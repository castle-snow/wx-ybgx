import PIXI from './pixi-wx.js'; import Phaser from './phaser-wx-main.js'; Phaser.TilemapLayer = function (game, tilemap, index, width, height) { width |= 0; height |= 0; Phaser.Sprite.call(this, game, 0, 0); this.map = tilemap; this.index = index; this.layer = tilemap.layers[index]; this.canvas = PIXI.CanvasPool.create(this, width, height); this.context = this.canvas.getContext('2d'); this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))); this.type = Phaser.TILEMAPLAYER; this.physicsType = Phaser.TILEMAPLAYER; this.renderSettings = { enableScrollDelta: false, overdrawRatio: 0.20, copyCanvas: null }; this.debug = false; this.exists = true; this.debugSettings = { missingImageFill: 'rgb(255,255,255)', debuggedTileOverfill: 'rgba(0,255,0,0.4)', forceFullRedraw: true, debugAlpha: 0.5, facingEdgeStroke: 'rgba(0,255,0,1)', collidingTileOverfill: 'rgba(0,255,0,0.2)' }; this.scrollFactorX = 1; this.scrollFactorY = 1; this.dirty = true; this.rayStepRate = 4; this._wrap = false; this._mc = { scrollX: 0, scrollY: 0, renderWidth: 0, renderHeight: 0, tileWidth: tilemap.tileWidth, tileHeight: tilemap.tileHeight, cw: tilemap.tileWidth, ch: tilemap.tileHeight, tilesets: [] }; this._scrollX = 0; this._scrollY = 0; this._results = []; if (!game.device.canvasBitBltShift) { this.renderSettings.copyCanvas = Phaser.TilemapLayer.ensureSharedCopyCanvas(); } this.fixedToCamera = true; }; Phaser.TilemapLayer.prototype = Object.create(Phaser.Sprite.prototype); Phaser.TilemapLayer.prototype.constructor = Phaser.TilemapLayer; Phaser.TilemapLayer.prototype.preUpdateCore = Phaser.Component.Core.preUpdate; Phaser.TilemapLayer.sharedCopyCanvas = null; Phaser.TilemapLayer.ensureSharedCopyCanvas = function () { if (!this.sharedCopyCanvas) { this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2); } return this.sharedCopyCanvas; }; Phaser.TilemapLayer.prototype.preUpdate = function() { return this.preUpdateCore(); }; Phaser.TilemapLayer.prototype.postUpdate = function () { if (this.fixedToCamera) { this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x; this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y; } this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x; this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y; }; Phaser.TilemapLayer.prototype._renderCanvas = function (renderSession) { if (this.fixedToCamera) { this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x; this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y; } this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x; this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y; this.render(); PIXI.Sprite.prototype._renderCanvas.call(this, renderSession); }; Phaser.TilemapLayer.prototype._renderWebGL = function (renderSession) { if (this.fixedToCamera) { this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x; this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y; } this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x; this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y; this.render(); PIXI.Sprite.prototype._renderWebGL.call(this, renderSession); }; Phaser.TilemapLayer.prototype.destroy = function() { PIXI.CanvasPool.remove(this); Phaser.Component.Destroy.prototype.destroy.call(this); }; Phaser.TilemapLayer.prototype.resize = function (width, height) { this.canvas.width = width; this.canvas.height = height; this.texture.frame.resize(width, height); this.texture.width = width; this.texture.height = height; this.texture.crop.width = width; this.texture.crop.height = height; this.texture.baseTexture.width = width; this.texture.baseTexture.height = height; this.texture.baseTexture.dirty(); this.texture.requiresUpdate = true; this.texture._updateUvs(); this.dirty = true; }; Phaser.TilemapLayer.prototype.resizeWorld = function () { this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y); }; Phaser.TilemapLayer.prototype._fixX = function (x) { if (this.scrollFactorX === 1 || (this.scrollFactorX === 0 && this.position.x === 0)) { return x; } if (this.scrollFactorX === 0 && this.position.x !== 0) { return x - this.position.x; } return this._scrollX + (x - (this._scrollX / this.scrollFactorX)); }; Phaser.TilemapLayer.prototype._unfixX = function (x) { if (this.scrollFactorX === 1) { return x; } return (this._scrollX / this.scrollFactorX) + (x - this._scrollX); }; Phaser.TilemapLayer.prototype._fixY = function (y) { if (this.scrollFactorY === 1 || (this.scrollFactorY === 0 && this.position.y === 0)) { return y; } if (this.scrollFactorY === 0 && this.position.y !== 0) { return y - this.position.y; } return this._scrollY + (y - (this._scrollY / this.scrollFactorY)); }; Phaser.TilemapLayer.prototype._unfixY = function (y) { if (this.scrollFactorY === 1) { return y; } return (this._scrollY / this.scrollFactorY) + (y - this._scrollY); }; Phaser.TilemapLayer.prototype.getTileX = function (x) { return Math.floor(this._fixX(x) / this._mc.tileWidth); }; Phaser.TilemapLayer.prototype.getTileY = function (y) { return Math.floor(this._fixY(y) / this._mc.tileHeight); }; Phaser.TilemapLayer.prototype.getTileXY = function (x, y, point) { point.x = this.getTileX(x); point.y = this.getTileY(y); return point; }; Phaser.TilemapLayer.prototype.getRayCastTiles = function (line, stepRate, collides, interestingFace) { if (!stepRate) { stepRate = this.rayStepRate; } if (collides === undefined) { collides = false; } if (interestingFace === undefined) { interestingFace = false; } var tiles = this.getTiles(line.x, line.y, line.width, line.height, collides, interestingFace); if (tiles.length === 0) { return []; } var coords = line.coordinatesOnLine(stepRate); var results = []; for (var i = 0; i < tiles.length; i++) { for (var t = 0; t < coords.length; t++) { var tile = tiles[i]; var coord = coords[t]; if (tile.containsPoint(coord[0], coord[1])) { results.push(tile); break; } } } return results; }; Phaser.TilemapLayer.prototype.getTiles = function (x, y, width, height, collides, interestingFace) { if (collides === undefined) { collides = false; } if (interestingFace === undefined) { interestingFace = false; } var fetchAll = !(collides || interestingFace); x = this._fixX(x); y = this._fixY(y); var tx = Math.floor(x / (this._mc.cw * this.scale.x)); var ty = Math.floor(y / (this._mc.ch * this.scale.y)); var tw = Math.ceil((x + width) / (this._mc.cw * this.scale.x)) - tx; var th = Math.ceil((y + height) / (this._mc.ch * this.scale.y)) - ty; while (this._results.length) { this._results.pop(); } for (var wy = ty; wy < ty + th; wy++) { for (var wx = tx; wx < tx + tw; wx++) { var row = this.layer.data[wy]; if (row && row[wx]) { if (fetchAll || row[wx].isInteresting(collides, interestingFace)) { this._results.push(row[wx]); } } } } return this._results.slice(); }; Phaser.TilemapLayer.prototype.resolveTileset = function (tileIndex) { var tilesets = this._mc.tilesets; if (tileIndex < 2000) { while (tilesets.length < tileIndex) { tilesets.push(undefined); } } var setIndex = this.map.tiles[tileIndex] && this.map.tiles[tileIndex][2]; if (setIndex !== null) { var tileset = this.map.tilesets[setIndex]; if (tileset && tileset.containsTileIndex(tileIndex)) { return (tilesets[tileIndex] = tileset); } } return (tilesets[tileIndex] = null); }; Phaser.TilemapLayer.prototype.resetTilesetCache = function () { var tilesets = this._mc.tilesets; while (tilesets.length) { tilesets.pop(); } }; Phaser.TilemapLayer.prototype.setScale = function (xScale, yScale) { xScale = xScale || 1; yScale = yScale || xScale; for (var y = 0; y < this.layer.data.length; y++) { var row = this.layer.data[y]; for (var x = 0; x < row.length; x++) { var tile = row[x]; tile.width = this.map.tileWidth * xScale; tile.height = this.map.tileHeight * yScale; tile.worldX = tile.x * tile.width; tile.worldY = tile.y * tile.height; } } this.scale.setTo(xScale, yScale); }; Phaser.TilemapLayer.prototype.shiftCanvas = function (context, x, y) { var canvas = context.canvas; var copyW = canvas.width - Math.abs(x); var copyH = canvas.height - Math.abs(y); var dx = 0; var dy = 0; var sx = x; var sy = y; if (x < 0) { dx = -x; sx = 0; } if (y < 0) { dy = -y; sy = 0; } var copyCanvas = this.renderSettings.copyCanvas; if (copyCanvas) { if (copyCanvas.width < copyW || copyCanvas.height < copyH) { copyCanvas.width = copyW; copyCanvas.height = copyH; } var copyContext = copyCanvas.getContext('2d'); copyContext.clearRect(0, 0, copyW, copyH); copyContext.drawImage(canvas, dx, dy, copyW, copyH, 0, 0, copyW, copyH); context.clearRect(sx, sy, copyW, copyH); context.drawImage(copyCanvas, 0, 0, copyW, copyH, sx, sy, copyW, copyH); } else { context.save(); context.globalCompositeOperation = 'copy'; context.drawImage(canvas, dx, dy, copyW, copyH, sx, sy, copyW, copyH); context.restore(); } }; Phaser.TilemapLayer.prototype.renderRegion = function (scrollX, scrollY, left, top, right, bottom) { var context = this.context; var width = this.layer.width; var height = this.layer.height; var tw = this._mc.tileWidth; var th = this._mc.tileHeight; var tilesets = this._mc.tilesets; var lastAlpha = NaN; if (!this._wrap) { if (left <= right) { left = Math.max(0, left); right = Math.min(width - 1, right); } if (top <= bottom) { top = Math.max(0, top); bottom = Math.min(height - 1, bottom); } } var baseX = (left * tw) - scrollX; var baseY = (top * th) - scrollY; var normStartX = (left + ((1 << 20) * width)) % width; var normStartY = (top + ((1 << 20) * height)) % height; var tx, ty, x, y, xmax, ymax; for (y = normStartY, ymax = bottom - top, ty = baseY; ymax >= 0; y++, ymax--, ty += th) { if (y >= height) { y -= height; } var row = this.layer.data[y]; for (x = normStartX, xmax = right - left, tx = baseX; xmax >= 0; x++, xmax--, tx += tw) { if (x >= width) { x -= width; } var tile = row[x]; if (!tile || tile.index < 0) { continue; } var index = tile.index; var set = tilesets[index]; if (set === undefined) { set = this.resolveTileset(index); } if (tile.alpha !== lastAlpha && !this.debug) { context.globalAlpha = tile.alpha; lastAlpha = tile.alpha; } if (set) { if (tile.rotation || tile.flipped) { context.save(); context.translate(tx + tile.centerX, ty + tile.centerY); context.rotate(tile.rotation); if (tile.flipped) { context.scale(-1, 1); } set.draw(context, -tile.centerX, -tile.centerY, index); context.restore(); } else { set.draw(context, tx, ty, index); } } else if (this.debugSettings.missingImageFill) { context.fillStyle = this.debugSettings.missingImageFill; context.fillRect(tx, ty, tw, th); } if (tile.debug && this.debugSettings.debuggedTileOverfill) { context.fillStyle = this.debugSettings.debuggedTileOverfill; context.fillRect(tx, ty, tw, th); } } } }; Phaser.TilemapLayer.prototype.renderDeltaScroll = function (shiftX, shiftY) { var scrollX = this._mc.scrollX; var scrollY = this._mc.scrollY; var renderW = this.canvas.width; var renderH = this.canvas.height; var tw = this._mc.tileWidth; var th = this._mc.tileHeight; var left = 0; var right = -tw; var top = 0; var bottom = -th; if (shiftX < 0) { left = renderW + shiftX; right = renderW - 1; } else if (shiftX > 0) { right = shiftX; } if (shiftY < 0) { top = renderH + shiftY; bottom = renderH - 1; } else if (shiftY > 0) { bottom = shiftY; } this.shiftCanvas(this.context, shiftX, shiftY); left = Math.floor((left + scrollX) / tw); right = Math.floor((right + scrollX) / tw); top = Math.floor((top + scrollY) / th); bottom = Math.floor((bottom + scrollY) / th); if (left <= right) { this.context.clearRect(((left * tw) - scrollX), 0, (right - left + 1) * tw, renderH); var trueTop = Math.floor((0 + scrollY) / th); var trueBottom = Math.floor((renderH - 1 + scrollY) / th); this.renderRegion(scrollX, scrollY, left, trueTop, right, trueBottom); } if (top <= bottom) { this.context.clearRect(0, ((top * th) - scrollY), renderW, (bottom - top + 1) * th); var trueLeft = Math.floor((0 + scrollX) / tw); var trueRight = Math.floor((renderW - 1 + scrollX) / tw); this.renderRegion(scrollX, scrollY, trueLeft, top, trueRight, bottom); } }; Phaser.TilemapLayer.prototype.renderFull = function () { var scrollX = this._mc.scrollX; var scrollY = this._mc.scrollY; var renderW = this.canvas.width; var renderH = this.canvas.height; var tw = this._mc.tileWidth; var th = this._mc.tileHeight; var left = Math.floor(scrollX / tw); var right = Math.floor((renderW - 1 + scrollX) / tw); var top = Math.floor(scrollY / th); var bottom = Math.floor((renderH - 1 + scrollY) / th); this.context.clearRect(0, 0, renderW, renderH); this.renderRegion(scrollX, scrollY, left, top, right, bottom); }; Phaser.TilemapLayer.prototype.render = function () { var redrawAll = false; if (!this.visible) { return; } if (this.dirty || this.layer.dirty) { this.layer.dirty = false; redrawAll = true; } var renderWidth = this.canvas.width; var renderHeight = this.canvas.height; var scrollX = this._scrollX | 0; var scrollY = this._scrollY | 0; var mc = this._mc; var shiftX = mc.scrollX - scrollX; var shiftY = mc.scrollY - scrollY; if (!redrawAll && shiftX === 0 && shiftY === 0 && mc.renderWidth === renderWidth && mc.renderHeight === renderHeight) { return; } this.context.save(); mc.scrollX = scrollX; mc.scrollY = scrollY; if (mc.renderWidth !== renderWidth || mc.renderHeight !== renderHeight) { mc.renderWidth = renderWidth; mc.renderHeight = renderHeight; } if (this.debug) { this.context.globalAlpha = this.debugSettings.debugAlpha; if (this.debugSettings.forceFullRedraw) { redrawAll = true; } } if (!redrawAll && this.renderSettings.enableScrollDelta && (Math.abs(shiftX) + Math.abs(shiftY)) < Math.min(renderWidth, renderHeight)) { this.renderDeltaScroll(shiftX, shiftY); } else { this.renderFull(); } if (this.debug) { this.context.globalAlpha = 1; this.renderDebug(); } this.texture.baseTexture.dirty(); this.dirty = false; this.context.restore(); return true; }; Phaser.TilemapLayer.prototype.renderDebug = function () { var scrollX = this._mc.scrollX; var scrollY = this._mc.scrollY; var context = this.context; var renderW = this.canvas.width; var renderH = this.canvas.height; var width = this.layer.width; var height = this.layer.height; var tw = this._mc.tileWidth; var th = this._mc.tileHeight; var left = Math.floor(scrollX / tw); var right = Math.floor((renderW - 1 + scrollX) / tw); var top = Math.floor(scrollY / th); var bottom = Math.floor((renderH - 1 + scrollY) / th); var baseX = (left * tw) - scrollX; var baseY = (top * th) - scrollY; var normStartX = (left + ((1 << 20) * width)) % width; var normStartY = (top + ((1 << 20) * height)) % height; var tx, ty, x, y, xmax, ymax; context.strokeStyle = this.debugSettings.facingEdgeStroke; for (y = normStartY, ymax = bottom - top, ty = baseY; ymax >= 0; y++, ymax--, ty += th) { if (y >= height) { y -= height; } var row = this.layer.data[y]; for (x = normStartX, xmax = right - left, tx = baseX; xmax >= 0; x++, xmax--, tx += tw) { if (x >= width) { x -= width; } var tile = row[x]; if (!tile || tile.index < 0 || !tile.collides) { continue; } if (this.debugSettings.collidingTileOverfill) { context.fillStyle = this.debugSettings.collidingTileOverfill; context.fillRect(tx, ty, this._mc.cw, this._mc.ch); } if (this.debugSettings.facingEdgeStroke) { context.beginPath(); if (tile.faceTop) { context.moveTo(tx, ty); context.lineTo(tx + this._mc.cw, ty); } if (tile.faceBottom) { context.moveTo(tx, ty + this._mc.ch); context.lineTo(tx + this._mc.cw, ty + this._mc.ch); } if (tile.faceLeft) { context.moveTo(tx, ty); context.lineTo(tx, ty + this._mc.ch); } if (tile.faceRight) { context.moveTo(tx + this._mc.cw, ty); context.lineTo(tx + this._mc.cw, ty + this._mc.ch); } context.closePath(); context.stroke(); } } } }; Object.defineProperty(Phaser.TilemapLayer.prototype, "wrap", { get: function () { return this._wrap; }, set: function (value) { this._wrap = value; this.dirty = true; } }); Object.defineProperty(Phaser.TilemapLayer.prototype, "scrollX", { get: function () { return this._scrollX; }, set: function (value) { this._scrollX = value; } }); Object.defineProperty(Phaser.TilemapLayer.prototype, "scrollY", { get: function () { return this._scrollY; }, set: function (value) { this._scrollY = value; } }); Object.defineProperty(Phaser.TilemapLayer.prototype, "collisionWidth", { get: function () { return this._mc.cw; }, set: function (value) { this._mc.cw = value | 0; this.dirty = true; } }); Object.defineProperty(Phaser.TilemapLayer.prototype, "collisionHeight", { get: function () { return this._mc.ch; }, set: function (value) { this._mc.ch = value | 0; this.dirty = true; } }); Phaser.TilemapParser = { INSERT_NULL: false, parse: function (game, key, tileWidth, tileHeight, width, height) { if (tileWidth === undefined) { tileWidth = 32; } if (tileHeight === undefined) { tileHeight = 32; } if (width === undefined) { width = 10; } if (height === undefined) { height = 10; } if (key === undefined) { return this.getEmptyData(); } if (key === null) { return this.getEmptyData(tileWidth, tileHeight, width, height); } var map = game.cache.getTilemapData(key); if (map) { if (map.format === Phaser.Tilemap.CSV) { return this.parseCSV(key, map.data, tileWidth, tileHeight); } else if (!map.format || map.format === Phaser.Tilemap.TILED_JSON) { return this.parseTiledJSON(map.data); } } else { console.warn('Phaser.TilemapParser.parse - No map data found for key ' + key); } }, parseCSV: function (key, data, tileWidth, tileHeight) { var map = this.getEmptyData(); data = data.trim(); var output = []; var rows = data.split("\n"); var height = rows.length; var width = 0; for (var y = 0; y < rows.length; y++) { output[y] = []; var column = rows[y].split(","); for (var x = 0; x < column.length; x++) { output[y][x] = new Phaser.Tile(map.layers[0], parseInt(column[x], 10), x, y, tileWidth, tileHeight); } if (width === 0) { width = column.length; } } map.format = Phaser.Tilemap.CSV; map.name = key; map.width = width; map.height = height; map.tileWidth = tileWidth; map.tileHeight = tileHeight; map.widthInPixels = width * tileWidth; map.heightInPixels = height * tileHeight; map.layers[0].width = width; map.layers[0].height = height; map.layers[0].widthInPixels = map.widthInPixels; map.layers[0].heightInPixels = map.heightInPixels; map.layers[0].data = output; return map; }, getEmptyData: function (tileWidth, tileHeight, width, height) { return { width: (width !== undefined && width !== null) ? width : 0, height: (height !== undefined && height !== null) ? height : 0, tileWidth: (tileWidth !== undefined && tileWidth !== null) ? tileWidth : 0, tileHeight: (tileHeight !== undefined && tileHeight !== null) ? tileHeight : 0, orientation: 'orthogonal', version: '1', properties: {}, widthInPixels: 0, heightInPixels: 0, layers: [ { name: 'layer', x: 0, y: 0, width: 0, height: 0, widthInPixels: 0, heightInPixels: 0, alpha: 1, visible: true, properties: {}, indexes: [], callbacks: [], bodies: [], data: [] } ], images: [], objects: {}, collision: {}, tilesets: [], tiles: [] }; }, parseTiledJSON: function (json) { if (json.orientation !== 'orthogonal') { console.warn('TilemapParser.parseTiledJSON - Only orthogonal map types are supported in this version of Phaser'); return null; } var map = { width: json.width, height: json.height, tileWidth: json.tilewidth, tileHeight: json.tileheight, orientation: json.orientation, format: Phaser.Tilemap.TILED_JSON, version: json.version, properties: json.properties, widthInPixels: json.width * json.tilewidth, heightInPixels: json.height * json.tileheight }; var layers = []; for (var i = 0; i < json.layers.length; i++) { if (json.layers[i].type !== 'tilelayer') { continue; } var curl = json.layers[i]; if (!curl.compression && curl.encoding && curl.encoding === 'base64') { var binaryString = window.atob(curl.data); var len = binaryString.length; var bytes = new Array(len); for (var j = 0; j < len; j+=4) { bytes[j / 4] = ( binaryString.charCodeAt(j) | binaryString.charCodeAt(j + 1) << 8 | binaryString.charCodeAt(j + 2) << 16 | binaryString.charCodeAt(j + 3) << 24 ) >>> 0; } curl.data = bytes; delete curl.encoding; } else if (curl.compression) { console.warn('TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer \'' + curl.name + '\''); continue; } var layer = { name: curl.name, x: curl.x, y: curl.y, width: curl.width, height: curl.height, widthInPixels: curl.width * json.tilewidth, heightInPixels: curl.height * json.tileheight, alpha: curl.opacity, visible: curl.visible, properties: {}, indexes: [], callbacks: [], bodies: [] }; if (curl.properties) { layer.properties = curl.properties; } var x = 0; var row = []; var output = []; var rotation, flipped, flippedVal, gid; for (var t = 0, len = curl.data.length; t < len; t++) { rotation = 0; flipped = false; gid = curl.data[t]; flippedVal = 0; if (gid > 0x20000000) { if (gid > 0x80000000) { gid -= 0x80000000; flippedVal += 4; } if (gid > 0x40000000) { gid -= 0x40000000; flippedVal += 2; } if (gid > 0x20000000) { gid -= 0x20000000; flippedVal += 1; } switch (flippedVal) { case 5: rotation = Math.PI / 2; break; case 6: rotation = Math.PI; break; case 3: rotation = 3 * Math.PI / 2; break; case 4: rotation = 0; flipped = true; break; case 7: rotation = Math.PI / 2; flipped = true; break; case 2: rotation = Math.PI; flipped = true; break; case 1: rotation = 3 * Math.PI / 2; flipped = true; break; } } if (gid > 0) { var tile = new Phaser.Tile(layer, gid, x, output.length, json.tilewidth, json.tileheight); tile.rotation = rotation; tile.flipped = flipped; if (flippedVal !== 0) { tile.flippedVal = flippedVal; } row.push(tile); } else { if (Phaser.TilemapParser.INSERT_NULL) { row.push(null); } else { row.push(new Phaser.Tile(layer, -1, x, output.length, json.tilewidth, json.tileheight)); } } x++; if (x === curl.width) { output.push(row); x = 0; row = []; } } layer.data = output; layers.push(layer); } map.layers = layers; var images = []; for (var i = 0; i < json.layers.length; i++) { if (json.layers[i].type !== 'imagelayer') { continue; } var curi = json.layers[i]; var image = { name: curi.name, image: curi.image, x: curi.x, y: curi.y, alpha: curi.opacity, visible: curi.visible, properties: {} }; if (curi.properties) { image.properties = curi.properties; } images.push(image); } map.images = images; var tilesets = []; var imagecollections = []; var lastSet = null; for (var i = 0; i < json.tilesets.length; i++) { var set = json.tilesets[i]; if (set.image) { var newSet = new Phaser.Tileset(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties); if (set.tileproperties) { newSet.tileProperties = set.tileproperties; } newSet.updateTileData(set.imagewidth, set.imageheight); tilesets.push(newSet); } else { var newCollection = new Phaser.ImageCollection(set.name, set.firstgid, set.tilewidth, set.tileheight, set.margin, set.spacing, set.properties); for (var ti in set.tiles) { var image = set.tiles[ti].image; var gid = set.firstgid + parseInt(ti, 10); newCollection.addImage(gid, image); } imagecollections.push(newCollection); } if (lastSet) { lastSet.lastgid = set.firstgid - 1; } lastSet = set; } map.tilesets = tilesets; map.imagecollections = imagecollections; var objects = {}; var collision = {}; function slice (obj, fields) { var sliced = {}; for (var k in fields) { var key = fields[k]; if (typeof obj[key] !== 'undefined') { sliced[key] = obj[key]; } } return sliced; } for (var i = 0; i < json.layers.length; i++) { if (json.layers[i].type !== 'objectgroup') { continue; } var curo = json.layers[i]; objects[curo.name] = []; collision[curo.name] = []; for (var v = 0, len = curo.objects.length; v < len; v++) { if (curo.objects[v].gid) { var object = { gid: curo.objects[v].gid, name: curo.objects[v].name, type: curo.objects[v].hasOwnProperty("type") ? curo.objects[v].type : "", x: curo.objects[v].x, y: curo.objects[v].y, visible: curo.objects[v].visible, properties: curo.objects[v].properties }; if (curo.objects[v].rotation) { object.rotation = curo.objects[v].rotation; } objects[curo.name].push(object); } else if (curo.objects[v].polyline) { var object = { name: curo.objects[v].name, type: curo.objects[v].type, x: curo.objects[v].x, y: curo.objects[v].y, width: curo.objects[v].width, height: curo.objects[v].height, visible: curo.objects[v].visible, properties: curo.objects[v].properties }; if (curo.objects[v].rotation) { object.rotation = curo.objects[v].rotation; } object.polyline = []; for (var p = 0; p < curo.objects[v].polyline.length; p++) { object.polyline.push([ curo.objects[v].polyline[p].x, curo.objects[v].polyline[p].y ]); } collision[curo.name].push(object); objects[curo.name].push(object); } else if (curo.objects[v].polygon) { var object = slice(curo.objects[v], ['name', 'type', 'x', 'y', 'visible', 'rotation', 'properties']); object.polygon = []; for (var p = 0; p < curo.objects[v].polygon.length; p++) { object.polygon.push([curo.objects[v].polygon[p].x, curo.objects[v].polygon[p].y]); } objects[curo.name].push(object); } else if (curo.objects[v].ellipse) { var object = slice(curo.objects[v], ['name', 'type', 'ellipse', 'x', 'y', 'width', 'height', 'visible', 'rotation', 'properties']); objects[curo.name].push(object); } else { var object = slice(curo.objects[v], ['name', 'type', 'x', 'y', 'width', 'height', 'visible', 'rotation', 'properties']); object.rectangle = true; objects[curo.name].push(object); } } } map.objects = objects; map.collision = collision; map.tiles = []; for (var i = 0; i < map.tilesets.length; i++) { var set = map.tilesets[i]; var x = set.tileMargin; var y = set.tileMargin; var count = 0; var countX = 0; var countY = 0; for (var t = set.firstgid; t < set.firstgid + set.total; t++) { map.tiles[t] = [x, y, i]; x += set.tileWidth + set.tileSpacing; count++; if (count === set.total) { break; } countX++; if (countX === set.columns) { x = set.tileMargin; y += set.tileHeight + set.tileSpacing; countX = 0; countY++; if (countY === set.rows) { break; } } } } var layer; var tile; var sid; var set; for (var i = 0; i < map.layers.length; i++) { layer = map.layers[i]; set = null; for (var j = 0; j < layer.data.length; j++) { row = layer.data[j]; for (var k = 0; k < row.length; k++) { tile = row[k]; if (tile === null || tile.index < 0) { continue; } sid = map.tiles[tile.index][2]; set = map.tilesets[sid]; if (set.tileProperties && set.tileProperties[tile.index - set.firstgid]) { tile.properties = Phaser.Utils.mixin(set.tileProperties[tile.index - set.firstgid], tile.properties); } } } } return map; } }; Phaser.Tileset = function (name, firstgid, width, height, margin, spacing, properties) { if (width === undefined || width <= 0) { width = 32; } if (height === undefined || height <= 0) { height = 32; } if (margin === undefined) { margin = 0; } if (spacing === undefined) { spacing = 0; } this.name = name; this.firstgid = firstgid | 0; this.tileWidth = width | 0; this.tileHeight = height | 0; this.tileMargin = margin | 0; this.tileSpacing = spacing | 0; this.properties = properties || {}; this.image = null; this.rows = 0; this.columns = 0; this.total = 0; this.drawCoords = []; }; Phaser.Tileset.prototype = { draw: function (context, x, y, index) { var coordIndex = (index - this.firstgid) << 1; if (coordIndex >= 0 && (coordIndex + 1) < this.drawCoords.length) { context.drawImage( this.image, this.drawCoords[coordIndex], this.drawCoords[coordIndex + 1], this.tileWidth, this.tileHeight, x, y, this.tileWidth, this.tileHeight ); } }, containsTileIndex: function (tileIndex) { return ( tileIndex >= this.firstgid && tileIndex < (this.firstgid + this.total) ); }, setImage: function (image) { this.image = image; this.updateTileData(image.width, image.height); }, setSpacing: function (margin, spacing) { this.tileMargin = margin | 0; this.tileSpacing = spacing | 0; if (this.image) { this.updateTileData(this.image.width, this.image.height); } }, updateTileData: function (imageWidth, imageHeight) { var rowCount = (imageHeight - this.tileMargin * 2 + this.tileSpacing) / (this.tileHeight + this.tileSpacing); var colCount = (imageWidth - this.tileMargin * 2 + this.tileSpacing) / (this.tileWidth + this.tileSpacing); if (rowCount % 1 !== 0 || colCount % 1 !== 0) { console.warn("Phaser.Tileset - " + this.name + " image tile area is not an even multiple of tile size"); } rowCount = Math.floor(rowCount); colCount = Math.floor(colCount); if ((this.rows && this.rows !== rowCount) || (this.columns && this.columns !== colCount)) { console.warn("Phaser.Tileset - actual and expected number of tile rows and columns differ"); } this.rows = rowCount; this.columns = colCount; this.total = rowCount * colCount; this.drawCoords.length = 0; var tx = this.tileMargin; var ty = this.tileMargin; for (var y = 0; y < this.rows; y++) { for (var x = 0; x < this.columns; x++) { this.drawCoords.push(tx); this.drawCoords.push(ty); tx += this.tileWidth + this.tileSpacing; } tx = this.tileMargin; ty += this.tileHeight + this.tileSpacing; } } }; Phaser.Tileset.prototype.constructor = Phaser.Tileset; Phaser.Particle = function (game, x, y, key, frame) { Phaser.Sprite.call(this, game, x, y, key, frame); this.autoScale = false; this.scaleData = null; this._s = 0; this.autoAlpha = false; this.alphaData = null; this._a = 0; }; Phaser.Particle.prototype = Object.create(Phaser.Sprite.prototype); Phaser.Particle.prototype.constructor = Phaser.Particle; Phaser.Particle.prototype.update = function() { if (this.autoScale) { this._s--; if (this._s) { this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y); } else { this.autoScale = false; } } if (this.autoAlpha) { this._a--; if (this._a) { this.alpha = this.alphaData[this._a].v; } else { this.autoAlpha = false; } } }; Phaser.Particle.prototype.onEmit = function() { }; Phaser.Particle.prototype.setAlphaData = function(data) { this.alphaData = data; this._a = data.length - 1; this.alpha = this.alphaData[this._a].v; this.autoAlpha = true; }; Phaser.Particle.prototype.setScaleData = function(data) { this.scaleData = data; this._s = data.length - 1; this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y); this.autoScale = true; }; Phaser.Particle.prototype.reset = function(x, y, health) { Phaser.Component.Reset.prototype.reset.call(this, x, y, health); this.alpha = 1; this.scale.set(1); this.autoScale = false; this.autoAlpha = false; return this; }; Phaser.Particles = function (game) { this.game = game; this.emitters = {}; this.ID = 0; }; Phaser.Particles.prototype = { add: function (emitter) { this.emitters[emitter.name] = emitter; return emitter; }, remove: function (emitter) { delete this.emitters[emitter.name]; }, update: function () { for (var key in this.emitters) { if (this.emitters[key].exists) { this.emitters[key].update(); } } } }; Phaser.Particles.prototype.constructor = Phaser.Particles; Phaser.Particles.Arcade = {}; Phaser.Particles.Arcade.Emitter = function (game, x, y, maxParticles) { this.maxParticles = maxParticles || 50; Phaser.Group.call(this, game); this.name = 'emitter' + this.game.particles.ID++; this.type = Phaser.EMITTER; this.physicsType = Phaser.GROUP; this.area = new Phaser.Rectangle(x, y, 1, 1); this.minParticleSpeed = new Phaser.Point(-100, -100); this.maxParticleSpeed = new Phaser.Point(100, 100); this.minParticleScale = 1; this.maxParticleScale = 1; this.scaleData = null; this.minRotation = -360; this.maxRotation = 360; this.minParticleAlpha = 1; this.maxParticleAlpha = 1; this.alphaData = null; this.gravity = 100; this.particleClass = Phaser.Particle; this.particleDrag = new Phaser.Point(); this.angularDrag = 0; this.frequency = 100; this.lifespan = 2000; this.bounce = new Phaser.Point(); this.on = false; this.particleAnchor = new Phaser.Point(0.5, 0.5); this.blendMode = Phaser.blendModes.NORMAL; this.emitX = x; this.emitY = y; this.autoScale = false; this.autoAlpha = false; this.particleBringToTop = false; this.particleSendToBack = false; this._minParticleScale = new Phaser.Point(1, 1); this._maxParticleScale = new Phaser.Point(1, 1); this._quantity = 0; this._timer = 0; this._counter = 0; this._flowQuantity = 0; this._flowTotal = 0; this._explode = true; this._frames = null; }; Phaser.Particles.Arcade.Emitter.prototype = Object.create(Phaser.Group.prototype); Phaser.Particles.Arcade.Emitter.prototype.constructor = Phaser.Particles.Arcade.Emitter; Phaser.Particles.Arcade.Emitter.prototype.update = function () { if (this.on && this.game.time.time >= this._timer) { this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion; if (this._flowTotal !== 0) { if (this._flowQuantity > 0) { for (var i = 0; i < this._flowQuantity; i++) { if (this.emitParticle()) { this._counter++; if (this._flowTotal !== -1 && this._counter >= this._flowTotal) { this.on = false; break; } } } } else { if (this.emitParticle()) { this._counter++; if (this._flowTotal !== -1 && this._counter >= this._flowTotal) { this.on = false; } } } } else { if (this.emitParticle()) { this._counter++; if (this._quantity > 0 && this._counter >= this._quantity) { this.on = false; } } } } var i = this.children.length; while (i--) { if (this.children[i].exists) { this.children[i].update(); } } }; Phaser.Particles.Arcade.Emitter.prototype.makeParticles = function (keys, frames, quantity, collide, collideWorldBounds) { if (frames === undefined) { frames = 0; } if (quantity === undefined) { quantity = this.maxParticles; } if (collide === undefined) { collide = false; } if (collideWorldBounds === undefined) { collideWorldBounds = false; } var particle; var i = 0; var rndKey = keys; var rndFrame = frames; this._frames = frames; if (quantity > this.maxParticles) { this.maxParticles = quantity; } while (i < quantity) { if (Array.isArray(keys)) { rndKey = this.game.rnd.pick(keys); } if (Array.isArray(frames)) { rndFrame = this.game.rnd.pick(frames); } particle = new this.particleClass(this.game, 0, 0, rndKey, rndFrame); this.game.physics.arcade.enable(particle, false); if (collide) { particle.body.checkCollision.any = true; particle.body.checkCollision.none = false; } else { particle.body.checkCollision.none = true; } particle.body.collideWorldBounds = collideWorldBounds; particle.body.skipQuadTree = true; particle.exists = false; particle.visible = false; particle.anchor.copyFrom(this.particleAnchor); this.add(particle); i++; } return this; }; Phaser.Particles.Arcade.Emitter.prototype.kill = function () { this.on = false; this.alive = false; this.exists = false; return this; }; Phaser.Particles.Arcade.Emitter.prototype.revive = function () { this.alive = true; this.exists = true; return this; }; Phaser.Particles.Arcade.Emitter.prototype.explode = function (lifespan, quantity) { this._flowTotal = 0; this.start(true, lifespan, 0, quantity, false); return this; }; Phaser.Particles.Arcade.Emitter.prototype.flow = function (lifespan, frequency, quantity, total, immediate) { if (quantity === undefined || quantity === 0) { quantity = 1; } if (total === undefined) { total = -1; } if (immediate === undefined) { immediate = true; } if (quantity > this.maxParticles) { quantity = this.maxParticles; } this._counter = 0; this._flowQuantity = quantity; this._flowTotal = total; if (immediate) { this.start(true, lifespan, frequency, quantity); this._counter += quantity; this.on = true; this._timer = this.game.time.time + frequency * this.game.time.slowMotion; } else { this.start(false, lifespan, frequency, quantity); } return this; }; Phaser.Particles.Arcade.Emitter.prototype.start = function (explode, lifespan, frequency, quantity, forceQuantity) { if (explode === undefined) { explode = true; } if (lifespan === undefined) { lifespan = 0; } if (frequency === undefined || frequency === null) { frequency = 250; } if (quantity === undefined) { quantity = 0; } if (forceQuantity === undefined) { forceQuantity = false; } if (quantity > this.maxParticles) { quantity = this.maxParticles; } this.revive(); this.visible = true; this.lifespan = lifespan; this.frequency = frequency; if (explode || forceQuantity) { for (var i = 0; i < quantity; i++) { this.emitParticle(); } } else { this.on = true; this._quantity = quantity; this._counter = 0; this._timer = this.game.time.time + frequency * this.game.time.slowMotion; } return this; }; Phaser.Particles.Arcade.Emitter.prototype.emitParticle = function (x, y, key, frame) { if (x === undefined) { x = null; } if (y === undefined) { y = null; } var particle = this.getFirstExists(false); if (particle === null) { return false; } var rnd = this.game.rnd; if (key !== undefined && frame !== undefined) { particle.loadTexture(key, frame); } else if (key !== undefined) { particle.loadTexture(key); } var emitX = this.emitX; var emitY = this.emitY; if (x !== null) { emitX = x; } else if (this.width > 1) { emitX = rnd.between(this.left, this.right); } if (y !== null) { emitY = y; } else if (this.height > 1) { emitY = rnd.between(this.top, this.bottom); } particle.reset(emitX, emitY); particle.angle = 0; particle.lifespan = this.lifespan; if (this.particleBringToTop) { this.bringToTop(particle); } else if (this.particleSendToBack) { this.sendToBack(particle); } if (this.autoScale) { particle.setScaleData(this.scaleData); } else if (this.minParticleScale !== 1 || this.maxParticleScale !== 1) { particle.scale.set(rnd.realInRange(this.minParticleScale, this.maxParticleScale)); } else if ((this._minParticleScale.x !== this._maxParticleScale.x) || (this._minParticleScale.y !== this._maxParticleScale.y)) { particle.scale.set(rnd.realInRange(this._minParticleScale.x, this._maxParticleScale.x), rnd.realInRange(this._minParticleScale.y, this._maxParticleScale.y)); } if (frame === undefined) { if (Array.isArray(this._frames)) { particle.frame = this.game.rnd.pick(this._frames); } else { particle.frame = this._frames; } } if (this.autoAlpha) { particle.setAlphaData(this.alphaData); } else { particle.alpha = rnd.realInRange(this.minParticleAlpha, this.maxParticleAlpha); } particle.blendMode = this.blendMode; var body = particle.body; body.updateBounds(); body.bounce.copyFrom(this.bounce); body.drag.copyFrom(this.particleDrag); body.velocity.x = rnd.between(this.minParticleSpeed.x, this.maxParticleSpeed.x); body.velocity.y = rnd.between(this.minParticleSpeed.y, this.maxParticleSpeed.y); body.angularVelocity = rnd.between(this.minRotation, this.maxRotation); body.gravity.y = this.gravity; body.angularDrag = this.angularDrag; particle.onEmit(); return true; }; Phaser.Particles.Arcade.Emitter.prototype.destroy = function () { this.game.particles.remove(this); Phaser.Group.prototype.destroy.call(this, true, false); }; Phaser.Particles.Arcade.Emitter.prototype.setSize = function (width, height) { this.area.width = width; this.area.height = height; return this; }; Phaser.Particles.Arcade.Emitter.prototype.setXSpeed = function (min, max) { min = min || 0; max = max || 0; this.minParticleSpeed.x = min; this.maxParticleSpeed.x = max; return this; }; Phaser.Particles.Arcade.Emitter.prototype.setYSpeed = function (min, max) { min = min || 0; max = max || 0; this.minParticleSpeed.y = min; this.maxParticleSpeed.y = max; return this; }; Phaser.Particles.Arcade.Emitter.prototype.setRotation = function (min, max) { min = min || 0; max = max || 0; this.minRotation = min; this.maxRotation = max; return this; }; Phaser.Particles.Arcade.Emitter.prototype.setAlpha = function (min, max, rate, ease, yoyo) { if (min === undefined) { min = 1; } if (max === undefined) { max = 1; } if (rate === undefined) { rate = 0; } if (ease === undefined) { ease = Phaser.Easing.Linear.None; } if (yoyo === undefined) { yoyo = false; } this.minParticleAlpha = min; this.maxParticleAlpha = max; this.autoAlpha = false; if (rate > 0 && min !== max) { var tweenData = { v: min }; var tween = this.game.make.tween(tweenData).to( { v: max }, rate, ease); tween.yoyo(yoyo); this.alphaData = tween.generateData(60); this.alphaData.reverse(); this.autoAlpha = true; } return this; }; Phaser.Particles.Arcade.Emitter.prototype.setScale = function (minX, maxX, minY, maxY, rate, ease, yoyo) { if (minX === undefined) { minX = 1; } if (maxX === undefined) { maxX = 1; } if (minY === undefined) { minY = 1; } if (maxY === undefined) { maxY = 1; } if (rate === undefined) { rate = 0; } if (ease === undefined) { ease = Phaser.Easing.Linear.None; } if (yoyo === undefined) { yoyo = false; } this.minParticleScale = 1; this.maxParticleScale = 1; this._minParticleScale.set(minX, minY); this._maxParticleScale.set(maxX, maxY); this.autoScale = false; if (rate > 0 && ((minX !== maxX) || (minY !== maxY))) { var tweenData = { x: minX, y: minY }; var tween = this.game.make.tween(tweenData).to( { x: maxX, y: maxY }, rate, ease); tween.yoyo(yoyo); this.scaleData = tween.generateData(60); this.scaleData.reverse(); this.autoScale = true; } return this; }; Phaser.Particles.Arcade.Emitter.prototype.at = function (object) { if (object.center) { this.emitX = object.center.x; this.emitY = object.center.y; } else { this.emitX = object.world.x + (object.anchor.x * object.width); this.emitY = object.world.y + (object.anchor.y * object.height); } return this; }; Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "width", { get: function () { return this.area.width; }, set: function (value) { this.area.width = value; } }); Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "height", { get: function () { return this.area.height; }, set: function (value) { this.area.height = value; } }); Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "x", { get: function () { return this.emitX; }, set: function (value) { this.emitX = value; } }); Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "y", { get: function () { return this.emitY; }, set: function (value) { this.emitY = value; } }); Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "left", { get: function () { return Math.floor(this.x - (this.area.width / 2)); } }); Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "right", { get: function () { return Math.floor(this.x + (this.area.width / 2)); } }); Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "top", { get: function () { return Math.floor(this.y - (this.area.height / 2)); } }); Object.defineProperty(Phaser.Particles.Arcade.Emitter.prototype, "bottom", { get: function () { return Math.floor(this.y + (this.area.height / 2)); } }); Phaser.Weapon = function (game, parent) { Phaser.Plugin.call(this, game, parent); this.bullets = null; this.autoExpandBulletsGroup = false; this.autofire = false; this.shots = 0; this.fireLimit = 0; this.fireRate = 100; this.fireRateVariance = 0; this.fireFrom = new Phaser.Rectangle(0, 0, 1, 1); this.fireAngle = Phaser.ANGLE_UP; this.bulletInheritSpriteSpeed = false; this.bulletAnimation = ''; this.bulletFrameRandom = false; this.bulletFrameCycle = false; this.bulletWorldWrap = false; this.bulletWorldWrapPadding = 0; this.bulletAngleOffset = 0; this.bulletAngleVariance = 0; this.bulletSpeed = 200; this.bulletSpeedVariance = 0; this.bulletLifespan = 0; this.bulletKillDistance = 0; this.bulletGravity = new Phaser.Point(0, 0); this.bulletRotateToVelocity = false; this.bulletKey = ''; this.bulletFrame = ''; this._bulletClass = Phaser.Bullet; this._bulletCollideWorldBounds = false; this._bulletKillType = Phaser.Weapon.KILL_WORLD_BOUNDS; this._data = { customBody: false, width: 0, height: 0, offsetX: 0, offsetY: 0 }; this.bounds = new Phaser.Rectangle(); this.bulletBounds = game.world.bounds; this.bulletFrames = []; this.bulletFrameIndex = 0; this.anims = {}; this.onFire = new Phaser.Signal(); this.onKill = new Phaser.Signal(); this.onFireLimit = new Phaser.Signal(); this.trackedSprite = null; this.trackedPointer = null; this.trackRotation = false; this.trackOffset = new Phaser.Point(); this._nextFire = 0; this._rotatedPoint = new Phaser.Point(); }; Phaser.Weapon.prototype = Object.create(Phaser.Plugin.prototype); Phaser.Weapon.prototype.constructor = Phaser.Weapon; Phaser.Weapon.KILL_NEVER = 0; Phaser.Weapon.KILL_LIFESPAN = 1; Phaser.Weapon.KILL_DISTANCE = 2; Phaser.Weapon.KILL_WEAPON_BOUNDS = 3; Phaser.Weapon.KILL_CAMERA_BOUNDS = 4; Phaser.Weapon.KILL_WORLD_BOUNDS = 5; Phaser.Weapon.KILL_STATIC_BOUNDS = 6; Phaser.Weapon.prototype.createBullets = function (quantity, key, frame, group) { if (quantity === undefined) { quantity = 1; } if (group === undefined) { group = this.game.world; } if (!this.bullets) { this.bullets = this.game.add.physicsGroup(Phaser.Physics.ARCADE, group); this.bullets.classType = this._bulletClass; } if (quantity !== 0) { if (quantity === -1) { this.autoExpandBulletsGroup = true; quantity = 1; } this.bullets.createMultiple(quantity, key, frame); this.bullets.setAll('data.bulletManager', this); this.bulletKey = key; this.bulletFrame = frame; } return this; }; Phaser.Weapon.prototype.forEach = function (callback, callbackContext) { this.bullets.forEachExists(callback, callbackContext, arguments); return this; }; Phaser.Weapon.prototype.pauseAll = function () { this.bullets.setAll('body.enable', false); return this; }; Phaser.Weapon.prototype.resumeAll = function () { this.bullets.setAll('body.enable', true); return this; }; Phaser.Weapon.prototype.killAll = function () { this.bullets.callAllExists('kill', true); this.bullets.setAll('body.enable', true); return this; }; Phaser.Weapon.prototype.resetShots = function (newLimit) { this.shots = 0; if (newLimit !== undefined) { this.fireLimit = newLimit; } return this; }; Phaser.Weapon.prototype.destroy = function () { this.parent.remove(this, false); this.bullets.destroy(); this.game = null; this.parent = null; this.active = false; this.visible = false; }; Phaser.Weapon.prototype.update = function () { if (this._bulletKillType === Phaser.Weapon.KILL_WEAPON_BOUNDS) { if (this.trackedSprite) { this.trackedSprite.updateTransform(); this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y); } else if (this.trackedPointer) { this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY); } } if (this.autofire) { this.fire(); } }; Phaser.Weapon.prototype.trackSprite = function (sprite, offsetX, offsetY, trackRotation) { if (offsetX === undefined) { offsetX = 0; } if (offsetY === undefined) { offsetY = 0; } if (trackRotation === undefined) { trackRotation = false; } this.trackedPointer = null; this.trackedSprite = sprite; this.trackRotation = trackRotation; this.trackOffset.set(offsetX, offsetY); return this; }; Phaser.Weapon.prototype.trackPointer = function (pointer, offsetX, offsetY) { if (pointer === undefined) { pointer = this.game.input.activePointer; } if (offsetX === undefined) { offsetX = 0; } if (offsetY === undefined) { offsetY = 0; } this.trackedPointer = pointer; this.trackedSprite = null; this.trackRotation = false; this.trackOffset.set(offsetX, offsetY); return this; }; Phaser.Weapon.prototype.fire = function (from, x, y) { if (this.game.time.now < this._nextFire || (this.fireLimit > 0 && this.shots === this.fireLimit)) { return false; } var speed = this.bulletSpeed; if (this.bulletSpeedVariance !== 0) { speed += Phaser.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance); } if (from) { if (this.fireFrom.width > 1) { this.fireFrom.centerOn(from.x, from.y); } else { this.fireFrom.x = from.x; this.fireFrom.y = from.y; } } else if (this.trackedSprite) { if (this.trackRotation) { this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y); this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation); if (this.fireFrom.width > 1) { this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y); } else { this.fireFrom.x = this._rotatedPoint.x; this.fireFrom.y = this._rotatedPoint.y; } } else { if (this.fireFrom.width > 1) { this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y); } else { this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x; this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y; } } if (this.bulletInheritSpriteSpeed) { speed += this.trackedSprite.body.speed; } } else if (this.trackedPointer) { if (this.fireFrom.width > 1) { this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y); } else { this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x; this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y; } } var fromX = (this.fireFrom.width > 1) ? this.fireFrom.randomX : this.fireFrom.x; var fromY = (this.fireFrom.height > 1) ? this.fireFrom.randomY : this.fireFrom.y; var angle = (this.trackRotation) ? this.trackedSprite.angle : this.fireAngle; if (x !== undefined && y !== undefined) { angle = this.game.math.radToDeg(Math.atan2(y - fromY, x - fromX)); } if (this.bulletAngleVariance !== 0) { angle += Phaser.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance); } var moveX = 0; var moveY = 0; if (angle === 0 || angle === 180) { moveX = Math.cos(this.game.math.degToRad(angle)) * speed; } else if (angle === 90 || angle === 270) { moveY = Math.sin(this.game.math.degToRad(angle)) * speed; } else { moveX = Math.cos(this.game.math.degToRad(angle)) * speed; moveY = Math.sin(this.game.math.degToRad(angle)) * speed; } var bullet = null; if (this.autoExpandBulletsGroup) { bullet = this.bullets.getFirstExists(false, true, fromX, fromY, this.bulletKey, this.bulletFrame); bullet.data.bulletManager = this; } else { bullet = this.bullets.getFirstExists(false); } if (bullet) { bullet.reset(fromX, fromY); bullet.data.fromX = fromX; bullet.data.fromY = fromY; bullet.data.killType = this.bulletKillType; bullet.data.killDistance = this.bulletKillDistance; bullet.data.rotateToVelocity = this.bulletRotateToVelocity; if (this.bulletKillType === Phaser.Weapon.KILL_LIFESPAN) { bullet.lifespan = this.bulletLifespan; } bullet.angle = angle + this.bulletAngleOffset; if (this.bulletAnimation !== '') { if (bullet.animations.getAnimation(this.bulletAnimation) === null) { var anim = this.anims[this.bulletAnimation]; bullet.animations.add(anim.name, anim.frames, anim.frameRate, anim.loop, anim.useNumericIndex); } bullet.animations.play(this.bulletAnimation); } else { if (this.bulletFrameCycle) { bullet.frame = this.bulletFrames[this.bulletFrameIndex]; this.bulletFrameIndex++; if (this.bulletFrameIndex >= this.bulletFrames.length) { this.bulletFrameIndex = 0; } } else if (this.bulletFrameRandom) { bullet.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]; } } if (bullet.data.bodyDirty) { if (this._data.customBody) { bullet.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY); } bullet.body.collideWorldBounds = this.bulletCollideWorldBounds; bullet.data.bodyDirty = false; } bullet.body.velocity.set(moveX, moveY); bullet.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y); if (this.bulletSpeedVariance !== 0) { var rate = this.fireRate; rate += Phaser.Math.between(-this.fireRateVariance, this.fireRateVariance); if (rate < 0) { rate = 0; } this._nextFire = this.game.time.now + rate; } else { this._nextFire = this.game.time.now + this.fireRate; } this.shots++; this.onFire.dispatch(bullet, this, speed); if (this.fireLimit > 0 && this.shots === this.fireLimit) { this.onFireLimit.dispatch(this, this.fireLimit); } } return bullet; }; Phaser.Weapon.prototype.fireAtPointer = function (pointer) { if (pointer === undefined) { pointer = this.game.input.activePointer; } return this.fire(null, pointer.worldX, pointer.worldY); }; Phaser.Weapon.prototype.fireAtSprite = function (sprite) { return this.fire(null, sprite.world.x, sprite.world.y); }; Phaser.Weapon.prototype.fireAtXY = function (x, y) { return this.fire(null, x, y); }; Phaser.Weapon.prototype.setBulletBodyOffset = function (width, height, offsetX, offsetY) { if (offsetX === undefined) { offsetX = 0; } if (offsetY === undefined) { offsetY = 0; } this._data.customBody = true; this._data.width = width; this._data.height = height; this._data.offsetX = offsetX; this._data.offsetY = offsetY; this.bullets.callAll('body.setSize', 'body', width, height, offsetX, offsetY); this.bullets.setAll('data.bodyDirty', false); return this; }; Phaser.Weapon.prototype.setBulletFrames = function (min, max, cycle, random) { if (cycle === undefined) { cycle = true; } if (random === undefined) { random = false; } this.bulletFrames = Phaser.ArrayUtils.numberArray(min, max); this.bulletFrameIndex = 0; this.bulletFrameCycle = cycle; this.bulletFrameRandom = random; return this; }; Phaser.Weapon.prototype.addBulletAnimation = function (name, frames, frameRate, loop, useNumericIndex) { this.anims[name] = { name: name, frames: frames, frameRate: frameRate, loop: loop, useNumericIndex: useNumericIndex }; this.bullets.callAll('animations.add', 'animations', name, frames, frameRate, loop, useNumericIndex); this.bulletAnimation = name; return this; }; Phaser.Weapon.prototype.debug = function (x, y, debugBodies) { if (x === undefined) { x = 16; } if (y === undefined) { y = 32; } if (debugBodies === undefined) { debugBodies = false; } this.game.debug.text("Weapon Plugin", x, y); this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, x, y + 24); if (debugBodies) { this.bullets.forEachExists(this.game.debug.body, this.game.debug, 'rgba(255, 0, 255, 0.8)'); } }; Object.defineProperty(Phaser.Weapon.prototype, "bulletClass", { get: function () { return this._bulletClass; }, set: function (classType) { this._bulletClass = classType; this.bullets.classType = this._bulletClass; } }); Object.defineProperty(Phaser.Weapon.prototype, "bulletKillType", { get: function () { return this._bulletKillType; }, set: function (type) { switch (type) { case Phaser.Weapon.KILL_STATIC_BOUNDS: case Phaser.Weapon.KILL_WEAPON_BOUNDS: this.bulletBounds = this.bounds; break; case Phaser.Weapon.KILL_CAMERA_BOUNDS: this.bulletBounds = this.game.camera.view; break; case Phaser.Weapon.KILL_WORLD_BOUNDS: this.bulletBounds = this.game.world.bounds; break; } this._bulletKillType = type; } }); Object.defineProperty(Phaser.Weapon.prototype, "bulletCollideWorldBounds", { get: function () { return this._bulletCollideWorldBounds; }, set: function (value) { this._bulletCollideWorldBounds = value; this.bullets.setAll('body.collideWorldBounds', value); this.bullets.setAll('data.bodyDirty', false); } }); Object.defineProperty(Phaser.Weapon.prototype, "x", { get: function () { return this.fireFrom.x; }, set: function (value) { this.fireFrom.x = value; } }); Object.defineProperty(Phaser.Weapon.prototype, "y", { get: function () { return this.fireFrom.y; }, set: function (value) { this.fireFrom.y = value; } }); Phaser.Bullet = function (game, x, y, key, frame) { Phaser.Sprite.call(this, game, x, y, key, frame); this.anchor.set(0.5); this.data = { bulletManager: null, fromX: 0, fromY: 0, bodyDirty: true, rotateToVelocity: false, killType: 0, killDistance: 0 }; }; Phaser.Bullet.prototype = Object.create(Phaser.Sprite.prototype); Phaser.Bullet.prototype.constructor = Phaser.Bullet; Phaser.Bullet.prototype.kill = function () { this.alive = false; this.exists = false; this.visible = false; this.data.bulletManager.onKill.dispatch(this); return this; }; Phaser.Bullet.prototype.update = function () { if (!this.exists) { return; } if (this.data.killType > Phaser.Weapon.KILL_LIFESPAN) { if (this.data.killType === Phaser.Weapon.KILL_DISTANCE) { if (this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, true) > this.data.killDistance) { this.kill(); } } else { if (!this.data.bulletManager.bulletBounds.intersects(this)) { this.kill(); } } } if (this.data.rotateToVelocity) { this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x); } if (this.data.bulletManager.bulletWorldWrap) { this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding); } }; Phaser.Video = function (game, key, url) { if (key === undefined) { key = null; } if (url === undefined) { url = null; } this.game = game; this.key = key; this.width = 0; this.height = 0; this.type = Phaser.VIDEO; this.disableTextureUpload = false; this.touchLocked = false; this.onPlay = new Phaser.Signal(); this.onChangeSource = new Phaser.Signal(); this.onComplete = new Phaser.Signal(); this.onAccess = new Phaser.Signal(); this.onError = new Phaser.Signal(); this.onTimeout = new Phaser.Signal(); this.timeout = 15000; this._timeOutID = null; this.video = null; this.videoStream = null; this.isStreaming = false; this.retryLimit = 20; this.retry = 0; this.retryInterval = 500; this._retryID = null; this._codeMuted = false; this._muted = false; this._codePaused = false; this._paused = false; this._pending = false; this._autoplay = false; this._endCallback = null; this._playCallback = null; if (key && this.game.cache.checkVideoKey(key)) { var _video = this.game.cache.getVideo(key); if (_video.isBlob) { this.createVideoFromBlob(_video.data); } else { this.video = _video.data; } this.width = this.video.videoWidth; this.height = this.video.videoHeight; } else if (url) { this.createVideoFromURL(url, false); } if (this.video && !url) { this.baseTexture = new PIXI.BaseTexture(this.video); this.baseTexture.forceLoaded(this.width, this.height); } else { this.baseTexture = new PIXI.BaseTexture(Phaser.Cache.DEFAULT.baseTexture.source); this.baseTexture.forceLoaded(this.width, this.height); } this.texture = new PIXI.Texture(this.baseTexture); this.textureFrame = new Phaser.Frame(0, 0, 0, this.width, this.height, 'video'); this.texture.setFrame(this.textureFrame); this.texture.valid = false; if (key !== null && this.video) { this.texture.valid = this.video.canplay; } this.snapshot = null; if (Phaser.BitmapData) { this.snapshot = new Phaser.BitmapData(this.game, '', this.width, this.height); } if (!this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || (window['PhaserGlobal'] && window['PhaserGlobal'].fakeiOSTouchLock)) { this.setTouchLock(); } else { if (_video) { _video.locked = false; } } }; Phaser.Video.prototype = { connectToMediaStream: function (video, stream) { if (video && stream) { this.video = video; this.videoStream = stream; this.isStreaming = true; this.baseTexture.source = this.video; this.updateTexture(null, this.video.videoWidth, this.video.videoHeight); this.onAccess.dispatch(this); } return this; }, startMediaStream: function (captureAudio, width, height) { if (captureAudio === undefined) { captureAudio = false; } if (width === undefined) { width = null; } if (height === undefined) { height = null; } if (!this.game.device.getUserMedia) { this.onError.dispatch(this, 'No getUserMedia'); return false; } if (this.videoStream !== null) { if (this.videoStream['active']) { this.videoStream.active = false; } else { this.videoStream.stop(); } } this.removeVideoElement(); this.video = document.createElement("video"); this.video.setAttribute('autoplay', 'autoplay'); if (width !== null) { this.video.width = width; } if (height !== null) { this.video.height = height; } this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout); try { navigator.getUserMedia( { "audio": captureAudio, "video": true }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this) ); } catch (error) { this.getUserMediaError(error); } return this; }, getUserMediaTimeout: function () { clearTimeout(this._timeOutID); this.onTimeout.dispatch(this); }, getUserMediaError: function (event) { clearTimeout(this._timeOutID); this.onError.dispatch(this, event); }, getUserMediaSuccess: function (stream) { clearTimeout(this._timeOutID); this.videoStream = stream; if (this.video.mozSrcObject !== undefined) { this.video.mozSrcObject = stream; } else { this.video.src = (window.URL && window.URL.createObjectURL(stream)) || stream; } var self = this; this.video.onloadeddata = function () { var retry = 10; function checkStream () { if (retry > 0) { if (self.video.videoWidth > 0) { var width = self.video.videoWidth; var height = self.video.videoHeight; if (isNaN(self.video.videoHeight)) { height = width / (4/3); } self.video.play(); self.isStreaming = true; self.baseTexture.source = self.video; self.updateTexture(null, width, height); self.onAccess.dispatch(self); } else { window.setTimeout(checkStream, 500); } } else { console.warn('Unable to connect to video stream. Webcam error?'); } retry--; } checkStream(); }; }, createVideoFromBlob: function (blob) { var _this = this; this.video = document.createElement("video"); this.video.controls = false; this.video.setAttribute('autoplay', 'autoplay'); this.video.addEventListener('loadeddata', function (event) { _this.updateTexture(event); }, true); this.video.src = window.URL.createObjectURL(blob); this.video.canplay = true; return this; }, createVideoFromURL: function (url, autoplay) { if (autoplay === undefined) { autoplay = false; } if (this.texture) { this.texture.valid = false; } this.video = document.createElement("video"); this.video.controls = false; if (autoplay) { this.video.setAttribute('autoplay', 'autoplay'); } this.video.src = url; this.video.canplay = true; this.video.load(); this.retry = this.retryLimit; this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval); this.key = url; return this; }, updateTexture: function (event, width, height) { var change = false; if (width === undefined || width === null) { width = this.video.videoWidth; change = true; } if (height === undefined || height === null) { height = this.video.videoHeight; } this.width = width; this.height = height; if (this.baseTexture.source !== this.video) { this.baseTexture.source = this.video; } this.baseTexture.forceLoaded(width, height); this.texture.frame.resize(width, height); this.texture.width = width; this.texture.height = height; this.texture.valid = true; if (this.snapshot) { this.snapshot.resize(width, height); } if (change && this.key !== null) { this.onChangeSource.dispatch(this, width, height); if (this._autoplay) { this.video.play(); this.onPlay.dispatch(this, this.loop, this.playbackRate); } } }, complete: function () { this.onComplete.dispatch(this); }, play: function (loop, playbackRate) { if (loop === undefined) { loop = false; } if (playbackRate === undefined) { playbackRate = 1; } if (this.game.sound.onMute) { this.game.sound.onMute.add(this.setMute, this); this.game.sound.onUnMute.add(this.unsetMute, this); if (this.game.sound.mute) { this.setMute(); } } this.game.onPause.add(this.setPause, this); this.game.onResume.add(this.setResume, this); this._endCallback = this.complete.bind(this); this.video.addEventListener('ended', this._endCallback, true); this.video.addEventListener('webkitendfullscreen', this._endCallback, true); if (loop) { this.video.loop = 'loop'; } else { this.video.loop = ''; } this.video.playbackRate = playbackRate; if (this.touchLocked) { this._pending = true; } else { this._pending = false; if (this.key !== null) { if (this.video.readyState !== 4) { this.retry = this.retryLimit; this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval); } else { this._playCallback = this.playHandler.bind(this); this.video.addEventListener('playing', this._playCallback, true); } } this.video.play(); this.onPlay.dispatch(this, loop, playbackRate); } return this; }, playHandler: function () { this.video.removeEventListener('playing', this._playCallback, true); this.updateTexture(); }, stop: function () { if (this.game.sound.onMute) { this.game.sound.onMute.remove(this.setMute, this); this.game.sound.onUnMute.remove(this.unsetMute, this); } this.game.onPause.remove(this.setPause, this); this.game.onResume.remove(this.setResume, this); if (this.isStreaming) { if (this.video.mozSrcObject) { this.video.mozSrcObject.stop(); this.video.src = null; } else { this.video.src = ""; if (this.videoStream['active']) { this.videoStream.active = false; } else { if (this.videoStream.getTracks) { this.videoStream.getTracks().forEach(function (track) { track.stop(); }); } else { this.videoStream.stop(); } } } this.videoStream = null; this.isStreaming = false; } else { this.video.removeEventListener('ended', this._endCallback, true); this.video.removeEventListener('webkitendfullscreen', this._endCallback, true); this.video.removeEventListener('playing', this._playCallback, true); if (this.touchLocked) { this._pending = false; } else { this.video.pause(); } } return this; }, add: function (object) { if (Array.isArray(object)) { for (var i = 0; i < object.length; i++) { if (object[i]['loadTexture']) { object[i].loadTexture(this); } } } else { object.loadTexture(this); } return this; }, addToWorld: function (x, y, anchorX, anchorY, scaleX, scaleY) { scaleX = scaleX || 1; scaleY = scaleY || 1; var image = this.game.add.image(x, y, this); image.anchor.set(anchorX, anchorY); image.scale.set(scaleX, scaleY); return image; }, render: function () { if (!this.disableTextureUpload && this.playing) { this.baseTexture.dirty(); } }, setMute: function () { if (this._muted) { return; } this._muted = true; this.video.muted = true; }, unsetMute: function () { if (!this._muted || this._codeMuted) { return; } this._muted = false; this.video.muted = false; }, setPause: function () { if (this._paused || this.touchLocked) { return; } this._paused = true; this.video.pause(); }, setResume: function () { if (!this._paused || this._codePaused || this.touchLocked) { return; } this._paused = false; if (!this.video.ended) { this.video.play(); } }, changeSource: function (src, autoplay) { if (autoplay === undefined) { autoplay = true; } this.texture.valid = false; this.video.pause(); this.retry = this.retryLimit; this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval); this.video.src = src; this.video.load(); this._autoplay = autoplay; if (!autoplay) { this.paused = true; } return this; }, checkVideoProgress: function () { if (this.video.readyState === 4) { this.updateTexture(); } else { this.retry--; if (this.retry > 0) { this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval); } else { console.warn('Phaser.Video: Unable to start downloading video in time', this.isStreaming); } } }, setTouchLock: function () { this.game.input.touch.addTouchLockCallback(this.unlock, this); this.touchLocked = true; }, unlock: function () { this.touchLocked = false; this.video.play(); this.onPlay.dispatch(this, this.loop, this.playbackRate); if (this.key) { var _video = this.game.cache.getVideo(this.key); if (_video && !_video.isBlob) { _video.locked = false; } } return true; }, grab: function (clear, alpha, blendMode) { if (clear === undefined) { clear = false; } if (alpha === undefined) { alpha = 1; } if (blendMode === undefined) { blendMode = null; } if (this.snapshot === null) { console.warn('Video.grab cannot run because Phaser.BitmapData is unavailable'); return; } if (clear) { this.snapshot.cls(); } this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, alpha, blendMode); return this.snapshot; }, removeVideoElement: function () { if (!this.video) { return; } if (this.video.parentNode) { this.video.parentNode.removeChild(this.video); } while (this.video.hasChildNodes()) { this.video.removeChild(this.video.firstChild); } this.video.removeAttribute('autoplay'); this.video.removeAttribute('src'); this.video = null; }, destroy: function () { this.stop(); this.removeVideoElement(); if (this.touchLocked) { this.game.input.touch.removeTouchLockCallback(this.unlock, this); } if (this._retryID) { window.clearTimeout(this._retryID); } } }; Object.defineProperty(Phaser.Video.prototype, "currentTime", { get: function () { return (this.video) ? this.video.currentTime : 0; }, set: function (value) { this.video.currentTime = value; } }); Object.defineProperty(Phaser.Video.prototype, "duration", { get: function () { return (this.video) ? this.video.duration : 0; } }); Object.defineProperty(Phaser.Video.prototype, "progress", { get: function () { return (this.video) ? (this.video.currentTime / this.video.duration) : 0; } }); Object.defineProperty(Phaser.Video.prototype, "mute", { get: function () { return this._muted; }, set: function (value) { value = value || null; if (value) { if (this._muted) { return; } this._codeMuted = true; this.setMute(); } else { if (!this._muted) { return; } this._codeMuted = false; this.unsetMute(); } } }); Object.defineProperty(Phaser.Video.prototype, "paused", { get: function () { return this._paused; }, set: function (value) { value = value || null; if (this.touchLocked) { return; } if (value) { if (this._paused) { return; } this._codePaused = true; this.setPause(); } else { if (!this._paused) { return; } this._codePaused = false; this.setResume(); } } }); Object.defineProperty(Phaser.Video.prototype, "volume", { get: function () { return (this.video) ? this.video.volume : 1; }, set: function (value) { if (value < 0) { value = 0; } else if (value > 1) { value = 1; } if (this.video) { this.video.volume = value; } } }); Object.defineProperty(Phaser.Video.prototype, "playbackRate", { get: function () { return (this.video) ? this.video.playbackRate : 1; }, set: function (value) { if (this.video) { this.video.playbackRate = value; } } }); Object.defineProperty(Phaser.Video.prototype, "loop", { get: function () { return (this.video) ? this.video.loop : false; }, set: function (value) { if (value && this.video) { this.video.loop = 'loop'; } else if (this.video) { this.video.loop = ''; } } }); Object.defineProperty(Phaser.Video.prototype, "playing", { get: function () { return !(this.video.paused && this.video.ended); } }); Phaser.Video.prototype.constructor = Phaser.Video; if (PIXI.blendModes === undefined) { PIXI.blendModes = Phaser.blendModes; } if (PIXI.scaleModes === undefined) { PIXI.scaleModes = Phaser.scaleModes; } if (PIXI.Texture.emptyTexture === undefined) { PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture()); } if (PIXI.DisplayObject._tempMatrix === undefined) { PIXI.DisplayObject._tempMatrix = new PIXI.Matrix(); } if (PIXI.RenderTexture.tempMatrix === undefined) { PIXI.RenderTexture.tempMatrix = new PIXI.Matrix(); } if (PIXI.Graphics && PIXI.Graphics.POLY === undefined) { PIXI.Graphics.POLY = Phaser.POLYGON; PIXI.Graphics.RECT = Phaser.RECTANGLE; PIXI.Graphics.CIRC = Phaser.CIRCLE; PIXI.Graphics.ELIP = Phaser.ELLIPSE; PIXI.Graphics.RREC = Phaser.ROUNDEDRECTANGLE; } PIXI.TextureSilentFail = true;