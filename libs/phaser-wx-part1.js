import PIXI from './pixi-wx.js'; import Phaser from './phaser-wx-main.js'; if (!Math.trunc) { Math.trunc = function trunc(x) { return x < 0 ? Math.ceil(x) : Math.floor(x); }; } if (!Function.prototype.bind) { Function.prototype.bind = (function () { var slice = Array.prototype.slice; return function (thisArg) { var target = this, boundArgs = slice.call(arguments, 1); if (typeof target !== 'function') { throw new TypeError(); } function bound() { var args = boundArgs.concat(slice.call(arguments)); target.apply(this instanceof bound ? this : thisArg, args); } bound.prototype = (function F(proto) { if (proto) { F.prototype = proto; } if (!(this instanceof F)) { return new F; } })(target.prototype); return bound; }; })(); } if (!Array.isArray) { Array.isArray = function (arg) { return Object.prototype.toString.call(arg) === '[object Array]'; }; } if (!Array.prototype.forEach) { Array.prototype.forEach = function(fun ) { "use strict"; if (this === void 0 || this === null) { throw new TypeError(); } var t = Object(this); var len = t.length >>> 0; if (typeof fun !== "function") { throw new TypeError(); } var thisArg = arguments.length >= 2 ? arguments[1] : void 0; for (var i = 0; i < len; i++) { if (i in t) { fun.call(thisArg, t[i], i, t); } } }; } if (typeof window.Uint32Array !== "function" && typeof window.Uint32Array !== "object") { var CheapArray = function(type) { var proto = new Array(); window[type] = function(arg) { if (typeof(arg) === "number") { Array.call(this, arg); this.length = arg; for (var i = 0; i < this.length; i++) { this[i] = 0; } } else { Array.call(this, arg.length); this.length = arg.length; for (var i = 0; i < this.length; i++) { this[i] = arg[i]; } } }; window[type].prototype = proto; window[type].constructor = window[type]; }; CheapArray('Uint32Array'); CheapArray('Int16Array'); } if (!window.console) { window.console = {}; window.console.log = window.console.assert = function(){}; window.console.warn = window.console.assert = function(){}; } Phaser.Utils = { reverseString: function (string) { return string.split('').reverse().join(''); }, getProperty: function(obj, prop) { var parts = prop.split('.'), last = parts.pop(), l = parts.length, i = 1, current = parts[0]; while (i < l && (obj = obj[current])) { current = parts[i]; i++; } if (obj) { return obj[last]; } else { return null; } }, setProperty: function(obj, prop, value) { var parts = prop.split('.'), last = parts.pop(), l = parts.length, i = 1, current = parts[0]; while (i < l && (obj = obj[current])) { current = parts[i]; i++; } if (obj) { obj[last] = value; } return obj; }, chanceRoll: function (chance) { if (chance === undefined) { chance = 50; } return chance > 0 && (Math.random() * 100 <= chance); }, randomChoice: function (choice1, choice2) { return (Math.random() < 0.5) ? choice1 : choice2; }, parseDimension: function (size, dimension) { var f = 0; var px = 0; if (typeof size === 'string') { if (size.substr(-1) === '%') { f = parseInt(size, 10) / 100; if (dimension === 0) { px = window.innerWidth * f; } else { px = window.innerHeight * f; } } else { px = parseInt(size, 10); } } else { px = size; } return px; }, pad: function (str, len, pad, dir) { if (len === undefined) { var len = 0; } if (pad === undefined) { var pad = ' '; } if (dir === undefined) { var dir = 3; } str = str.toString(); var padlen = 0; if (len + 1 >= str.length) { switch (dir) { case 1: str = new Array(len + 1 - str.length).join(pad) + str; break; case 3: var right = Math.ceil((padlen = len - str.length) / 2); var left = padlen - right; str = new Array(left+1).join(pad) + str + new Array(right+1).join(pad); break; default: str = str + new Array(len + 1 - str.length).join(pad); break; } } return str; }, isPlainObject: function (obj) { if (typeof(obj) !== "object" || obj.nodeType || obj === obj.window) { return false; } try { if (obj.constructor && !({}).hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) { return false; } } catch (e) { return false; } return true; }, extend: function () { var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false; if (typeof target === "boolean") { deep = target; target = arguments[1] || {}; i = 2; } if (length === i) { target = this; --i; } for (; i < length; i++) { if ((options = arguments[i]) != null) { for (name in options) { src = target[name]; copy = options[name]; if (target === copy) { continue; } if (deep && copy && (Phaser.Utils.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) { if (copyIsArray) { copyIsArray = false; clone = src && Array.isArray(src) ? src : []; } else { clone = src && Phaser.Utils.isPlainObject(src) ? src : {}; } target[name] = Phaser.Utils.extend(deep, clone, copy); } else if (copy !== undefined) { target[name] = copy; } } } } return target; }, mixinPrototype: function (target, mixin, replace) { if (replace === undefined) { replace = false; } var mixinKeys = Object.keys(mixin); for (var i = 0; i < mixinKeys.length; i++) { var key = mixinKeys[i]; var value = mixin[key]; if (!replace && (key in target)) { continue; } else { if (value && (typeof value.get === 'function' || typeof value.set === 'function')) { if (typeof value.clone === 'function') { target[key] = value.clone(); } else { Object.defineProperty(target, key, value); } } else { target[key] = value; } } } }, mixin: function (from, to) { if (!from || typeof (from) !== "object") { return to; } for (var key in from) { var o = from[key]; if (o.childNodes || o.cloneNode) { continue; } var type = typeof (from[key]); if (!from[key] || type !== "object") { to[key] = from[key]; } else { if (typeof (to[key]) === type) { to[key] = Phaser.Utils.mixin(from[key], to[key]); } else { to[key] = Phaser.Utils.mixin(from[key], new o.constructor()); } } } return to; } }; Phaser.Circle = function (x, y, diameter) { x = x || 0; y = y || 0; diameter = diameter || 0; this.x = x; this.y = y; this._diameter = diameter; this._radius = 0; if (diameter > 0) { this._radius = diameter * 0.5; } this.type = Phaser.CIRCLE; }; Phaser.Circle.prototype = { circumference: function () { return 2 * (Math.PI * this._radius); }, random: function (out) { if (out === undefined) { out = new Phaser.Point(); } var t = 2 * Math.PI * Math.random(); var u = Math.random() + Math.random(); var r = (u > 1) ? 2 - u : u; var x = r * Math.cos(t); var y = r * Math.sin(t); out.x = this.x + (x * this.radius); out.y = this.y + (y * this.radius); return out; }, getBounds: function () { return new Phaser.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter); }, setTo: function (x, y, diameter) { this.x = x; this.y = y; this._diameter = diameter; this._radius = diameter * 0.5; return this; }, copyFrom: function (source) { return this.setTo(source.x, source.y, source.diameter); }, copyTo: function (dest) { dest.x = this.x; dest.y = this.y; dest.diameter = this._diameter; return dest; }, distance: function (dest, round) { var distance = Phaser.Math.distance(this.x, this.y, dest.x, dest.y); return round ? Math.round(distance) : distance; }, clone: function (output) { if (output === undefined || output === null) { output = new Phaser.Circle(this.x, this.y, this.diameter); } else { output.setTo(this.x, this.y, this.diameter); } return output; }, contains: function (x, y) { return Phaser.Circle.contains(this, x, y); }, circumferencePoint: function (angle, asDegrees, out) { return Phaser.Circle.circumferencePoint(this, angle, asDegrees, out); }, offset: function (dx, dy) { this.x += dx; this.y += dy; return this; }, offsetPoint: function (point) { return this.offset(point.x, point.y); }, toString: function () { return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"; } }; Phaser.Circle.prototype.constructor = Phaser.Circle; Object.defineProperty(Phaser.Circle.prototype, "diameter", { get: function () { return this._diameter; }, set: function (value) { if (value > 0) { this._diameter = value; this._radius = value * 0.5; } } }); Object.defineProperty(Phaser.Circle.prototype, "radius", { get: function () { return this._radius; }, set: function (value) { if (value > 0) { this._radius = value; this._diameter = value * 2; } } }); Object.defineProperty(Phaser.Circle.prototype, "left", { get: function () { return this.x - this._radius; }, set: function (value) { if (value > this.x) { this._radius = 0; this._diameter = 0; } else { this.radius = this.x - value; } } }); Object.defineProperty(Phaser.Circle.prototype, "right", { get: function () { return this.x + this._radius; }, set: function (value) { if (value < this.x) { this._radius = 0; this._diameter = 0; } else { this.radius = value - this.x; } } }); Object.defineProperty(Phaser.Circle.prototype, "top", { get: function () { return this.y - this._radius; }, set: function (value) { if (value > this.y) { this._radius = 0; this._diameter = 0; } else { this.radius = this.y - value; } } }); Object.defineProperty(Phaser.Circle.prototype, "bottom", { get: function () { return this.y + this._radius; }, set: function (value) { if (value < this.y) { this._radius = 0; this._diameter = 0; } else { this.radius = value - this.y; } } }); Object.defineProperty(Phaser.Circle.prototype, "area", { get: function () { if (this._radius > 0) { return Math.PI * this._radius * this._radius; } else { return 0; } } }); Object.defineProperty(Phaser.Circle.prototype, "empty", { get: function () { return (this._diameter === 0); }, set: function (value) { if (value === true) { this.setTo(0, 0, 0); } } }); Phaser.Circle.contains = function (a, x, y) { if (a.radius > 0 && x >= a.left && x <= a.right && y >= a.top && y <= a.bottom) { var dx = (a.x - x) * (a.x - x); var dy = (a.y - y) * (a.y - y); return (dx + dy) <= (a.radius * a.radius); } else { return false; } }; Phaser.Circle.equals = function (a, b) { return (a.x === b.x && a.y === b.y && a.diameter === b.diameter); }; Phaser.Circle.intersects = function (a, b) { return (Phaser.Math.distance(a.x, a.y, b.x, b.y) <= (a.radius + b.radius)); }; Phaser.Circle.circumferencePoint = function (a, angle, asDegrees, out) { if (asDegrees === undefined) { asDegrees = false; } if (out === undefined) { out = new Phaser.Point(); } if (asDegrees === true) { angle = Phaser.Math.degToRad(angle); } out.x = a.x + a.radius * Math.cos(angle); out.y = a.y + a.radius * Math.sin(angle); return out; }; Phaser.Circle.intersectsRectangle = function (c, r) { var cx = Math.abs(c.x - r.x - r.halfWidth); var xDist = r.halfWidth + c.radius; if (cx > xDist) { return false; } var cy = Math.abs(c.y - r.y - r.halfHeight); var yDist = r.halfHeight + c.radius; if (cy > yDist) { return false; } if (cx <= r.halfWidth || cy <= r.halfHeight) { return true; } var xCornerDist = cx - r.halfWidth; var yCornerDist = cy - r.halfHeight; var xCornerDistSq = xCornerDist * xCornerDist; var yCornerDistSq = yCornerDist * yCornerDist; var maxCornerDistSq = c.radius * c.radius; return xCornerDistSq + yCornerDistSq <= maxCornerDistSq; }; PIXI.Circle = Phaser.Circle; Phaser.Ellipse = function (x, y, width, height) { x = x || 0; y = y || 0; width = width || 0; height = height || 0; this.x = x; this.y = y; this.width = width; this.height = height; this.type = Phaser.ELLIPSE; }; Phaser.Ellipse.prototype = { setTo: function (x, y, width, height) { this.x = x; this.y = y; this.width = width; this.height = height; return this; }, getBounds: function () { return new Phaser.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height); }, copyFrom: function (source) { return this.setTo(source.x, source.y, source.width, source.height); }, copyTo: function(dest) { dest.x = this.x; dest.y = this.y; dest.width = this.width; dest.height = this.height; return dest; }, clone: function(output) { if (output === undefined || output === null) { output = new Phaser.Ellipse(this.x, this.y, this.width, this.height); } else { output.setTo(this.x, this.y, this.width, this.height); } return output; }, contains: function (x, y) { return Phaser.Ellipse.contains(this, x, y); }, random: function (out) { if (out === undefined) { out = new Phaser.Point(); } var p = Math.random() * Math.PI * 2; var r = Math.random(); out.x = Math.sqrt(r) * Math.cos(p); out.y = Math.sqrt(r) * Math.sin(p); out.x = this.x + (out.x * this.width / 2.0); out.y = this.y + (out.y * this.height / 2.0); return out; }, toString: function () { return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"; } }; Phaser.Ellipse.prototype.constructor = Phaser.Ellipse; Object.defineProperty(Phaser.Ellipse.prototype, "left", { get: function () { return this.x; }, set: function (value) { this.x = value; } }); Object.defineProperty(Phaser.Ellipse.prototype, "right", { get: function () { return this.x + this.width; }, set: function (value) { if (value < this.x) { this.width = 0; } else { this.width = value - this.x; } } }); Object.defineProperty(Phaser.Ellipse.prototype, "top", { get: function () { return this.y; }, set: function (value) { this.y = value; } }); Object.defineProperty(Phaser.Ellipse.prototype, "bottom", { get: function () { return this.y + this.height; }, set: function (value) { if (value < this.y) { this.height = 0; } else { this.height = value - this.y; } } }); Object.defineProperty(Phaser.Ellipse.prototype, "empty", { get: function () { return (this.width === 0 || this.height === 0); }, set: function (value) { if (value === true) { this.setTo(0, 0, 0, 0); } } }); Phaser.Ellipse.contains = function (a, x, y) { if (a.width <= 0 || a.height <= 0) { return false; } var normx = ((x - a.x) / a.width) - 0.5; var normy = ((y - a.y) / a.height) - 0.5; normx *= normx; normy *= normy; return (normx + normy < 0.25); }; PIXI.Ellipse = Phaser.Ellipse; Phaser.Line = function (x1, y1, x2, y2) { x1 = x1 || 0; y1 = y1 || 0; x2 = x2 || 0; y2 = y2 || 0; this.start = new Phaser.Point(x1, y1); this.end = new Phaser.Point(x2, y2); this.type = Phaser.LINE; }; Phaser.Line.prototype = { setTo: function (x1, y1, x2, y2) { this.start.setTo(x1, y1); this.end.setTo(x2, y2); return this; }, fromSprite: function (startSprite, endSprite, useCenter) { if (useCenter === undefined) { useCenter = false; } if (useCenter) { return this.setTo(startSprite.center.x, startSprite.center.y, endSprite.center.x, endSprite.center.y); } return this.setTo(startSprite.x, startSprite.y, endSprite.x, endSprite.y); }, fromAngle: function (x, y, angle, length) { this.start.setTo(x, y); this.end.setTo(x + (Math.cos(angle) * length), y + (Math.sin(angle) * length)); return this; }, rotate: function (angle, asDegrees) { var cx = (this.start.x + this.end.x) / 2; var cy = (this.start.y + this.end.y) / 2; this.start.rotate(cx, cy, angle, asDegrees); this.end.rotate(cx, cy, angle, asDegrees); return this; }, rotateAround: function (x, y, angle, asDegrees) { this.start.rotate(x, y, angle, asDegrees); this.end.rotate(x, y, angle, asDegrees); return this; }, intersects: function (line, asSegment, result) { return Phaser.Line.intersectsPoints(this.start, this.end, line.start, line.end, asSegment, result); }, reflect: function (line) { return Phaser.Line.reflect(this, line); }, midPoint: function (out) { if (out === undefined) { out = new Phaser.Point(); } out.x = (this.start.x + this.end.x) / 2; out.y = (this.start.y + this.end.y) / 2; return out; }, centerOn: function (x, y) { var cx = (this.start.x + this.end.x) / 2; var cy = (this.start.y + this.end.y) / 2; var tx = x - cx; var ty = y - cy; this.start.add(tx, ty); this.end.add(tx, ty); }, pointOnLine: function (x, y) { return ((x - this.start.x) * (this.end.y - this.start.y) === (this.end.x - this.start.x) * (y - this.start.y)); }, pointOnSegment: function (x, y) { var xMin = Math.min(this.start.x, this.end.x); var xMax = Math.max(this.start.x, this.end.x); var yMin = Math.min(this.start.y, this.end.y); var yMax = Math.max(this.start.y, this.end.y); return (this.pointOnLine(x, y) && (x >= xMin && x <= xMax) && (y >= yMin && y <= yMax)); }, random: function (out) { if (out === undefined) { out = new Phaser.Point(); } var t = Math.random(); out.x = this.start.x + t * (this.end.x - this.start.x); out.y = this.start.y + t * (this.end.y - this.start.y); return out; }, coordinatesOnLine: function (stepRate, results) { if (stepRate === undefined) { stepRate = 1; } if (results === undefined) { results = []; } var x1 = Math.round(this.start.x); var y1 = Math.round(this.start.y); var x2 = Math.round(this.end.x); var y2 = Math.round(this.end.y); var dx = Math.abs(x2 - x1); var dy = Math.abs(y2 - y1); var sx = (x1 < x2) ? 1 : -1; var sy = (y1 < y2) ? 1 : -1; var err = dx - dy; results.push([x1, y1]); var i = 1; while (!((x1 === x2) && (y1 === y2))) { var e2 = err << 1; if (e2 > -dy) { err -= dy; x1 += sx; } if (e2 < dx) { err += dx; y1 += sy; } if (i % stepRate === 0) { results.push([x1, y1]); } i++; } return results; }, clone: function (output) { if (output === undefined || output === null) { output = new Phaser.Line(this.start.x, this.start.y, this.end.x, this.end.y); } else { output.setTo(this.start.x, this.start.y, this.end.x, this.end.y); } return output; } }; Object.defineProperty(Phaser.Line.prototype, "length", { get: function () { return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y)); } }); Object.defineProperty(Phaser.Line.prototype, "angle", { get: function () { return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x); } }); Object.defineProperty(Phaser.Line.prototype, "slope", { get: function () { return (this.end.y - this.start.y) / (this.end.x - this.start.x); } }); Object.defineProperty(Phaser.Line.prototype, "perpSlope", { get: function () { return -((this.end.x - this.start.x) / (this.end.y - this.start.y)); } }); Object.defineProperty(Phaser.Line.prototype, "x", { get: function () { return Math.min(this.start.x, this.end.x); } }); Object.defineProperty(Phaser.Line.prototype, "y", { get: function () { return Math.min(this.start.y, this.end.y); } }); Object.defineProperty(Phaser.Line.prototype, "left", { get: function () { return Math.min(this.start.x, this.end.x); } }); Object.defineProperty(Phaser.Line.prototype, "right", { get: function () { return Math.max(this.start.x, this.end.x); } }); Object.defineProperty(Phaser.Line.prototype, "top", { get: function () { return Math.min(this.start.y, this.end.y); } }); Object.defineProperty(Phaser.Line.prototype, "bottom", { get: function () { return Math.max(this.start.y, this.end.y); } }); Object.defineProperty(Phaser.Line.prototype, "width", { get: function () { return Math.abs(this.start.x - this.end.x); } }); Object.defineProperty(Phaser.Line.prototype, "height", { get: function () { return Math.abs(this.start.y - this.end.y); } }); Object.defineProperty(Phaser.Line.prototype, "normalX", { get: function () { return Math.cos(this.angle - 1.5707963267948966); } }); Object.defineProperty(Phaser.Line.prototype, "normalY", { get: function () { return Math.sin(this.angle - 1.5707963267948966); } }); Object.defineProperty(Phaser.Line.prototype, "normalAngle", { get: function () { return Phaser.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI); } }); Phaser.Line.intersectsPoints = function (a, b, e, f, asSegment, result) { if (asSegment === undefined) { asSegment = true; } if (result === undefined) { result = new Phaser.Point(); } var a1 = b.y - a.y; var a2 = f.y - e.y; var b1 = a.x - b.x; var b2 = e.x - f.x; var c1 = (b.x * a.y) - (a.x * b.y); var c2 = (f.x * e.y) - (e.x * f.y); var denom = (a1 * b2) - (a2 * b1); if (denom === 0) { return null; } result.x = ((b1 * c2) - (b2 * c1)) / denom; result.y = ((a2 * c1) - (a1 * c2)) / denom; if (asSegment) { var uc = ((f.y - e.y) * (b.x - a.x) - (f.x - e.x) * (b.y - a.y)); var ua = (((f.x - e.x) * (a.y - e.y)) - (f.y - e.y) * (a.x - e.x)) / uc; var ub = (((b.x - a.x) * (a.y - e.y)) - ((b.y - a.y) * (a.x - e.x))) / uc; if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) { return result; } else { return null; } } return result; }; Phaser.Line.intersects = function (a, b, asSegment, result) { return Phaser.Line.intersectsPoints(a.start, a.end, b.start, b.end, asSegment, result); }; Phaser.Line.intersectsRectangle = function (line, rect) { if (!Phaser.Rectangle.intersects(line, rect)) { return false; } var x1 = line.start.x; var y1 = line.start.y; var x2 = line.end.x; var y2 = line.end.y; var bx1 = rect.x; var by1 = rect.y; var bx2 = rect.right; var by2 = rect.bottom; var t = 0; if ((x1 >= bx1 && x1 <= bx2 && y1 >= by1 && y1 <= by2) || (x2 >= bx1 && x2 <= bx2 && y2 >= by1 && y2 <= by2)) { return true; } if (x1 < bx1 && x2 >= bx1) { t = y1 + (y2 - y1) * (bx1 - x1) / (x2 - x1); if (t > by1 && t <= by2) { return true; } } else if (x1 > bx2 && x2 <= bx2) { t = y1 + (y2 - y1) * (bx2 - x1) / (x2 - x1); if (t >= by1 && t <= by2) { return true; } } if (y1 < by1 && y2 >= by1) { t = x1 + (x2 - x1) * (by1 - y1) / (y2 - y1); if (t >= bx1 && t <= bx2) { return true; } } else if (y1 > by2 && y2 <= by2) { t = x1 + (x2 - x1) * (by2 - y1) / (y2 - y1); if (t >= bx1 && t <= bx2) { return true; } } return false; }; Phaser.Line.reflect = function (a, b) { return 2 * b.normalAngle - 3.141592653589793 - a.angle; }; Phaser.Matrix = function (a, b, c, d, tx, ty) { if (a === undefined || a === null) { a = 1; } if (b === undefined || b === null) { b = 0; } if (c === undefined || c === null) { c = 0; } if (d === undefined || d === null) { d = 1; } if (tx === undefined || tx === null) { tx = 0; } if (ty === undefined || ty === null) { ty = 0; } this.a = a; this.b = b; this.c = c; this.d = d; this.tx = tx; this.ty = ty; this.type = Phaser.MATRIX; }; Phaser.Matrix.prototype = { fromArray: function (array) { return this.setTo(array[0], array[1], array[3], array[4], array[2], array[5]); }, setTo: function (a, b, c, d, tx, ty) { this.a = a; this.b = b; this.c = c; this.d = d; this.tx = tx; this.ty = ty; return this; }, clone: function (output) { if (output === undefined || output === null) { output = new Phaser.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty); } else { output.a = this.a; output.b = this.b; output.c = this.c; output.d = this.d; output.tx = this.tx; output.ty = this.ty; } return output; }, copyTo: function (matrix) { matrix.copyFrom(this); return matrix; }, copyFrom: function (matrix) { this.a = matrix.a; this.b = matrix.b; this.c = matrix.c; this.d = matrix.d; this.tx = matrix.tx; this.ty = matrix.ty; return this; }, toArray: function (transpose, array) { if (array === undefined) { array = new PIXI.Float32Array(9); } if (transpose) { array[0] = this.a; array[1] = this.b; array[2] = 0; array[3] = this.c; array[4] = this.d; array[5] = 0; array[6] = this.tx; array[7] = this.ty; array[8] = 1; } else { array[0] = this.a; array[1] = this.c; array[2] = this.tx; array[3] = this.b; array[4] = this.d; array[5] = this.ty; array[6] = 0; array[7] = 0; array[8] = 1; } return array; }, apply: function (pos, newPos) { if (newPos === undefined) { newPos = new Phaser.Point(); } newPos.x = this.a * pos.x + this.c * pos.y + this.tx; newPos.y = this.b * pos.x + this.d * pos.y + this.ty; return newPos; }, applyInverse: function (pos, newPos) { if (newPos === undefined) { newPos = new Phaser.Point(); } var id = 1 / (this.a * this.d + this.c * -this.b); var x = pos.x; var y = pos.y; newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id; newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id; return newPos; }, translate: function (x, y) { this.tx += x; this.ty += y; return this; }, scale: function (x, y) { this.a *= x; this.d *= y; this.c *= x; this.b *= y; this.tx *= x; this.ty *= y; return this; }, rotate: function (angle) { var cos = Math.cos(angle); var sin = Math.sin(angle); var a1 = this.a; var c1 = this.c; var tx1 = this.tx; this.a = a1 * cos-this.b * sin; this.b = a1 * sin+this.b * cos; this.c = c1 * cos-this.d * sin; this.d = c1 * sin+this.d * cos; this.tx = tx1 * cos - this.ty * sin; this.ty = tx1 * sin + this.ty * cos; return this; }, append: function (matrix) { var a1 = this.a; var b1 = this.b; var c1 = this.c; var d1 = this.d; this.a  = matrix.a * a1 + matrix.b * c1; this.b  = matrix.a * b1 + matrix.b * d1; this.c  = matrix.c * a1 + matrix.d * c1; this.d  = matrix.c * b1 + matrix.d * d1; this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx; this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty; return this; }, identity: function () { return this.setTo(1, 0, 0, 1, 0, 0); } }; Phaser.identityMatrix = new Phaser.Matrix(); PIXI.Matrix = Phaser.Matrix; PIXI.identityMatrix = Phaser.identityMatrix; Phaser.Point = function (x, y) { x = x || 0; y = y || 0; this.x = x; this.y = y; this.type = Phaser.POINT; }; Phaser.Point.prototype = { copyFrom: function (source) { return this.setTo(source.x, source.y); }, invert: function () { return this.setTo(this.y, this.x); }, setTo: function (x, y) { this.x = x || 0; this.y = y || ( (y !== 0) ? this.x : 0 ); return this; }, set: function (x, y) { this.x = x || 0; this.y = y || ( (y !== 0) ? this.x : 0 ); return this; }, add: function (x, y) { this.x += x; this.y += y; return this; }, subtract: function (x, y) { this.x -= x; this.y -= y; return this; }, multiply: function (x, y) { this.x *= x; this.y *= y; return this; }, divide: function (x, y) { this.x /= x; this.y /= y; return this; }, clampX: function (min, max) { this.x = Phaser.Math.clamp(this.x, min, max); return this; }, clampY: function (min, max) { this.y = Phaser.Math.clamp(this.y, min, max); return this; }, clamp: function (min, max) { this.x = Phaser.Math.clamp(this.x, min, max); this.y = Phaser.Math.clamp(this.y, min, max); return this; }, clone: function (output) { if (output === undefined || output === null) { output = new Phaser.Point(this.x, this.y); } else { output.setTo(this.x, this.y); } return output; }, copyTo: function (dest) { dest.x = this.x; dest.y = this.y; return dest; }, distance: function (dest, round) { return Phaser.Point.distance(this, dest, round); }, equals: function (a) { return (a.x === this.x && a.y === this.y); }, angle: function (a, asDegrees) { if (asDegrees === undefined) { asDegrees = false; } if (asDegrees) { return Phaser.Math.radToDeg(Math.atan2(a.y - this.y, a.x - this.x)); } else { return Math.atan2(a.y - this.y, a.x - this.x); } }, rotate: function (x, y, angle, asDegrees, distance) { return Phaser.Point.rotate(this, x, y, angle, asDegrees, distance); }, getMagnitude: function () { return Math.sqrt((this.x * this.x) + (this.y * this.y)); }, getMagnitudeSq: function () { return (this.x * this.x) + (this.y * this.y); }, setMagnitude: function (magnitude) { return this.normalize().multiply(magnitude, magnitude); }, normalize: function () { if (!this.isZero()) { var m = this.getMagnitude(); this.x /= m; this.y /= m; } return this; }, isZero: function () { return (this.x === 0 && this.y === 0); }, dot: function (a) { return ((this.x * a.x) + (this.y * a.y)); }, cross: function (a) { return ((this.x * a.y) - (this.y * a.x)); }, perp: function () { return this.setTo(-this.y, this.x); }, rperp: function () { return this.setTo(this.y, -this.x); }, normalRightHand: function () { return this.setTo(this.y * -1, this.x); }, floor: function () { return this.setTo(Math.floor(this.x), Math.floor(this.y)); }, ceil: function () { return this.setTo(Math.ceil(this.x), Math.ceil(this.y)); }, toString: function () { return '[{Point (x=' + this.x + ' y=' + this.y + ')}]'; } }; Phaser.Point.prototype.constructor = Phaser.Point; Phaser.Point.add = function (a, b, out) { if (out === undefined) { out = new Phaser.Point(); } out.x = a.x + b.x; out.y = a.y + b.y; return out; }; Phaser.Point.subtract = function (a, b, out) { if (out === undefined) { out = new Phaser.Point(); } out.x = a.x - b.x; out.y = a.y - b.y; return out; }; Phaser.Point.multiply = function (a, b, out) { if (out === undefined) { out = new Phaser.Point(); } out.x = a.x * b.x; out.y = a.y * b.y; return out; }; Phaser.Point.divide = function (a, b, out) { if (out === undefined) { out = new Phaser.Point(); } out.x = a.x / b.x; out.y = a.y / b.y; return out; }; Phaser.Point.equals = function (a, b) { return (a.x === b.x && a.y === b.y); }; Phaser.Point.angle = function (a, b) { return Math.atan2(a.y - b.y, a.x - b.x); }; Phaser.Point.negative = function (a, out) { if (out === undefined) { out = new Phaser.Point(); } return out.setTo(-a.x, -a.y); }; Phaser.Point.multiplyAdd = function (a, b, s, out) { if (out === undefined) { out = new Phaser.Point(); } return out.setTo(a.x + b.x * s, a.y + b.y * s); }; Phaser.Point.interpolate = function (a, b, f, out) { if (out === undefined) { out = new Phaser.Point(); } return out.setTo(a.x + (b.x - a.x) * f, a.y + (b.y - a.y) * f); }; Phaser.Point.perp = function (a, out) { if (out === undefined) { out = new Phaser.Point(); } return out.setTo(-a.y, a.x); }; Phaser.Point.rperp = function (a, out) { if (out === undefined) { out = new Phaser.Point(); } return out.setTo(a.y, -a.x); }; Phaser.Point.distance = function (a, b, round) { var distance = Phaser.Math.distance(a.x, a.y, b.x, b.y); return round ? Math.round(distance) : distance; }; Phaser.Point.project = function (a, b, out) { if (out === undefined) { out = new Phaser.Point(); } var amt = a.dot(b) / b.getMagnitudeSq(); if (amt !== 0) { out.setTo(amt * b.x, amt * b.y); } return out; }; Phaser.Point.projectUnit = function (a, b, out) { if (out === undefined) { out = new Phaser.Point(); } var amt = a.dot(b); if (amt !== 0) { out.setTo(amt * b.x, amt * b.y); } return out; }; Phaser.Point.normalRightHand = function (a, out) { if (out === undefined) { out = new Phaser.Point(); } return out.setTo(a.y * -1, a.x); }; Phaser.Point.normalize = function (a, out) { if (out === undefined) { out = new Phaser.Point(); } var m = a.getMagnitude(); if (m !== 0) { out.setTo(a.x / m, a.y / m); } return out; }; Phaser.Point.rotate = function (a, x, y, angle, asDegrees, distance) { if (asDegrees) { angle = Phaser.Math.degToRad(angle); } if (distance === undefined) { a.subtract(x, y); var s = Math.sin(angle); var c = Math.cos(angle); var tx = c * a.x - s * a.y; var ty = s * a.x + c * a.y; a.x = tx + x; a.y = ty + y; } else { var t = angle + Math.atan2(a.y - y, a.x - x); a.x = x + distance * Math.cos(t); a.y = y + distance * Math.sin(t); } return a; }; Phaser.Point.centroid = function (points, out) { if (out === undefined) { out = new Phaser.Point(); } if (Object.prototype.toString.call(points) !== '[object Array]') { throw new Error("Phaser.Point. Parameter 'points' must be an array"); } var pointslength = points.length; if (pointslength < 1) { throw new Error("Phaser.Point. Parameter 'points' array must not be empty"); } if (pointslength === 1) { out.copyFrom(points[0]); return out; } for (var i = 0; i < pointslength; i++) { Phaser.Point.add(out, points[i], out); } out.divide(pointslength, pointslength); return out; }; Phaser.Point.parse = function(obj, xProp, yProp) { xProp = xProp || 'x'; yProp = yProp || 'y'; var point = new Phaser.Point(); if (obj[xProp]) { point.x = parseInt(obj[xProp], 10); } if (obj[yProp]) { point.y = parseInt(obj[yProp], 10); } return point; }; PIXI.Point = Phaser.Point; Phaser.Polygon = function () { this.area = 0; this._points = []; if (arguments.length > 0) { this.setTo.apply(this, arguments); } this.closed = true; this.flattened = false; this.type = Phaser.POLYGON; }; Phaser.Polygon.prototype = { toNumberArray: function (output) { if (output === undefined) { output = []; } for (var i = 0; i < this._points.length; i++) { if (typeof this._points[i] === 'number') { output.push(this._points[i]); output.push(this._points[i + 1]); i++; } else { output.push(this._points[i].x); output.push(this._points[i].y); } } return output; }, flatten: function () { this._points = this.toNumberArray(); this.flattened = true; return this; }, clone: function (output) { var points = this._points.slice(); if (output === undefined || output === null) { output = new Phaser.Polygon(points); } else { output.setTo(points); } return output; }, contains: function (x, y) { var inside = false; if (this.flattened) { for (var i = -2, j = this._points.length - 2; (i += 2) < this._points.length; j = i) { var ix = this._points[i]; var iy = this._points[i + 1]; var jx = this._points[j]; var jy = this._points[j + 1]; if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix)) { inside = !inside; } } } else { for (var i = -1, j = this._points.length - 1; ++i < this._points.length; j = i) { var ix = this._points[i].x; var iy = this._points[i].y; var jx = this._points[j].x; var jy = this._points[j].y; if (((iy <= y && y < jy) || (jy <= y && y < iy)) && (x < (jx - ix) * (y - iy) / (jy - iy) + ix)) { inside = !inside; } } } return inside; }, setTo: function (points) { this.area = 0; this._points = []; if (arguments.length > 0) { if (!Array.isArray(points)) { points = Array.prototype.slice.call(arguments); } var y0 = Number.MAX_VALUE; for (var i = 0, len = points.length; i < len; i++) { if (typeof points[i] === 'number') { var p = new PIXI.Point(points[i], points[i + 1]); i++; } else if (Array.isArray(points[i])) { var p = new PIXI.Point(points[i][0], points[i][1]); } else { var p = new PIXI.Point(points[i].x, points[i].y); } this._points.push(p); if (p.y < y0) { y0 = p.y; } } this.calculateArea(y0); } return this; }, calculateArea: function (y0) { var p1; var p2; var avgHeight; var width; for (var i = 0, len = this._points.length; i < len; i++) { p1 = this._points[i]; if (i === len - 1) { p2 = this._points[0]; } else { p2 = this._points[i + 1]; } avgHeight = ((p1.y - y0) + (p2.y - y0)) / 2; width = p1.x - p2.x; this.area += avgHeight * width; } return this.area; } }; Phaser.Polygon.prototype.constructor = Phaser.Polygon; Object.defineProperty(Phaser.Polygon.prototype, 'points', { get: function() { return this._points; }, set: function(points) { if (points != null) { this.setTo(points); } else { this.setTo(); } } }); PIXI.Polygon = Phaser.Polygon; Phaser.Rectangle = function (x, y, width, height) { x = x || 0; y = y || 0; width = width || 0; height = height || 0; this.x = x; this.y = y; this.width = width; this.height = height; this.type = Phaser.RECTANGLE; }; Phaser.Rectangle.prototype = { offset: function (dx, dy) { this.x += dx; this.y += dy; return this; }, offsetPoint: function (point) { return this.offset(point.x, point.y); }, setTo: function (x, y, width, height) { this.x = x; this.y = y; this.width = width; this.height = height; return this; }, scale: function (x, y) { if (y === undefined) { y = x; } this.width *= x; this.height *= y; return this; }, centerOn: function (x, y) { this.centerX = x; this.centerY = y; return this; }, floor: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); }, floorAll: function () { this.x = Math.floor(this.x); this.y = Math.floor(this.y); this.width = Math.floor(this.width); this.height = Math.floor(this.height); }, ceil: function () { this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); }, ceilAll: function () { this.x = Math.ceil(this.x); this.y = Math.ceil(this.y); this.width = Math.ceil(this.width); this.height = Math.ceil(this.height); }, copyFrom: function (source) { return this.setTo(source.x, source.y, source.width, source.height); }, copyTo: function (dest) { dest.x = this.x; dest.y = this.y; dest.width = this.width; dest.height = this.height; return dest; }, inflate: function (dx, dy) { return Phaser.Rectangle.inflate(this, dx, dy); }, size: function (output) { return Phaser.Rectangle.size(this, output); }, resize: function (width, height) { this.width = width; this.height = height; return this; }, clone: function (output) { return Phaser.Rectangle.clone(this, output); }, contains: function (x, y) { return Phaser.Rectangle.contains(this, x, y); }, containsRect: function (b) { return Phaser.Rectangle.containsRect(b, this); }, equals: function (b) { return Phaser.Rectangle.equals(this, b); }, intersection: function (b, out) { return Phaser.Rectangle.intersection(this, b, out); }, intersects: function (b) { return Phaser.Rectangle.intersects(this, b); }, intersectsRaw: function (left, right, top, bottom, tolerance) { return Phaser.Rectangle.intersectsRaw(this, left, right, top, bottom, tolerance); }, union: function (b, out) { return Phaser.Rectangle.union(this, b, out); }, random: function (out) { if (out === undefined) { out = new Phaser.Point(); } out.x = this.randomX; out.y = this.randomY; return out; }, getPoint: function (position, out) { if (out === undefined) { out = new Phaser.Point(); } switch (position) { default: case Phaser.TOP_LEFT: return out.set(this.x, this.y); case Phaser.TOP_CENTER: return out.set(this.centerX, this.y); case Phaser.TOP_RIGHT: return out.set(this.right, this.y); case Phaser.LEFT_CENTER: return out.set(this.x, this.centerY); case Phaser.CENTER: return out.set(this.centerX, this.centerY); case Phaser.RIGHT_CENTER: return out.set(this.right, this.centerY); case Phaser.BOTTOM_LEFT: return out.set(this.x, this.bottom); case Phaser.BOTTOM_CENTER: return out.set(this.centerX, this.bottom); case Phaser.BOTTOM_RIGHT: return out.set(this.right, this.bottom); } }, toString: function () { return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"; } }; Object.defineProperty(Phaser.Rectangle.prototype, "halfWidth", { get: function () { return Math.round(this.width / 2); } }); Object.defineProperty(Phaser.Rectangle.prototype, "halfHeight", { get: function () { return Math.round(this.height / 2); } }); Object.defineProperty(Phaser.Rectangle.prototype, "bottom", { get: function () { return this.y + this.height; }, set: function (value) { if (value <= this.y) { this.height = 0; } else { this.height = value - this.y; } } }); Object.defineProperty(Phaser.Rectangle.prototype, "bottomLeft", { get: function () { return new Phaser.Point(this.x, this.bottom); }, set: function (value) { this.x = value.x; this.bottom = value.y; } }); Object.defineProperty(Phaser.Rectangle.prototype, "bottomRight", { get: function () { return new Phaser.Point(this.right, this.bottom); }, set: function (value) { this.right = value.x; this.bottom = value.y; } }); Object.defineProperty(Phaser.Rectangle.prototype, "left", { get: function () { return this.x; }, set: function (value) { if (value >= this.right) { this.width = 0; } else { this.width = this.right - value; } this.x = value; } }); Object.defineProperty(Phaser.Rectangle.prototype, "right", { get: function () { return this.x + this.width; }, set: function (value) { if (value <= this.x) { this.width = 0; } else { this.width = value - this.x; } } }); Object.defineProperty(Phaser.Rectangle.prototype, "volume", { get: function () { return this.width * this.height; } }); Object.defineProperty(Phaser.Rectangle.prototype, "perimeter", { get: function () { return (this.width * 2) + (this.height * 2); } }); Object.defineProperty(Phaser.Rectangle.prototype, "centerX", { get: function () { return this.x + this.halfWidth; }, set: function (value) { this.x = value - this.halfWidth; } }); Object.defineProperty(Phaser.Rectangle.prototype, "centerY", { get: function () { return this.y + this.halfHeight; }, set: function (value) { this.y = value - this.halfHeight; } }); Object.defineProperty(Phaser.Rectangle.prototype, "randomX", { get: function () { return this.x + (Math.random() * this.width); } }); Object.defineProperty(Phaser.Rectangle.prototype, "randomY", { get: function () { return this.y + (Math.random() * this.height); } }); Object.defineProperty(Phaser.Rectangle.prototype, "top", { get: function () { return this.y; }, set: function (value) { if (value >= this.bottom) { this.height = 0; this.y = value; } else { this.height = (this.bottom - value); } } }); Object.defineProperty(Phaser.Rectangle.prototype, "topLeft", { get: function () { return new Phaser.Point(this.x, this.y); }, set: function (value) { this.x = value.x; this.y = value.y; } }); Object.defineProperty(Phaser.Rectangle.prototype, "topRight", { get: function () { return new Phaser.Point(this.x + this.width, this.y); }, set: function (value) { this.right = value.x; this.y = value.y; } }); Object.defineProperty(Phaser.Rectangle.prototype, "empty", { get: function () { return (!this.width || !this.height); }, set: function (value) { if (value === true) { this.setTo(0, 0, 0, 0); } } }); Phaser.Rectangle.prototype.constructor = Phaser.Rectangle; Phaser.Rectangle.inflate = function (a, dx, dy) { a.x -= dx; a.width += 2 * dx; a.y -= dy; a.height += 2 * dy; return a; }; Phaser.Rectangle.inflatePoint = function (a, point) { return Phaser.Rectangle.inflate(a, point.x, point.y); }; Phaser.Rectangle.size = function (a, output) { if (output === undefined || output === null) { output = new Phaser.Point(a.width, a.height); } else { output.setTo(a.width, a.height); } return output; }; Phaser.Rectangle.clone = function (a, output) { if (output === undefined || output === null) { output = new Phaser.Rectangle(a.x, a.y, a.width, a.height); } else { output.setTo(a.x, a.y, a.width, a.height); } return output; }; Phaser.Rectangle.contains = function (a, x, y) { if (a.width <= 0 || a.height <= 0) { return false; } return (x >= a.x && x < a.right && y >= a.y && y < a.bottom); }; Phaser.Rectangle.containsRaw = function (rx, ry, rw, rh, x, y) { return (x >= rx && x < (rx + rw) && y >= ry && y < (ry + rh)); }; Phaser.Rectangle.containsPoint = function (a, point) { return Phaser.Rectangle.contains(a, point.x, point.y); }; Phaser.Rectangle.containsRect = function (a, b) { if (a.volume > b.volume) { return false; } return (a.x >= b.x && a.y >= b.y && a.right < b.right && a.bottom < b.bottom); }; Phaser.Rectangle.equals = function (a, b) { return (a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height); }; Phaser.Rectangle.sameDimensions = function (a, b) { return (a.width === b.width && a.height === b.height); }; Phaser.Rectangle.intersection = function (a, b, output) { if (output === undefined) { output = new Phaser.Rectangle(); } if (Phaser.Rectangle.intersects(a, b)) { output.x = Math.max(a.x, b.x); output.y = Math.max(a.y, b.y); output.width = Math.min(a.right, b.right) - output.x; output.height = Math.min(a.bottom, b.bottom) - output.y; } return output; }; Phaser.Rectangle.intersects = function (a, b) { if (a.width <= 0 || a.height <= 0 || b.width <= 0 || b.height <= 0) { return false; } return !(a.right < b.x || a.bottom < b.y || a.x > b.right || a.y > b.bottom); }; Phaser.Rectangle.intersectsRaw = function (a, left, right, top, bottom, tolerance) { if (tolerance === undefined) { tolerance = 0; } return !(left > a.right + tolerance || right < a.left - tolerance || top > a.bottom + tolerance || bottom < a.top - tolerance); }; Phaser.Rectangle.union = function (a, b, output) { if (output === undefined) { output = new Phaser.Rectangle(); } return output.setTo(Math.min(a.x, b.x), Math.min(a.y, b.y), Math.max(a.right, b.right) - Math.min(a.left, b.left), Math.max(a.bottom, b.bottom) - Math.min(a.top, b.top)); }; Phaser.Rectangle.aabb = function(points, out) { if (out === undefined) { out = new Phaser.Rectangle(); } var xMax = Number.NEGATIVE_INFINITY, xMin = Number.POSITIVE_INFINITY, yMax = Number.NEGATIVE_INFINITY, yMin = Number.POSITIVE_INFINITY; points.forEach(function(point) { if (point.x > xMax) { xMax = point.x; } if (point.x < xMin) { xMin = point.x; } if (point.y > yMax) { yMax = point.y; } if (point.y < yMin) { yMin = point.y; } }); out.setTo(xMin, yMin, xMax - xMin, yMax - yMin); return out; }; PIXI.Rectangle = Phaser.Rectangle; PIXI.EmptyRectangle = new Phaser.Rectangle(0, 0, 0, 0); Phaser.RoundedRectangle = function(x, y, width, height, radius) { if (x === undefined) { x = 0; } if (y === undefined) { y = 0; } if (width === undefined) { width = 0; } if (height === undefined) { height = 0; } if (radius === undefined) { radius = 20; } this.x = x; this.y = y; this.width = width; this.height = height; this.radius = radius || 20; this.type = Phaser.ROUNDEDRECTANGLE; }; Phaser.RoundedRectangle.prototype = { clone: function () { return new Phaser.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius); }, contains: function (x, y) { if (this.width <= 0 || this.height <= 0) { return false; } var x1 = this.x; if (x >= x1 && x <= x1 + this.width) { var y1 = this.y; if (y >= y1 && y <= y1 + this.height) { return true; } } return false; } }; Phaser.RoundedRectangle.prototype.constructor = Phaser.RoundedRectangle; PIXI.RoundedRectangle = Phaser.RoundedRectangle; Phaser.Camera = function (game, id, x, y, width, height) { this.game = game; this.world = game.world; this.id = 0; this.view = new Phaser.Rectangle(x, y, width, height); this.bounds = new Phaser.Rectangle(x, y, width, height); this.deadzone = null; this.visible = true; this.roundPx = true; this.atLimit = { x: false, y: false }; this.target = null; this.displayObject = null; this.scale = null; this.totalInView = 0; this.lerp = new Phaser.Point(1, 1); this.onShakeComplete = new Phaser.Signal(); this.onFlashComplete = new Phaser.Signal(); this.onFadeComplete = new Phaser.Signal(); this.fx = null; this._targetPosition = new Phaser.Point(); this._edge = 0; this._position = new Phaser.Point(); this._shake = { intensity: 0, duration: 0, horizontal: false, vertical: false, shakeBounds: true, x: 0, y: 0 }; this._fxDuration = 0; this._fxType = 0; }; Phaser.Camera.FOLLOW_LOCKON = 0; Phaser.Camera.FOLLOW_PLATFORMER = 1; Phaser.Camera.FOLLOW_TOPDOWN = 2; Phaser.Camera.FOLLOW_TOPDOWN_TIGHT = 3; Phaser.Camera.SHAKE_BOTH = 4; Phaser.Camera.SHAKE_HORIZONTAL = 5; Phaser.Camera.SHAKE_VERTICAL = 6; Phaser.Camera.ENABLE_FX = true; Phaser.Camera.prototype = { boot: function () { this.displayObject = this.game.world; this.scale = this.game.world.scale; this.game.camera = this; if (Phaser.Graphics && Phaser.Camera.ENABLE_FX) { this.fx = new Phaser.Graphics(this.game); this.game.stage.addChild(this.fx); } }, preUpdate: function () { this.totalInView = 0; }, follow: function (target, style, lerpX, lerpY) { if (style === undefined) { style = Phaser.Camera.FOLLOW_LOCKON; } if (lerpX === undefined) { lerpX = 1; } if (lerpY === undefined) { lerpY = 1; } this.target = target; this.lerp.set(lerpX, lerpY); var helper; switch (style) { case Phaser.Camera.FOLLOW_PLATFORMER: var w = this.width / 8; var h = this.height / 3; this.deadzone = new Phaser.Rectangle((this.width - w) / 2, (this.height - h) / 2 - h * 0.25, w, h); break; case Phaser.Camera.FOLLOW_TOPDOWN: helper = Math.max(this.width, this.height) / 4; this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper); break; case Phaser.Camera.FOLLOW_TOPDOWN_TIGHT: helper = Math.max(this.width, this.height) / 8; this.deadzone = new Phaser.Rectangle((this.width - helper) / 2, (this.height - helper) / 2, helper, helper); break; case Phaser.Camera.FOLLOW_LOCKON: this.deadzone = null; break; default: this.deadzone = null; break; } }, unfollow: function () { this.target = null; }, focusOn: function (displayObject) { this.setPosition(Math.round(displayObject.x - this.view.halfWidth), Math.round(displayObject.y - this.view.halfHeight)); }, focusOnXY: function (x, y) { this.setPosition(Math.round(x - this.view.halfWidth), Math.round(y - this.view.halfHeight)); }, shake: function (intensity, duration, force, direction, shakeBounds) { if (intensity === undefined) { intensity = 0.05; } if (duration === undefined) { duration = 500; } if (force === undefined) { force = true; } if (direction === undefined) { direction = Phaser.Camera.SHAKE_BOTH; } if (shakeBounds === undefined) { shakeBounds = true; } if (!force && this._shake.duration > 0) { return false; } this._shake.intensity = intensity; this._shake.duration = duration; this._shake.shakeBounds = shakeBounds; this._shake.x = 0; this._shake.y = 0; this._shake.horizontal = (direction === Phaser.Camera.SHAKE_BOTH || direction === Phaser.Camera.SHAKE_HORIZONTAL); this._shake.vertical = (direction === Phaser.Camera.SHAKE_BOTH || direction === Phaser.Camera.SHAKE_VERTICAL); return true; }, flash: function (color, duration, force) { if (color === undefined) { color = 0xffffff; } if (duration === undefined) { duration = 500; } if (force === undefined) { force = false; } if (!this.fx || (!force && this._fxDuration > 0)) { return false; } this.fx.clear(); this.fx.beginFill(color); this.fx.drawRect(0, 0, this.width, this.height); this.fx.endFill(); this.fx.alpha = 1; this._fxDuration = duration; this._fxType = 0; return true; }, fade: function (color, duration, force) { if (color === undefined) { color = 0x000000; } if (duration === undefined) { duration = 500; } if (force === undefined) { force = false; } if (!this.fx || (!force && this._fxDuration > 0)) { return false; } this.fx.clear(); this.fx.beginFill(color); this.fx.drawRect(0, 0, this.width, this.height); this.fx.endFill(); this.fx.alpha = 0; this._fxDuration = duration; this._fxType = 1; return true; }, update: function () { if (this._fxDuration > 0) { this.updateFX(); } if (this._shake.duration > 0) { this.updateShake(); } if (this.bounds) { this.checkBounds(); } if (this.roundPx) { this.view.floor(); this._shake.x = Math.floor(this._shake.x); this._shake.y = Math.floor(this._shake.y); } this.displayObject.position.x = -this.view.x; this.displayObject.position.y = -this.view.y; }, updateFX: function () { if (this._fxType === 0) { this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration; if (this.fx.alpha <= 0) { this._fxDuration = 0; this.fx.alpha = 0; this.onFlashComplete.dispatch(); } } else { this.fx.alpha += this.game.time.elapsedMS / this._fxDuration; if (this.fx.alpha >= 1) { this._fxDuration = 0; this.fx.alpha = 1; this.onFadeComplete.dispatch(); } } }, updateShake: function () { this._shake.duration -= this.game.time.elapsedMS; if (this._shake.duration <= 0) { this.onShakeComplete.dispatch(); this._shake.x = 0; this._shake.y = 0; } else { if (this._shake.horizontal) { this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width; } if (this._shake.vertical) { this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height; } } }, updateTarget: function () { this._targetPosition.x = this.view.x + this.target.worldPosition.x; this._targetPosition.y = this.view.y + this.target.worldPosition.y; if (this.deadzone) { this._edge = this._targetPosition.x - this.view.x; if (this._edge < this.deadzone.left) { this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x); } else if (this._edge > this.deadzone.right) { this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x); } this._edge = this._targetPosition.y - this.view.y; if (this._edge < this.deadzone.top) { this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y); } else if (this._edge > this.deadzone.bottom) { this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y); } } else { this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x); this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y); } if (this.bounds) { this.checkBounds(); } if (this.roundPx) { this.view.floor(); } this.displayObject.position.x = -this.view.x; this.displayObject.position.y = -this.view.y; }, setBoundsToWorld: function () { if (this.bounds) { this.bounds.copyFrom(this.game.world.bounds); } }, checkBounds: function () { this.atLimit.x = false; this.atLimit.y = false; var vx = this.view.x + this._shake.x; var vw = this.view.right + this._shake.x; var vy = this.view.y + this._shake.y; var vh = this.view.bottom + this._shake.y; if (vx <= this.bounds.x * this.scale.x) { this.atLimit.x = true; this.view.x = this.bounds.x * this.scale.x; if (!this._shake.shakeBounds) { this._shake.x = 0; } } if (vw >= this.bounds.right * this.scale.x) { this.atLimit.x = true; this.view.x = (this.bounds.right * this.scale.x) - this.width; if (!this._shake.shakeBounds) { this._shake.x = 0; } } if (vy <= this.bounds.top * this.scale.y) { this.atLimit.y = true; this.view.y = this.bounds.top * this.scale.y; if (!this._shake.shakeBounds) { this._shake.y = 0; } } if (vh >= this.bounds.bottom * this.scale.y) { this.atLimit.y = true; this.view.y = (this.bounds.bottom * this.scale.y) - this.height; if (!this._shake.shakeBounds) { this._shake.y = 0; } } }, setPosition: function (x, y) { this.view.x = x; this.view.y = y; if (this.bounds) { this.checkBounds(); } }, setSize: function (width, height) { this.view.width = width; this.view.height = height; }, reset: function () { this.target = null; this.view.x = 0; this.view.y = 0; this._shake.duration = 0; this.resetFX(); }, resetFX: function () { this.fx.clear(); this.fx.alpha = 0; this._fxDuration = 0; } }; Phaser.Camera.prototype.constructor = Phaser.Camera; Object.defineProperty(Phaser.Camera.prototype, "x", { get: function () { return this.view.x; }, set: function (value) { this.view.x = value; if (this.bounds) { this.checkBounds(); } } }); Object.defineProperty(Phaser.Camera.prototype, "y", { get: function () { return this.view.y; }, set: function (value) { this.view.y = value; if (this.bounds) { this.checkBounds(); } } }); Object.defineProperty(Phaser.Camera.prototype, "position", { get: function () { this._position.set(this.view.x, this.view.y); return this._position; }, set: function (value) { if (typeof value.x !== "undefined") { this.view.x = value.x; } if (typeof value.y !== "undefined") { this.view.y = value.y; } if (this.bounds) { this.checkBounds(); } } }); Object.defineProperty(Phaser.Camera.prototype, "width", { get: function () { return this.view.width; }, set: function (value) { this.view.width = value; } }); Object.defineProperty(Phaser.Camera.prototype, "height", { get: function () { return this.view.height; }, set: function (value) { this.view.height = value; } }); Object.defineProperty(Phaser.Camera.prototype, "shakeIntensity", { get: function () { return this._shake.intensity; }, set: function (value) { this._shake.intensity = value; } }); Phaser.State = function () { this.game = null; this.key = ''; this.add = null; this.make = null; this.camera = null; this.cache = null; this.input = null; this.load = null; this.math = null; this.sound = null; this.scale = null; this.stage = null; this.state = null; this.time = null; this.tweens = null; this.world = null; this.particles = null; this.physics = null; this.rnd = null; }; Phaser.State.prototype = { init: function () { }, preload: function () { }, loadUpdate: function () { }, loadRender: function () { }, create: function () { }, update: function () { }, preRender: function () { }, render: function () { }, resize: function () { }, paused: function () { }, resumed: function () { }, pauseUpdate: function () { }, shutdown: function () { } }; Phaser.State.prototype.constructor = Phaser.State; Phaser.StateManager = function (game, pendingState) { this.game = game; this.states = {}; this._pendingState = null; if (typeof pendingState !== 'undefined' && pendingState !== null) { this._pendingState = pendingState; } this._clearWorld = false; this._clearCache = false; this._created = false; this._args = []; this.current = ''; this.onStateChange = new Phaser.Signal(); this.onInitCallback = null; this.onPreloadCallback = null; this.onCreateCallback = null; this.onUpdateCallback = null; this.onRenderCallback = null; this.onResizeCallback = null; this.onPreRenderCallback = null; this.onLoadUpdateCallback = null; this.onLoadRenderCallback = null; this.onPausedCallback = null; this.onResumedCallback = null; this.onPauseUpdateCallback = null; this.onShutDownCallback = null; }; Phaser.StateManager.prototype = { boot: function () { this.game.onPause.add(this.pause, this); this.game.onResume.add(this.resume, this); if (this._pendingState !== null && typeof this._pendingState !== 'string') { this.add('default', this._pendingState, true); } }, add: function (key, state, autoStart) { if (autoStart === undefined) { autoStart = false; } var newState; if (state instanceof Phaser.State) { newState = state; } else if (typeof state === 'object') { newState = state; newState.game = this.game; } else if (typeof state === 'function') { newState = new state(this.game); } this.states[key] = newState; if (autoStart) { if (this.game.isBooted) { this.start(key); } else { this._pendingState = key; } } return newState; }, remove: function (key) { if (this.current === key) { this.callbackContext = null; this.onInitCallback = null; this.onShutDownCallback = null; this.onPreloadCallback = null; this.onLoadRenderCallback = null; this.onLoadUpdateCallback = null; this.onCreateCallback = null; this.onUpdateCallback = null; this.onPreRenderCallback = null; this.onRenderCallback = null; this.onResizeCallback = null; this.onPausedCallback = null; this.onResumedCallback = null; this.onPauseUpdateCallback = null; } delete this.states[key]; }, start: function (key, clearWorld, clearCache) { if (clearWorld === undefined) { clearWorld = true; } if (clearCache === undefined) { clearCache = false; } if (this.checkState(key)) { this._pendingState = key; this._clearWorld = clearWorld; this._clearCache = clearCache; if (arguments.length > 3) { this._args = Array.prototype.splice.call(arguments, 3); } } }, restart: function (clearWorld, clearCache) { if (clearWorld === undefined) { clearWorld = true; } if (clearCache === undefined) { clearCache = false; } this._pendingState = this.current; this._clearWorld = clearWorld; this._clearCache = clearCache; if (arguments.length > 2) { this._args = Array.prototype.slice.call(arguments, 2); } }, dummy: function () { }, preUpdate: function () { if (this._pendingState && this.game.isBooted) { var previousStateKey = this.current; this.clearCurrentState(); this.setCurrentState(this._pendingState); this.onStateChange.dispatch(this.current, previousStateKey); if (this.current !== this._pendingState) { return; } else { this._pendingState = null; } if (this.onPreloadCallback) { this.game.load.reset(true); this.onPreloadCallback.call(this.callbackContext, this.game); if (this.game.load.totalQueuedFiles() === 0 && this.game.load.totalQueuedPacks() === 0) { this.loadComplete(); } else { this.game.load.start(); } } else { this.loadComplete(); } } }, clearCurrentState: function () { if (this.current) { if (this.onShutDownCallback) { this.onShutDownCallback.call(this.callbackContext, this.game); } this.game.tweens.removeAll(); this.game.camera.reset(); this.game.input.reset(true); this.game.physics.clear(); this.game.time.removeAll(); this.game.scale.reset(this._clearWorld); if (this.game.debug) { this.game.debug.reset(); } if (this._clearWorld) { this.game.world.shutdown(); if (this._clearCache) { this.game.cache.destroy(); } } } }, checkState: function (key) { if (this.states[key]) { if (this.states[key]['preload'] || this.states[key]['create'] || this.states[key]['update'] || this.states[key]['render']) { return true; } else { console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions: preload, create, update or render"); return false; } } else { console.warn("Phaser.StateManager - No state found with the key: " + key); return false; } }, link: function (key) { this.states[key].game = this.game; this.states[key].add = this.game.add; this.states[key].make = this.game.make; this.states[key].camera = this.game.camera; this.states[key].cache = this.game.cache; this.states[key].input = this.game.input; this.states[key].load = this.game.load; this.states[key].math = this.game.math; this.states[key].sound = this.game.sound; this.states[key].scale = this.game.scale; this.states[key].state = this; this.states[key].stage = this.game.stage; this.states[key].time = this.game.time; this.states[key].tweens = this.game.tweens; this.states[key].world = this.game.world; this.states[key].particles = this.game.particles; this.states[key].rnd = this.game.rnd; this.states[key].physics = this.game.physics; this.states[key].key = key; }, unlink: function (key) { if (this.states[key]) { this.states[key].game = null; this.states[key].add = null; this.states[key].make = null; this.states[key].camera = null; this.states[key].cache = null; this.states[key].input = null; this.states[key].load = null; this.states[key].math = null; this.states[key].sound = null; this.states[key].scale = null; this.states[key].state = null; this.states[key].stage = null; this.states[key].time = null; this.states[key].tweens = null; this.states[key].world = null; this.states[key].particles = null; this.states[key].rnd = null; this.states[key].physics = null; } }, setCurrentState: function (key) { this.callbackContext = this.states[key]; this.link(key); this.onInitCallback = this.states[key]['init'] || this.dummy; this.onPreloadCallback = this.states[key]['preload'] || null; this.onLoadRenderCallback = this.states[key]['loadRender'] || null; this.onLoadUpdateCallback = this.states[key]['loadUpdate'] || null; this.onCreateCallback = this.states[key]['create'] || null; this.onUpdateCallback = this.states[key]['update'] || null; this.onPreRenderCallback = this.states[key]['preRender'] || null; this.onRenderCallback = this.states[key]['render'] || null; this.onResizeCallback = this.states[key]['resize'] || null; this.onPausedCallback = this.states[key]['paused'] || null; this.onResumedCallback = this.states[key]['resumed'] || null; this.onPauseUpdateCallback = this.states[key]['pauseUpdate'] || null; this.onShutDownCallback = this.states[key]['shutdown'] || this.dummy; if (this.current !== '') { this.game.physics.reset(); } this.current = key; this._created = false; this.onInitCallback.apply(this.callbackContext, this._args); if (key === this._pendingState) { this._args = []; } this.game._kickstart = true; }, getCurrentState: function() { return this.states[this.current]; }, loadComplete: function () { if (this._created === false && this.onLoadUpdateCallback) { this.onLoadUpdateCallback.call(this.callbackContext, this.game); } if (this._created === false && this.onCreateCallback) { this._created = true; this.onCreateCallback.call(this.callbackContext, this.game); } else { this._created = true; } }, pause: function () { if (this._created && this.onPausedCallback) { this.onPausedCallback.call(this.callbackContext, this.game); } }, resume: function () { if (this._created && this.onResumedCallback) { this.onResumedCallback.call(this.callbackContext, this.game); } }, update: function () { if (this._created) { if (this.onUpdateCallback) { this.onUpdateCallback.call(this.callbackContext, this.game); } } else { if (this.onLoadUpdateCallback) { this.onLoadUpdateCallback.call(this.callbackContext, this.game); } } }, pauseUpdate: function () { if (this._created) { if (this.onPauseUpdateCallback) { this.onPauseUpdateCallback.call(this.callbackContext, this.game); } } else { if (this.onLoadUpdateCallback) { this.onLoadUpdateCallback.call(this.callbackContext, this.game); } } }, preRender: function (elapsedTime) { if (this._created && this.onPreRenderCallback) { this.onPreRenderCallback.call(this.callbackContext, this.game, elapsedTime); } }, resize: function (width, height) { if (this.onResizeCallback) { this.onResizeCallback.call(this.callbackContext, width, height); } }, render: function () { if (this._created) { if (this.onRenderCallback) { if (this.game.renderType === Phaser.CANVAS) { this.game.context.save(); this.game.context.setTransform(1, 0, 0, 1, 0, 0); this.onRenderCallback.call(this.callbackContext, this.game); this.game.context.restore(); } else { this.onRenderCallback.call(this.callbackContext, this.game); } } } else { if (this.onLoadRenderCallback) { this.onLoadRenderCallback.call(this.callbackContext, this.game); } } }, destroy: function () { this._clearWorld = true; this._clearCache = true; this.clearCurrentState(); this.callbackContext = null; this.onInitCallback = null; this.onShutDownCallback = null; this.onPreloadCallback = null; this.onLoadRenderCallback = null; this.onLoadUpdateCallback = null; this.onCreateCallback = null; this.onUpdateCallback = null; this.onRenderCallback = null; this.onPausedCallback = null; this.onResumedCallback = null; this.onPauseUpdateCallback = null; this.game = null; this.states = {}; this._pendingState = null; this.current = ''; } }; Phaser.StateManager.prototype.constructor = Phaser.StateManager; Object.defineProperty(Phaser.StateManager.prototype, "created", { get: function () { return this._created; } }); Phaser.Signal = function () {}; Phaser.Signal.prototype = { _bindings: null, _prevParams: null, memorize: false, _shouldPropagate: true, active: true, _boundDispatch: false, validateListener: function (listener, fnName) { if (typeof listener !== 'function') { throw new Error('Phaser.Signal: listener is a required param of {fn}() and should be a Function.'.replace('{fn}', fnName)); } }, _registerListener: function (listener, isOnce, listenerContext, priority, args) { var prevIndex = this._indexOfListener(listener, listenerContext); var binding; if (prevIndex !== -1) { binding = this._bindings[prevIndex]; if (binding.isOnce() !== isOnce) { throw new Error('You cannot add' + (isOnce ? '' : 'Once') + '() then add' + (!isOnce ? '' : 'Once') + '() the same listener without removing the relationship first.'); } } else { binding = new Phaser.SignalBinding(this, listener, isOnce, listenerContext, priority, args); this._addBinding(binding); } if (this.memorize && this._prevParams) { binding.execute(this._prevParams); } return binding; }, _addBinding: function (binding) { if (!this._bindings) { this._bindings = []; } var n = this._bindings.length; do { n--; } while (this._bindings[n] && binding._priority <= this._bindings[n]._priority); this._bindings.splice(n + 1, 0, binding); }, _indexOfListener: function (listener, context) { if (!this._bindings) { return -1; } if (context === undefined) { context = null; } var n = this._bindings.length; var cur; while (n--) { cur = this._bindings[n]; if (cur._listener === listener && cur.context === context) { return n; } } return -1; }, has: function (listener, context) { return this._indexOfListener(listener, context) !== -1; }, add: function (listener, listenerContext, priority) { this.validateListener(listener, 'add'); var args = []; if (arguments.length > 3) { for (var i = 3; i < arguments.length; i++) { args.push(arguments[i]); } } return this._registerListener(listener, false, listenerContext, priority, args); }, addOnce: function (listener, listenerContext, priority) { this.validateListener(listener, 'addOnce'); var args = []; if (arguments.length > 3) { for (var i = 3; i < arguments.length; i++) { args.push(arguments[i]); } } return this._registerListener(listener, true, listenerContext, priority, args); }, remove: function (listener, context) { this.validateListener(listener, 'remove'); var i = this._indexOfListener(listener, context); if (i !== -1) { this._bindings[i]._destroy(); this._bindings.splice(i, 1); } return listener; }, removeAll: function (context) { if (context === undefined) { context = null; } if (!this._bindings) { return; } var n = this._bindings.length; while (n--) { if (context) { if (this._bindings[n].context === context) { this._bindings[n]._destroy(); this._bindings.splice(n, 1); } } else { this._bindings[n]._destroy(); } } if (!context) { this._bindings.length = 0; } }, getNumListeners: function () { return this._bindings ? this._bindings.length : 0; }, halt: function () { this._shouldPropagate = false; }, dispatch: function () { if (!this.active || !this._bindings) { return; } var paramsArr = Array.prototype.slice.call(arguments); var n = this._bindings.length; var bindings; if (this.memorize) { this._prevParams = paramsArr; } if (!n) { return; } bindings = this._bindings.slice(); this._shouldPropagate = true; do { n--; } while (bindings[n] && this._shouldPropagate && bindings[n].execute(paramsArr) !== false); }, forget: function() { if (this._prevParams) { this._prevParams = null; } }, dispose: function () { this.removeAll(); this._bindings = null; if (this._prevParams) { this._prevParams = null; } }, toString: function () { return '[Phaser.Signal active:'+ this.active +' numListeners:'+ this.getNumListeners() +']'; } }; Object.defineProperty(Phaser.Signal.prototype, "boundDispatch", { get: function () { var _this = this; return this._boundDispatch || (this._boundDispatch = function () { return _this.dispatch.apply(_this, arguments); }); } }); Phaser.Signal.prototype.constructor = Phaser.Signal; Phaser.SignalBinding = function (signal, listener, isOnce, listenerContext, priority, args) { this._listener = listener; if (isOnce) { this._isOnce = true; } if (listenerContext != null) { this.context = listenerContext; } this._signal = signal; if (priority) { this._priority = priority; } if (args && args.length) { this._args = args; } }; Phaser.SignalBinding.prototype = { context: null, _isOnce: false, _priority: 0, _args: null, callCount: 0, active: true, params: null, execute: function(paramsArr) { var handlerReturn, params; if (this.active && !!this._listener) { params = this.params ? this.params.concat(paramsArr) : paramsArr; if (this._args) { params = params.concat(this._args); } handlerReturn = this._listener.apply(this.context, params); this.callCount++; if (this._isOnce) { this.detach(); } } return handlerReturn; }, detach: function () { return this.isBound() ? this._signal.remove(this._listener, this.context) : null; }, isBound: function () { return (!!this._signal && !!this._listener); }, isOnce: function () { return this._isOnce; }, getListener: function () { return this._listener; }, getSignal: function () { return this._signal; }, _destroy: function () { delete this._signal; delete this._listener; delete this.context; }, toString: function () { return '[Phaser.SignalBinding isOnce:' + this._isOnce +', isBound:'+ this.isBound() +', active:' + this.active + ']'; } }; Phaser.SignalBinding.prototype.constructor = Phaser.SignalBinding; Phaser.Filter = function (game, uniforms, fragmentSrc) { this.game = game; this.type = Phaser.WEBGL_FILTER; this.passes = [this]; this.shaders = []; this.dirty = true; this.padding = 0; this.prevPoint = new Phaser.Point(); var d = new Date(); this.uniforms = { resolution: { type: '2f', value: { x: 256, y: 256 }}, time: { type: '1f', value: 0 }, mouse: { type: '2f', value: { x: 0.0, y: 0.0 } }, date: { type: '4fv', value: [ d.getFullYear(),  d.getMonth(),  d.getDate(), d.getHours() *60 * 60 + d.getMinutes() * 60 + d.getSeconds() ] }, sampleRate: { type: '1f', value: 44100.0 }, iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: true } }, iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: true } }, iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: true } }, iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: true } } }; if (uniforms) { for (var key in uniforms) { this.uniforms[key] = uniforms[key]; } } this.fragmentSrc = fragmentSrc || ''; }; Phaser.Filter.prototype = { init: function () { }, setResolution: function (width, height) { this.uniforms.resolution.value.x = width; this.uniforms.resolution.value.y = height; }, update: function (pointer) { if (typeof pointer !== 'undefined') { var x = pointer.x / this.game.width; var y = 1 - pointer.y / this.game.height; if (x !== this.prevPoint.x || y !== this.prevPoint.y) { this.uniforms.mouse.value.x = x.toFixed(2); this.uniforms.mouse.value.y = y.toFixed(2); this.prevPoint.set(x, y); } } this.uniforms.time.value = this.game.time.totalElapsedSeconds(); }, addToWorld: function (x, y, width, height, anchorX, anchorY) { if (anchorX === undefined) { anchorX = 0; } if (anchorY === undefined) { anchorY = 0; } if (width !== undefined && width !== null) { this.width = width; } else { width = this.width; } if (height !== undefined && height !== null) { this.height = height; } else { height = this.height; } var image = this.game.add.image(x, y, '__default'); image.width = width; image.height = height; image.anchor.set(anchorX, anchorY); image.filters = [ this ]; return image; }, destroy: function () { this.game = null; } }; Phaser.Filter.prototype.constructor = Phaser.Filter; Object.defineProperty(Phaser.Filter.prototype, 'width', { get: function() { return this.uniforms.resolution.value.x; }, set: function(value) { this.uniforms.resolution.value.x = value; } }); Object.defineProperty(Phaser.Filter.prototype, 'height', { get: function() { return this.uniforms.resolution.value.y; }, set: function(value) { this.uniforms.resolution.value.y = value; } }); Phaser.Plugin = function (game, parent) { if (parent === undefined) { parent = null; } this.game = game; this.parent = parent; this.active = false; this.visible = false; this.hasPreUpdate = false; this.hasUpdate = false; this.hasPostUpdate = false; this.hasRender = false; this.hasPostRender = false; }; Phaser.Plugin.prototype = { preUpdate: function () { }, update: function () { }, render: function () { }, postRender: function () { }, destroy: function () { this.game = null; this.parent = null; this.active = false; this.visible = false; } }; Phaser.Plugin.prototype.constructor = Phaser.Plugin; Phaser.PluginManager = function(game) { this.game = game; this.plugins = []; this._len = 0; this._i = 0; }; Phaser.PluginManager.prototype = { add: function (plugin) { var args = Array.prototype.slice.call(arguments, 1); var result = false; if (typeof plugin === 'function') { plugin = new plugin(this.game, this); } else { plugin.game = this.game; plugin.parent = this; } if (typeof plugin['preUpdate'] === 'function') { plugin.hasPreUpdate = true; result = true; } if (typeof plugin['update'] === 'function') { plugin.hasUpdate = true; result = true; } if (typeof plugin['postUpdate'] === 'function') { plugin.hasPostUpdate = true; result = true; } if (typeof plugin['render'] === 'function') { plugin.hasRender = true; result = true; } if (typeof plugin['postRender'] === 'function') { plugin.hasPostRender = true; result = true; } if (result) { if (plugin.hasPreUpdate || plugin.hasUpdate || plugin.hasPostUpdate) { plugin.active = true; } if (plugin.hasRender || plugin.hasPostRender) { plugin.visible = true; } this._len = this.plugins.push(plugin); if (typeof plugin['init'] === 'function') { plugin.init.apply(plugin, args); } return plugin; } else { return null; } }, remove: function (plugin, destroy) { if (destroy === undefined) { destroy = true; } this._i = this._len; while (this._i--) { if (this.plugins[this._i] === plugin) { if (destroy) { plugin.destroy(); } this.plugins.splice(this._i, 1); this._len--; return; } } }, removeAll: function() { this._i = this._len; while (this._i--) { this.plugins[this._i].destroy(); } this.plugins.length = 0; this._len = 0; }, preUpdate: function () { this._i = this._len; while (this._i--) { if (this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate) { this.plugins[this._i].preUpdate(); } } }, update: function () { this._i = this._len; while (this._i--) { if (this.plugins[this._i].active && this.plugins[this._i].hasUpdate) { this.plugins[this._i].update(); } } }, postUpdate: function () { this._i = this._len; while (this._i--) { if (this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate) { this.plugins[this._i].postUpdate(); } } }, render: function () { this._i = this._len; while (this._i--) { if (this.plugins[this._i].visible && this.plugins[this._i].hasRender) { this.plugins[this._i].render(); } } }, postRender: function () { this._i = this._len; while (this._i--) { if (this.plugins[this._i].visible && this.plugins[this._i].hasPostRender) { this.plugins[this._i].postRender(); } } }, destroy: function () { this.removeAll(); this.game = null; } }; Phaser.PluginManager.prototype.constructor = Phaser.PluginManager; Phaser.Stage = function (game) { this.game = game; PIXI.DisplayObjectContainer.call(this); this.name = '_stage_root'; this.disableVisibilityChange = false; this.exists = true; this.worldTransform = new PIXI.Matrix(); this.stage = this; this.currentRenderOrderID = 0; this._hiddenVar = 'hidden'; this._onChange = null; this._bgColor = { r: 0, g: 0, b: 0, a: 0, color: 0, rgba: '#000000' }; if (!this.game.transparent) { this._bgColor.a = 1; } if (game.config) { this.parseConfig(game.config); } }; Phaser.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); Phaser.Stage.prototype.constructor = Phaser.Stage; Phaser.Stage.prototype.parseConfig = function (config) { if (config['disableVisibilityChange']) { this.disableVisibilityChange = config['disableVisibilityChange']; } if (config['backgroundColor']) { this.setBackgroundColor(config['backgroundColor']); } }; Phaser.Stage.prototype.boot = function () { Phaser.DOM.getOffset(this.game.canvas, this.offset); Phaser.Canvas.setUserSelect(this.game.canvas, 'none'); Phaser.Canvas.setTouchAction(this.game.canvas, 'none'); this.checkVisibility(); }; Phaser.Stage.prototype.preUpdate = function () { this.currentRenderOrderID = 0; for (var i = 0; i < this.children.length; i++) { this.children[i].preUpdate(); } }; Phaser.Stage.prototype.update = function () { var i = this.children.length; while (i--) { this.children[i].update(); } }; Phaser.Stage.prototype.postUpdate = function () { this.game.camera.update(); if (this.game.camera.target) { this.game.camera.target.postUpdate(); this.updateTransform(); this.game.camera.updateTarget(); } for (var i = 0; i < this.children.length; i++) { this.children[i].postUpdate(); } this.updateTransform(); }; Phaser.Stage.prototype.updateTransform = function () { this.worldAlpha = 1; for (var i = 0; i < this.children.length; i++) { this.children[i].updateTransform(); } }; Phaser.Stage.prototype.checkVisibility = function () { if (document.hidden !== undefined) { this._hiddenVar = 'visibilitychange'; } else if (document.webkitHidden !== undefined) { this._hiddenVar = 'webkitvisibilitychange'; } else if (document.mozHidden !== undefined) { this._hiddenVar = 'mozvisibilitychange'; } else if (document.msHidden !== undefined) { this._hiddenVar = 'msvisibilitychange'; } else { this._hiddenVar = null; } var _this = this; this._onChange = function (event) { return _this.visibilityChange(event); }; if (this._hiddenVar) { document.addEventListener(this._hiddenVar, this._onChange, false); } window.onblur = this._onChange; window.onfocus = this._onChange; window.onpagehide = this._onChange; window.onpageshow = this._onChange; if (this.game.device.cocoonJSApp) { CocoonJS.App.onSuspended.addEventListener(function () { Phaser.Stage.prototype.visibilityChange.call(_this, { type: "pause" }); }); CocoonJS.App.onActivated.addEventListener(function () { Phaser.Stage.prototype.visibilityChange.call(_this, { type: "resume" }); }); } }; Phaser.Stage.prototype.visibilityChange = function (event) { if (event.type === 'pagehide' || event.type === 'blur' || event.type === 'pageshow' || event.type === 'focus') { if (event.type === 'pagehide' || event.type === 'blur') { this.game.focusLoss(event); } else if (event.type === 'pageshow' || event.type === 'focus') { this.game.focusGain(event); } return; } if (this.disableVisibilityChange) { return; } if (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || event.type === "pause") { this.game.gamePaused(event); } else { this.game.gameResumed(event); } }; Phaser.Stage.prototype.setBackgroundColor = function (color) { if (this.game.transparent) { return; } Phaser.Color.valueToColor(color, this._bgColor); Phaser.Color.updateColor(this._bgColor); this._bgColor.r /= 255; this._bgColor.g /= 255; this._bgColor.b /= 255; this._bgColor.a = 1; }; Phaser.Stage.prototype.destroy = function () { if (this._hiddenVar) { document.removeEventListener(this._hiddenVar, this._onChange, false); } window.onpagehide = null; window.onpageshow = null; window.onblur = null; window.onfocus = null; }; Object.defineProperty(Phaser.Stage.prototype, "backgroundColor", { get: function () { return this._bgColor.color; }, set: function (color) { this.setBackgroundColor(color); } }); Object.defineProperty(Phaser.Stage.prototype, "smoothed", { get: function () { return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR; }, set: function (value) { if (value) { PIXI.scaleModes.DEFAULT = PIXI.scaleModes.LINEAR; } else { PIXI.scaleModes.DEFAULT = PIXI.scaleModes.NEAREST; } } });