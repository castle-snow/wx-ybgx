import PIXI from './pixi-wx.js'; import Phaser from './phaser-wx-main.js'; Phaser.Device = function () { this.deviceReadyAt = 0; this.initialized = false; this.desktop = false; this.iOS = false; this.iOSVersion = 0; this.cocoonJS = false; this.cocoonJSApp = false; this.cordova = false; this.node = false; this.nodeWebkit = false; this.electron = false; this.ejecta = false; this.crosswalk = false; this.android = false; this.chromeOS = false; this.linux = false; this.macOS = false; this.windows = false; this.windowsPhone = false; this.canvas = false; this.canvasBitBltShift = null; this.webGL = false; this.file = false; this.fileSystem = false; this.localStorage = false; this.worker = false; this.css3D = false; this.pointerLock = false; this.typedArray = false; this.vibration = false; this.getUserMedia = true; this.quirksMode = false; this.touch = false; this.mspointer = false; this.wheelEvent = null; this.arora = false; this.chrome = false; this.chromeVersion = 0; this.epiphany = false; this.firefox = false; this.firefoxVersion = 0; this.ie = false; this.ieVersion = 0; this.trident = false; this.tridentVersion = 0; this.edge = false; this.mobileSafari = false; this.midori = false; this.opera = false; this.safari = false; this.safariVersion = 0; this.webApp = false; this.silk = false; this.audioData = false; this.webAudio = false; this.ogg = false; this.opus = false; this.mp3 = false; this.wav = false; this.m4a = false; this.webm = false; this.dolby = false; this.oggVideo = false; this.h264Video = false; this.mp4Video = false; this.webmVideo = false; this.vp9Video = false; this.hlsVideo = false; this.iPhone = false; this.iPhone4 = false; this.iPad = false; this.pixelRatio = 0; this.littleEndian = false; this.LITTLE_ENDIAN = false; this.support32bit = false; this.fullscreen = false; this.requestFullscreen = ''; this.cancelFullscreen = ''; this.fullscreenKeyboard = false; }; Phaser.Device = new Phaser.Device(); Phaser.Device.onInitialized = new Phaser.Signal(); Phaser.Device.whenReady = function (callback, context, nonPrimer) { var readyCheck = this._readyCheck; if (this.deviceReadyAt || !readyCheck) { callback.call(context, this); } else if (readyCheck._monitor || nonPrimer) { readyCheck._queue = readyCheck._queue || []; readyCheck._queue.push([callback, context]); } else { readyCheck._monitor = readyCheck.bind(this); readyCheck._queue = readyCheck._queue || []; readyCheck._queue.push([callback, context]); var cordova = typeof window.cordova !== 'undefined'; var cocoonJS = navigator['isCocoonJS']; if (document.readyState === 'complete' || document.readyState === 'interactive') { window.setTimeout(readyCheck._monitor, 0); } else if (cordova && !cocoonJS) { document.addEventListener('deviceready', readyCheck._monitor, false); } else { document.addEventListener('DOMContentLoaded', readyCheck._monitor, false); window.addEventListener('load', readyCheck._monitor, false); } } }; Phaser.Device._readyCheck = function () { var readyCheck = this._readyCheck; if (!document.body) { window.setTimeout(readyCheck._monitor, 20); } else if (!this.deviceReadyAt) { this.deviceReadyAt = Date.now(); document.removeEventListener('deviceready', readyCheck._monitor); document.removeEventListener('DOMContentLoaded', readyCheck._monitor); window.removeEventListener('load', readyCheck._monitor); this._initialize(); this.initialized = true; this.onInitialized.dispatch(this); var item; while ((item = readyCheck._queue.shift())) { var callback = item[0]; var context = item[1]; callback.call(context, this); } this._readyCheck = null; this._initialize = null; this.onInitialized = null; } }; Phaser.Device._initialize = function () { var device = this; function _checkOS () { var ua = navigator.userAgent; if (/Playstation Vita/.test(ua)) { device.vita = true; } else if (/Kindle/.test(ua) || /\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua)) { device.kindle = true; } else if (/Android/.test(ua)) { device.android = true; } else if (/CrOS/.test(ua)) { device.chromeOS = true; } else if (/iP[ao]d|iPhone/i.test(ua)) { device.iOS = true; (navigator.appVersion).match(/OS (\d+)/); device.iOSVersion = parseInt(RegExp.$1, 10); } else if (/Linux/.test(ua)) { device.linux = true; } else if (/Mac OS/.test(ua)) { device.macOS = true; } else if (/Windows/.test(ua)) { device.windows = true; } if (/Windows Phone/i.test(ua) || /IEMobile/i.test(ua)) { device.android = false; device.iOS = false; device.macOS = false; device.windows = true; device.windowsPhone = true; } var silk = /Silk/.test(ua); if (device.windows || device.macOS || (device.linux && !silk) || device.chromeOS) { device.desktop = true; } if (device.windowsPhone || ((/Windows NT/i.test(ua)) && (/Touch/i.test(ua)))) { device.desktop = false; } } function _checkFeatures () { device.canvas = !!window['CanvasRenderingContext2D'] || device.cocoonJS; try { device.localStorage = !!localStorage.getItem; } catch (error) { device.localStorage = false; } device.file = !!window['File'] && !!window['FileReader'] && !!window['FileList'] && !!window['Blob']; device.fileSystem = !!window['requestFileSystem']; device.webGL = ( function () { try { var canvas = document.createElement( 'canvas' );  canvas.screencanvas = false; return !! window.WebGLRenderingContext && ( canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' ) ); } catch( e ) { return false; } } )(); device.webGL = !!device.webGL; device.worker = !!window['Worker']; device.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document; device.quirksMode = (document.compatMode === 'CSS1Compat') ? false : true; navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia; window.URL = window.URL; device.getUserMedia = device.getUserMedia && !!navigator.getUserMedia && !!window.URL; if (device.firefox && device.firefoxVersion < 21) { device.getUserMedia = false; } if (!device.iOS && (device.ie || device.firefox || device.chrome)) { device.canvasBitBltShift = true; } if (device.safari || device.mobileSafari) { device.canvasBitBltShift = false; } } function _checkInput () { if ('ontouchstart' in document.documentElement || (window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1)) { device.touch = true; } if (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) { device.mspointer = true; } if (!device.cocoonJS) { if ('onwheel' in window || (device.ie && 'WheelEvent' in window)) { device.wheelEvent = 'wheel'; } else if ('onmousewheel' in window) { device.wheelEvent = 'mousewheel'; } else if (device.firefox && 'MouseScrollEvent' in window) { device.wheelEvent = 'DOMMouseScroll'; } } } function _checkFullScreenSupport () { var fs = [ 'requestFullscreen', 'requestFullScreen', 'webkitRequestFullscreen', 'webkitRequestFullScreen', 'msRequestFullscreen', 'msRequestFullScreen', 'mozRequestFullScreen', 'mozRequestFullscreen' ]; var element = document.createElement('div'); for (var i = 0; i < fs.length; i++) { if (element[fs[i]]) { device.fullscreen = true; device.requestFullscreen = fs[i]; break; } } var cfs = [ 'cancelFullScreen', 'exitFullscreen', 'webkitCancelFullScreen', 'webkitExitFullscreen', 'msCancelFullScreen', 'msExitFullscreen', 'mozCancelFullScreen', 'mozExitFullscreen' ]; if (device.fullscreen) { for (var i = 0; i < cfs.length; i++) { if (document[cfs[i]]) { device.cancelFullscreen = cfs[i]; break; } } } if (window['Element'] && Element['ALLOW_KEYBOARD_INPUT']) { device.fullscreenKeyboard = true; } } function _checkBrowser () { var ua = navigator.userAgent; if (/Arora/.test(ua)) { device.arora = true; } else if (/Edge\/\d+/.test(ua)) { device.edge = true; } else if (/Chrome\/(\d+)/.test(ua) && !device.windowsPhone) { device.chrome = true; device.chromeVersion = parseInt(RegExp.$1, 10); } else if (/Epiphany/.test(ua)) { device.epiphany = true; } else if (/Firefox\D+(\d+)/.test(ua)) { device.firefox = true; device.firefoxVersion = parseInt(RegExp.$1, 10); } else if (/AppleWebKit/.test(ua) && device.iOS) { device.mobileSafari = true; } else if (/MSIE (\d+\.\d+);/.test(ua)) { device.ie = true; device.ieVersion = parseInt(RegExp.$1, 10); } else if (/Midori/.test(ua)) { device.midori = true; } else if (/Opera/.test(ua)) { device.opera = true; } else if (/Safari\/(\d+)/.test(ua) && !device.windowsPhone) { device.safari = true; if (/Version\/(\d+)\./.test(ua)) { device.safariVersion = parseInt(RegExp.$1, 10); } } else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua)) { device.ie = true; device.trident = true; device.tridentVersion = parseInt(RegExp.$1, 10); device.ieVersion = parseInt(RegExp.$3, 10); } if (/Silk/.test(ua)) { device.silk = true; } if (navigator['standalone']) { device.webApp = true; } if (typeof window.cordova !== 'undefined') { device.cordova = true; } if (typeof process !== 'undefined' && typeof require !== 'undefined') { device.node = true; } if (device.node && typeof process.versions === 'object') { device.nodeWebkit = !!process.versions['node-webkit']; device.electron = !!process.versions.electron; } if (navigator['isCocoonJS']) { device.cocoonJS = true; } if (device.cocoonJS) { try { device.cocoonJSApp = (typeof CocoonJS !== 'undefined'); } catch(error) { device.cocoonJSApp = false; } } if (typeof window.ejecta !== 'undefined') { device.ejecta = true; } if (/Crosswalk/.test(ua)) { device.crosswalk = true; } } function _checkVideo () { var videoElement = document.createElement("video"); var result = false; try { if (result = !!videoElement.canPlayType) { if (videoElement.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, '')) { device.oggVideo = true; } if (videoElement.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, '')) { device.h264Video = true; device.mp4Video = true; } if (videoElement.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, '')) { device.webmVideo = true; } if (videoElement.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, '')) { device.vp9Video = true; } if (videoElement.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, '')) { device.hlsVideo = true; } } } catch (e) {} } function _checkAudio () { device.audioData = !!(window['Audio']); device.webAudio = !!(window['AudioContext'] || window['webkitAudioContext']); var audioElement = document.createElement('audio'); var result = false; try { if (result = !!audioElement.canPlayType) { if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, '')) { device.ogg = true; } if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || audioElement.canPlayType('audio/opus;').replace(/^no$/, '')) { device.opus = true; } if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, '')) { device.mp3 = true; } if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, '')) { device.wav = true; } if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, '')) { device.m4a = true; } if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '')) { device.webm = true; } if (audioElement.canPlayType('audio/mp4;codecs="ec-3"') !== '') { if (device.edge) { device.dolby = true; } else if (device.safari && device.safariVersion >= 9) { if (/Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) { var major = parseInt(RegExp.$1, 10); var minor = parseInt(RegExp.$2, 10); if ((major === 10 && minor >= 11) || major > 10) { device.dolby = true; } } } } } } catch (e) { } } function _checkIsLittleEndian () { var a = new ArrayBuffer(4); var b = new Uint8Array(a); var c = new Uint32Array(a); b[0] = 0xa1; b[1] = 0xb2; b[2] = 0xc3; b[3] = 0xd4; if (c[0] === 0xd4c3b2a1) { return true; } if (c[0] === 0xa1b2c3d4) { return false; } else { return null; } } function _checkIsUint8ClampedImageData () { if (Uint8ClampedArray === undefined) { return false; } var elem = PIXI.CanvasPool.create(this, 1, 1); var ctx = elem.getContext('2d'); if (!ctx) { return false; } var image = ctx.createImageData(1, 1); PIXI.CanvasPool.remove(this); return image.data instanceof Uint8ClampedArray; } function _checkDevice () { device.pixelRatio = window['devicePixelRatio'] || 1; device.iPhone = navigator.userAgent.toLowerCase().indexOf('iphone') !== -1; device.iPhone4 = (device.pixelRatio === 2 && device.iPhone); device.iPad = navigator.userAgent.toLowerCase().indexOf('ipad') !== -1; if (typeof Int8Array !== 'undefined') { device.typedArray = true; } else { device.typedArray = false; } if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined') { device.littleEndian = _checkIsLittleEndian(); device.LITTLE_ENDIAN = device.littleEndian; } device.support32bit = (typeof ArrayBuffer !== 'undefined' && typeof Uint8ClampedArray !== 'undefined' && typeof Int32Array !== 'undefined' && device.littleEndian !== null && _checkIsUint8ClampedImageData()); navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate; if (navigator.vibrate) { device.vibration = true; } } function _checkCSS3D () { var el = document.createElement('p'); var has3d; var transforms = { 'webkitTransform': '-webkit-transform', 'OTransform': '-o-transform', 'msTransform': '-ms-transform', 'MozTransform': '-moz-transform', 'transform': 'transform' }; document.body.insertBefore(el, null); for (var t in transforms) { if (el.style[t] !== undefined) { el.style[t] = "translate3d(1px,1px,1px)"; has3d = window.getComputedStyle(el).getPropertyValue(transforms[t]); } } document.body.removeChild(el); device.css3D = (has3d !== undefined && has3d.length > 0 && has3d !== "none"); } _checkOS(); _checkBrowser(); _checkAudio(); _checkVideo(); _checkCSS3D(); _checkDevice(); _checkFeatures(); _checkFullScreenSupport(); _checkInput(); }; Phaser.Device.canPlayAudio = function (type) { if (type === 'mp3' && this.mp3) { return true; } else if (type === 'ogg' && (this.ogg || this.opus)) { return true; } else if (type === 'm4a' && this.m4a) { return true; } else if (type === 'opus' && this.opus) { return true; } else if (type === 'wav' && this.wav) { return true; } else if (type === 'webm' && this.webm) { return true; } else if (type === 'mp4' && this.dolby) { return true; } return false; }; Phaser.Device.canPlayVideo = function (type) { if (type === 'webm' && (this.webmVideo || this.vp9Video)) { return true; } else if (type === 'mp4' && (this.mp4Video || this.h264Video)) { return true; } else if ((type === 'ogg' || type === 'ogv') && this.oggVideo) { return true; } else if (type === 'mpeg' && this.hlsVideo) { return true; } return false; }; Phaser.Device.isConsoleOpen = function () { if (window.console && window.console['firebug']) { return true; } if (window.console) { console.profile(); console.profileEnd(); if (console.clear) { console.clear(); } if (console['profiles']) { return console['profiles'].length > 0; } } return false; }; Phaser.Device.isAndroidStockBrowser = function () { var matches = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/); return matches && matches[1] < 537; }; Phaser.Canvas = { create: function (parent, width, height, id, skipPool) { width = width || 256; height = height || 256; var canvas = (skipPool) ? document.createElement('canvas') : PIXI.CanvasPool.create(parent, width, height); if (typeof id === 'string' && id !== '') { canvas.id = id; } canvas.width = width; canvas.height = height; canvas.style.display = 'block'; return canvas; }, setBackgroundColor: function (canvas, color) { color = color || 'rgb(0,0,0)'; canvas.style.backgroundColor = color; return canvas; }, setTouchAction: function (canvas, value) { value = value || 'none'; canvas.style.msTouchAction = value; canvas.style['ms-touch-action'] = value; canvas.style['touch-action'] = value; return canvas; }, setUserSelect: function (canvas, value) { value = value || 'none'; canvas.style['-webkit-touch-callout'] = value; canvas.style['-webkit-user-select'] = value; canvas.style['-khtml-user-select'] = value; canvas.style['-moz-user-select'] = value; canvas.style['-ms-user-select'] = value; canvas.style['user-select'] = value; canvas.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)'; return canvas; }, addToDOM: function (canvas, parent, overflowHidden) { var target; if (overflowHidden === undefined) { overflowHidden = true; } if (parent) { if (typeof parent === 'string') { target = document.getElementById(parent); } else if (typeof parent === 'object' && parent.nodeType === 1) { target = parent; } } if (!target) { target = document.body; } if (overflowHidden && target.style) { target.style.overflow = 'hidden'; } target.appendChild(canvas); return canvas; }, removeFromDOM: function (canvas) { if (canvas.parentNode) { canvas.parentNode.removeChild(canvas); } }, setTransform: function (context, translateX, translateY, scaleX, scaleY, skewX, skewY) { context.setTransform(scaleX, skewX, skewY, scaleY, translateX, translateY); return context; }, setSmoothingEnabled: function (context, value) { var s = Phaser.Canvas.getSmoothingPrefix(context); if (s) { context[s] = value; } return context; }, getSmoothingPrefix: function (context) { var vendor = [ 'i', 'webkitI', 'msI', 'mozI', 'oI' ]; for (var prefix in vendor) { var s = vendor[prefix] + 'mageSmoothingEnabled'; if (s in context) { return s; } } return null; }, getSmoothingEnabled: function (context) { var s = Phaser.Canvas.getSmoothingPrefix(context); if (s) { return context[s]; } }, setImageRenderingCrisp: function (canvas) { var types = [ 'optimizeSpeed', 'crisp-edges', '-moz-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'pixelated' ]; for (var i = 0; i < types.length; i++) { canvas.style['image-rendering'] = types[i]; } canvas.style.msInterpolationMode = 'nearest-neighbor'; return canvas; }, setImageRenderingBicubic: function (canvas) { canvas.style['image-rendering'] = 'auto'; canvas.style.msInterpolationMode = 'bicubic'; return canvas; } }; Phaser.RequestAnimationFrame = function(game, forceSetTimeOut) { if (forceSetTimeOut === undefined) { forceSetTimeOut = false; } this.game = game; this.isRunning = false; this.forceSetTimeOut = forceSetTimeOut; var vendors = [ 'ms', 'moz', 'webkit', 'o' ]; for (var x = 0; x < vendors.length && !window.requestAnimationFrame; x++) { window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame']; window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']; } this._isSetTimeOut = false; this._onLoop = null; this._timeOutID = null; }; Phaser.RequestAnimationFrame.prototype = { start: function () { this.isRunning = true; var _this = this; if (!window.requestAnimationFrame || this.forceSetTimeOut) { this._isSetTimeOut = true; this._onLoop = function () { return _this.updateSetTimeout(); }; this._timeOutID = window.setTimeout(this._onLoop, 0); } else { this._isSetTimeOut = false; this._onLoop = function (time) { return _this.updateRAF(time); }; this._timeOutID = window.requestAnimationFrame(this._onLoop); } }, updateRAF: function (rafTime) { if (this.isRunning) { this.game.update(Math.floor(rafTime)); this._timeOutID = window.requestAnimationFrame(this._onLoop); } }, updateSetTimeout: function () { if (this.isRunning) { this.game.update(Date.now()); this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall); } }, stop: function () { if (this._isSetTimeOut) { clearTimeout(this._timeOutID); } else { window.cancelAnimationFrame(this._timeOutID); } this.isRunning = false; }, isSetTimeOut: function () { return this._isSetTimeOut; }, isRAF: function () { return (this._isSetTimeOut === false); } }; Phaser.RequestAnimationFrame.prototype.constructor = Phaser.RequestAnimationFrame; Phaser.Math = { PI2: Math.PI * 2, between: function (min, max) { return Math.floor(Math.random() * (max - min + 1) + min); }, fuzzyEqual: function (a, b, epsilon) { if (epsilon === undefined) { epsilon = 0.0001; } return Math.abs(a - b) < epsilon; }, fuzzyLessThan: function (a, b, epsilon) { if (epsilon === undefined) { epsilon = 0.0001; } return a < b + epsilon; }, fuzzyGreaterThan: function (a, b, epsilon) { if (epsilon === undefined) { epsilon = 0.0001; } return a > b - epsilon; }, fuzzyCeil: function (val, epsilon) { if (epsilon === undefined) { epsilon = 0.0001; } return Math.ceil(val - epsilon); }, fuzzyFloor: function (val, epsilon) { if (epsilon === undefined) { epsilon = 0.0001; } return Math.floor(val + epsilon); }, average: function () { var sum = 0; var len = arguments.length; for (var i = 0; i < len; i++) { sum += (+arguments[i]); } return sum / len; }, shear: function (n) { return n % 1; }, snapTo: function (input, gap, start) { if (start === undefined) { start = 0; } if (gap === 0) { return input; } input -= start; input = gap * Math.round(input / gap); return start + input; }, snapToFloor: function (input, gap, start) { if (start === undefined) { start = 0; } if (gap === 0) { return input; } input -= start; input = gap * Math.floor(input / gap); return start + input; }, snapToCeil: function (input, gap, start) { if (start === undefined) { start = 0; } if (gap === 0) { return input; } input -= start; input = gap * Math.ceil(input / gap); return start + input; }, roundTo: function (value, place, base) { if (place === undefined) { place = 0; } if (base === undefined) { base = 10; } var p = Math.pow(base, -place); return Math.round(value * p) / p; }, floorTo: function (value, place, base) { if (place === undefined) { place = 0; } if (base === undefined) { base = 10; } var p = Math.pow(base, -place); return Math.floor(value * p) / p; }, ceilTo: function (value, place, base) { if (place === undefined) { place = 0; } if (base === undefined) { base = 10; } var p = Math.pow(base, -place); return Math.ceil(value * p) / p; }, rotateToAngle: function (currentAngle, targetAngle, lerp) { if (lerp === undefined) { lerp = 0.05; } if (currentAngle === targetAngle) { return currentAngle; } if (Math.abs(targetAngle - currentAngle) <= lerp || Math.abs(targetAngle - currentAngle) >= (Phaser.Math.PI2 - lerp)) { currentAngle = targetAngle; } else { if (Math.abs(targetAngle - currentAngle) > Math.PI) { if (targetAngle < currentAngle) { targetAngle += Phaser.Math.PI2; } else { targetAngle -= Phaser.Math.PI2; } } if (targetAngle > currentAngle) { currentAngle += lerp; } else if (targetAngle < currentAngle) { currentAngle -= lerp; } } return currentAngle; }, getShortestAngle: function (angle1, angle2) { var difference = angle2 - angle1; if (difference === 0) { return 0; } var times = Math.floor((difference - (-180)) / 360); return difference - (times * 360); }, angleBetween: function (x1, y1, x2, y2) { return Math.atan2(y2 - y1, x2 - x1); }, angleBetweenY: function (x1, y1, x2, y2) { return Math.atan2(x2 - x1, y2 - y1); }, angleBetweenPoints: function (point1, point2) { return Math.atan2(point2.y - point1.y, point2.x - point1.x); }, angleBetweenPointsY: function (point1, point2) { return Math.atan2(point2.x - point1.x, point2.y - point1.y); }, reverseAngle: function (angleRad) { return this.normalizeAngle(angleRad + Math.PI, true); }, normalizeAngle: function (angleRad) { angleRad = angleRad % (2 * Math.PI); return angleRad >= 0 ? angleRad : angleRad + 2 * Math.PI; }, maxAdd: function (value, amount, max) { return Math.min(value + amount, max); }, minSub: function (value, amount, min) { return Math.max(value - amount, min); }, wrap: function (value, min, max) { var range = max - min; if (range <= 0) { return 0; } var result = (value - min) % range; if (result < 0) { result += range; } return result + min; }, wrapValue: function (value, amount, max) { var diff; value = Math.abs(value); amount = Math.abs(amount); max = Math.abs(max); diff = (value + amount) % max; return diff; }, isOdd: function (n) { return !!(n & 1); }, isEven: function (n) { return !(n & 1); }, min: function () { if (arguments.length === 1 && typeof arguments[0] === 'object') { var data = arguments[0]; } else { var data = arguments; } for (var i = 1, min = 0, len = data.length; i < len; i++) { if (data[i] < data[min]) { min = i; } } return data[min]; }, max: function () { if (arguments.length === 1 && typeof arguments[0] === 'object') { var data = arguments[0]; } else { var data = arguments; } for (var i = 1, max = 0, len = data.length; i < len; i++) { if (data[i] > data[max]) { max = i; } } return data[max]; }, minProperty: function (property) { if (arguments.length === 2 && typeof arguments[1] === 'object') { var data = arguments[1]; } else { var data = arguments.slice(1); } for (var i = 1, min = 0, len = data.length; i < len; i++) { if (data[i][property] < data[min][property]) { min = i; } } return data[min][property]; }, maxProperty: function (property) { if (arguments.length === 2 && typeof arguments[1] === 'object') { var data = arguments[1]; } else { var data = arguments.slice(1); } for (var i = 1, max = 0, len = data.length; i < len; i++) { if (data[i][property] > data[max][property]) { max = i; } } return data[max][property]; }, wrapAngle: function (angle, radians) { return radians ? this.wrap(angle, -Math.PI, Math.PI) : this.wrap(angle, -180, 180); }, linearInterpolation: function (v, k) { var m = v.length - 1; var f = m * k; var i = Math.floor(f); if (k < 0) { return this.linear(v[0], v[1], f); } if (k > 1) { return this.linear(v[m], v[m - 1], m - f); } return this.linear(v[i], v[i + 1 > m ? m : i + 1], f - i); }, bezierInterpolation: function (v, k) { var b = 0; var n = v.length - 1; for (var i = 0; i <= n; i++) { b += Math.pow(1 - k, n - i) * Math.pow(k, i) * v[i] * this.bernstein(n, i); } return b; }, catmullRomInterpolation: function (v, k) { var m = v.length - 1; var f = m * k; var i = Math.floor(f); if (v[0] === v[m]) { if (k < 0) { i = Math.floor(f = m * (1 + k)); } return this.catmullRom(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i); } else { if (k < 0) { return v[0] - (this.catmullRom(v[0], v[0], v[1], v[1], -f) - v[0]); } if (k > 1) { return v[m] - (this.catmullRom(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]); } return this.catmullRom(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i); } }, linear: function (p0, p1, t) { return (p1 - p0) * t + p0; }, bernstein: function (n, i) { return this.factorial(n) / this.factorial(i) / this.factorial(n - i); }, factorial: function (value) { if (value === 0) { return 1; } var res = value; while(--value) { res *= value; } return res; }, catmullRom: function (p0, p1, p2, p3, t) { var v0 = (p2 - p0) * 0.5, v1 = (p3 - p1) * 0.5, t2 = t * t, t3 = t * t2; return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1; }, difference: function (a, b) { return Math.abs(a - b); }, roundAwayFromZero: function (value) { return (value > 0) ? Math.ceil(value) : Math.floor(value); }, sinCosGenerator: function (length, sinAmplitude, cosAmplitude, frequency) { if (sinAmplitude === undefined) { sinAmplitude = 1.0; } if (cosAmplitude === undefined) { cosAmplitude = 1.0; } if (frequency === undefined) { frequency = 1.0; } var sin = sinAmplitude; var cos = cosAmplitude; var frq = frequency * Math.PI / length; var cosTable = []; var sinTable = []; for (var c = 0; c < length; c++) { cos -= sin * frq; sin += cos * frq; cosTable[c] = cos; sinTable[c] = sin; } return { sin: sinTable, cos: cosTable, length: length }; }, distance: function (x1, y1, x2, y2) { var dx = x1 - x2; var dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }, distanceSq: function (x1, y1, x2, y2) { var dx = x1 - x2; var dy = y1 - y2; return dx * dx + dy * dy; }, distancePow: function (x1, y1, x2, y2, pow) { if (pow === undefined) { pow = 2; } return Math.sqrt(Math.pow(x2 - x1, pow) + Math.pow(y2 - y1, pow)); }, clamp: function (v, min, max) { if (v < min) { return min; } else if (max < v) { return max; } else { return v; } }, clampBottom: function (x, a) { return x < a ? a : x; }, within: function (a, b, tolerance) { return (Math.abs(a - b) <= tolerance); }, mapLinear: function (x, a1, a2, b1, b2) { return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 ); }, smoothstep: function (x, min, max) { x = Math.max(0, Math.min(1, (x - min) / (max - min))); return x * x * (3 - 2 * x); }, smootherstep: function (x, min, max) { x = Math.max(0, Math.min(1, (x - min) / (max - min))); return x * x * x * (x * (x * 6 - 15) + 10); }, sign: function (x) { return ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 ); }, percent: function (a, b, base) { if (base === undefined) { base = 0; } if (a > b || base > b) { return 1; } else if (a < base || base > a) { return 0; } else { return (a - base) / b; } } }; var degreeToRadiansFactor = Math.PI / 180; var radianToDegreesFactor = 180 / Math.PI; Phaser.Math.degToRad = function degToRad (degrees) { return degrees * degreeToRadiansFactor; }; Phaser.Math.radToDeg = function radToDeg (radians) { return radians * radianToDegreesFactor; }; Phaser.RandomDataGenerator = function (seeds) { if (seeds === undefined) { seeds = []; } this.c = 1; this.s0 = 0; this.s1 = 0; this.s2 = 0; if (typeof seeds === 'string') { this.state(seeds); } else { this.sow(seeds); } }; Phaser.RandomDataGenerator.prototype = { rnd: function () { var t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; this.c = t | 0; this.s0 = this.s1; this.s1 = this.s2; this.s2 = t - this.c; return this.s2; }, sow: function (seeds) { this.s0 = this.hash(' '); this.s1 = this.hash(this.s0); this.s2 = this.hash(this.s1); this.c = 1; if (!seeds) { return; } for (var i = 0; i < seeds.length && (seeds[i] != null); i++) { var seed = seeds[i]; this.s0 -= this.hash(seed); this.s0 += ~~(this.s0 < 0); this.s1 -= this.hash(seed); this.s1 += ~~(this.s1 < 0); this.s2 -= this.hash(seed); this.s2 += ~~(this.s2 < 0); } }, hash: function (data) { var h, i, n; n = 0xefc8249d; data = data.toString(); for (i = 0; i < data.length; i++) { n += data.charCodeAt(i); h = 0.02519603282416938 * n; n = h >>> 0; h -= n; h *= n; n = h >>> 0; h -= n; n += h * 0x100000000; } return (n >>> 0) * 2.3283064365386963e-10; }, integer: function() { return this.rnd.apply(this) * 0x100000000; }, frac: function() { return this.rnd.apply(this) + (this.rnd.apply(this) * 0x200000 | 0) * 1.1102230246251565e-16; }, real: function() { return this.integer() + this.frac(); }, integerInRange: function (min, max) { return Math.floor(this.realInRange(0, max - min + 1) + min); }, between: function (min, max) { return this.integerInRange(min, max); }, realInRange: function (min, max) { return this.frac() * (max - min) + min; }, normal: function () { return 1 - 2 * this.frac(); }, uuid: function () { var a = ''; var b = ''; for (b = a = ''; a++ < 36; b +=~a % 5 | a * 3&4 ? (a^15 ? 8^this.frac() * (a^20 ? 16 : 4) : 4).toString(16) : '-') { } return b; }, pick: function (ary) { return ary[this.integerInRange(0, ary.length - 1)]; }, sign: function () { return this.pick([-1, 1]); }, weightedPick: function (ary) { return ary[~~(Math.pow(this.frac(), 2) * (ary.length - 1) + 0.5)]; }, timestamp: function (min, max) { return this.realInRange(min || 946684800000, max || 1577862000000); }, angle: function() { return this.integerInRange(-180, 180); }, state: function (state) { if (typeof state === 'string' && state.match(/^!rnd/)) { state = state.split(','); this.c = parseFloat(state[1]); this.s0 = parseFloat(state[2]); this.s1 = parseFloat(state[3]); this.s2 = parseFloat(state[4]); } return ['!rnd', this.c, this.s0, this.s1, this.s2].join(','); } }; Phaser.RandomDataGenerator.prototype.constructor = Phaser.RandomDataGenerator; Phaser.QuadTree = function(x, y, width, height, maxObjects, maxLevels, level) { this.maxObjects = 10; this.maxLevels = 4; this.level = 0; this.bounds = {}; this.objects = []; this.nodes = []; this._empty = []; this.reset(x, y, width, height, maxObjects, maxLevels, level); }; Phaser.QuadTree.prototype = { reset: function (x, y, width, height, maxObjects, maxLevels, level) { this.maxObjects = maxObjects || 10; this.maxLevels = maxLevels || 4; this.level = level || 0; this.bounds = { x: Math.round(x), y: Math.round(y), width: width, height: height, subWidth: Math.floor(width / 2), subHeight: Math.floor(height / 2), right: Math.round(x) + Math.floor(width / 2), bottom: Math.round(y) + Math.floor(height / 2) }; this.objects.length = 0; this.nodes.length = 0; }, populate: function (group) { group.forEach(this.populateHandler, this, true); }, populateHandler: function (sprite) { if (sprite.body && sprite.exists) { this.insert(sprite.body); } }, split: function () { this.nodes[0] = new Phaser.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, (this.level + 1)); this.nodes[1] = new Phaser.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, (this.level + 1)); this.nodes[2] = new Phaser.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, (this.level + 1)); this.nodes[3] = new Phaser.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, (this.level + 1)); }, insert: function (body) { var i = 0; var index; if (this.nodes[0] != null) { index = this.getIndex(body); if (index !== -1) { this.nodes[index].insert(body); return; } } this.objects.push(body); if (this.objects.length > this.maxObjects && this.level < this.maxLevels) { if (this.nodes[0] == null) { this.split(); } while (i < this.objects.length) { index = this.getIndex(this.objects[i]); if (index !== -1) { this.nodes[index].insert(this.objects.splice(i, 1)[0]); } else { i++; } } } }, getIndex: function (rect) { var index = -1; if (rect.x < this.bounds.right && rect.right < this.bounds.right) { if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom) { index = 1; } else if (rect.y > this.bounds.bottom) { index = 2; } } else if (rect.x > this.bounds.right) { if (rect.y < this.bounds.bottom && rect.bottom < this.bounds.bottom) { index = 0; } else if (rect.y > this.bounds.bottom) { index = 3; } } return index; }, retrieve: function (source) { if (source instanceof Phaser.Rectangle) { var returnObjects = this.objects; var index = this.getIndex(source); } else { if (!source.body) { return this._empty; } var returnObjects = this.objects; var index = this.getIndex(source.body); } if (this.nodes[0]) { if (index !== -1) { returnObjects = returnObjects.concat(this.nodes[index].retrieve(source)); } else { returnObjects = returnObjects.concat(this.nodes[0].retrieve(source)); returnObjects = returnObjects.concat(this.nodes[1].retrieve(source)); returnObjects = returnObjects.concat(this.nodes[2].retrieve(source)); returnObjects = returnObjects.concat(this.nodes[3].retrieve(source)); } } return returnObjects; }, clear: function () { this.objects.length = 0; var i = this.nodes.length; while (i--) { this.nodes[i].clear(); this.nodes.splice(i, 1); } this.nodes.length = 0; } }; Phaser.QuadTree.prototype.constructor = Phaser.QuadTree; Phaser.Net = function (game) { this.game = game; }; Phaser.Net.prototype = { getHostName: function () { if (window.location && window.location.hostname) { return window.location.hostname; } return null; }, checkDomainName: function (domain) { return window.location.hostname.indexOf(domain) !== -1; }, updateQueryString: function (key, value, redirect, url) { if (redirect === undefined) { redirect = false; } if (url === undefined || url === '') { url = window.location.href; } var output = ''; var re = new RegExp("([?|&])" + key + "=.*?(&|#|$)(.*)", "gi"); if (re.test(url)) { if (typeof value !== 'undefined' && value !== null) { output = url.replace(re, '$1' + key + "=" + value + '$2$3'); } else { output = url.replace(re, '$1$3').replace(/(&|\?)$/, ''); } } else { if (typeof value !== 'undefined' && value !== null) { var separator = url.indexOf('?') !== -1 ? '&' : '?'; var hash = url.split('#'); url = hash[0] + separator + key + '=' + value; if (hash[1]) { url += '#' + hash[1]; } output = url; } else { output = url; } } if (redirect) { window.location.href = output; } else { return output; } }, getQueryString: function (parameter) { if (parameter === undefined) { parameter = ''; } var output = {}; var keyValues = location.search.substring(1).split('&'); for (var i in keyValues) { var key = keyValues[i].split('='); if (key.length > 1) { if (parameter && parameter === this.decodeURI(key[0])) { return this.decodeURI(key[1]); } else { output[this.decodeURI(key[0])] = this.decodeURI(key[1]); } } } return output; }, decodeURI: function (value) { return decodeURIComponent(value.replace(/\+/g, " ")); } }; Phaser.Net.prototype.constructor = Phaser.Net; Phaser.TweenManager = function (game) { this.game = game; this.frameBased = false; this._tweens = []; this._add = []; this.easeMap = { "Power0": Phaser.Easing.Power0, "Power1": Phaser.Easing.Power1, "Power2": Phaser.Easing.Power2, "Power3": Phaser.Easing.Power3, "Power4": Phaser.Easing.Power4, "Linear": Phaser.Easing.Linear.None, "Quad": Phaser.Easing.Quadratic.Out, "Cubic": Phaser.Easing.Cubic.Out, "Quart": Phaser.Easing.Quartic.Out, "Quint": Phaser.Easing.Quintic.Out, "Sine": Phaser.Easing.Sinusoidal.Out, "Expo": Phaser.Easing.Exponential.Out, "Circ": Phaser.Easing.Circular.Out, "Elastic": Phaser.Easing.Elastic.Out, "Back": Phaser.Easing.Back.Out, "Bounce": Phaser.Easing.Bounce.Out, "Quad.easeIn": Phaser.Easing.Quadratic.In, "Cubic.easeIn": Phaser.Easing.Cubic.In, "Quart.easeIn": Phaser.Easing.Quartic.In, "Quint.easeIn": Phaser.Easing.Quintic.In, "Sine.easeIn": Phaser.Easing.Sinusoidal.In, "Expo.easeIn": Phaser.Easing.Exponential.In, "Circ.easeIn": Phaser.Easing.Circular.In, "Elastic.easeIn": Phaser.Easing.Elastic.In, "Back.easeIn": Phaser.Easing.Back.In, "Bounce.easeIn": Phaser.Easing.Bounce.In, "Quad.easeOut": Phaser.Easing.Quadratic.Out, "Cubic.easeOut": Phaser.Easing.Cubic.Out, "Quart.easeOut": Phaser.Easing.Quartic.Out, "Quint.easeOut": Phaser.Easing.Quintic.Out, "Sine.easeOut": Phaser.Easing.Sinusoidal.Out, "Expo.easeOut": Phaser.Easing.Exponential.Out, "Circ.easeOut": Phaser.Easing.Circular.Out, "Elastic.easeOut": Phaser.Easing.Elastic.Out, "Back.easeOut": Phaser.Easing.Back.Out, "Bounce.easeOut": Phaser.Easing.Bounce.Out, "Quad.easeInOut": Phaser.Easing.Quadratic.InOut, "Cubic.easeInOut": Phaser.Easing.Cubic.InOut, "Quart.easeInOut": Phaser.Easing.Quartic.InOut, "Quint.easeInOut": Phaser.Easing.Quintic.InOut, "Sine.easeInOut": Phaser.Easing.Sinusoidal.InOut, "Expo.easeInOut": Phaser.Easing.Exponential.InOut, "Circ.easeInOut": Phaser.Easing.Circular.InOut, "Elastic.easeInOut": Phaser.Easing.Elastic.InOut, "Back.easeInOut": Phaser.Easing.Back.InOut, "Bounce.easeInOut": Phaser.Easing.Bounce.InOut }; this.game.onPause.add(this._pauseAll, this); this.game.onResume.add(this._resumeAll, this); }; Phaser.TweenManager.prototype = { getAll: function () { return this._tweens; }, removeAll: function () { for (var i = 0; i < this._tweens.length; i++) { this._tweens[i].pendingDelete = true; } this._add = []; }, removeFrom: function (obj, children) { if (children === undefined) { children = true; } var i; var len; if (Array.isArray(obj)) { for (i = 0, len = obj.length; i < len; i++) { this.removeFrom(obj[i]); } } else if (obj.type === Phaser.GROUP && children) { for (var i = 0, len = obj.children.length; i < len; i++) { this.removeFrom(obj.children[i]); } } else { for (i = 0, len = this._tweens.length; i < len; i++) { if (obj === this._tweens[i].target) { this.remove(this._tweens[i]); } } for (i = 0, len = this._add.length; i < len; i++) { if (obj === this._add[i].target) { this.remove(this._add[i]); } } } }, add: function (tween) { tween._manager = this; this._add.push(tween); }, create: function (object) { return new Phaser.Tween(object, this.game, this); }, remove: function (tween) { var i = this._tweens.indexOf(tween); if (i !== -1) { this._tweens[i].pendingDelete = true; } else { i = this._add.indexOf(tween); if (i !== -1) { this._add[i].pendingDelete = true; } } }, update: function () { var addTweens = this._add.length; var numTweens = this._tweens.length; if (numTweens === 0 && addTweens === 0) { return false; } var i = 0; while (i < numTweens) { if (this._tweens[i].update(this.game.time.time)) { i++; } else { this._tweens.splice(i, 1); numTweens--; } } if (addTweens > 0) { this._tweens = this._tweens.concat(this._add); this._add.length = 0; } return true; }, isTweening: function(object) { return this._tweens.some(function(tween) { return tween.target === object; }); }, _pauseAll: function () { for (var i = this._tweens.length - 1; i >= 0; i--) { this._tweens[i]._pause(); } }, _resumeAll: function () { for (var i = this._tweens.length - 1; i >= 0; i--) { this._tweens[i]._resume(); } }, pauseAll: function () { for (var i = this._tweens.length - 1; i >= 0; i--) { this._tweens[i].pause(); } }, resumeAll: function () { for (var i = this._tweens.length - 1; i >= 0; i--) { this._tweens[i].resume(true); } } }; Phaser.TweenManager.prototype.constructor = Phaser.TweenManager; Phaser.Tween = function (target, game, manager) { this.game = game; this.target = target; this.manager = manager; this.timeline = []; this.reverse = false; this.timeScale = 1; this.repeatCounter = 0; this.pendingDelete = false; this.onStart = new Phaser.Signal(); this.onLoop = new Phaser.Signal(); this.onRepeat = new Phaser.Signal(); this.onChildComplete = new Phaser.Signal(); this.onComplete = new Phaser.Signal(); this.isRunning = false; this.current = 0; this.properties = {}; this.chainedTween = null; this.isPaused = false; this.frameBased = manager.frameBased; this._onUpdateCallback = null; this._onUpdateCallbackContext = null; this._pausedTime = 0; this._codePaused = false; this._hasStarted = false; }; Phaser.Tween.prototype = { to: function (properties, duration, ease, autoStart, delay, repeat, yoyo) { if (duration === undefined || duration <= 0) { duration = 1000; } if (ease === undefined || ease === null) { ease = Phaser.Easing.Default; } if (autoStart === undefined) { autoStart = false; } if (delay === undefined) { delay = 0; } if (repeat === undefined) { repeat = 0; } if (yoyo === undefined) { yoyo = false; } if (typeof ease === 'string' && this.manager.easeMap[ease]) { ease = this.manager.easeMap[ease]; } if (this.isRunning) { console.warn('Phaser.Tween.to cannot be called after Tween.start'); return this; } this.timeline.push(new Phaser.TweenData(this).to(properties, duration, ease, delay, repeat, yoyo)); if (autoStart) { this.start(); } return this; }, from: function (properties, duration, ease, autoStart, delay, repeat, yoyo) { if (duration === undefined) { duration = 1000; } if (ease === undefined || ease === null) { ease = Phaser.Easing.Default; } if (autoStart === undefined) { autoStart = false; } if (delay === undefined) { delay = 0; } if (repeat === undefined) { repeat = 0; } if (yoyo === undefined) { yoyo = false; } if (typeof ease === 'string' && this.manager.easeMap[ease]) { ease = this.manager.easeMap[ease]; } if (this.isRunning) { console.warn('Phaser.Tween.from cannot be called after Tween.start'); return this; } this.timeline.push(new Phaser.TweenData(this).from(properties, duration, ease, delay, repeat, yoyo)); if (autoStart) { this.start(); } return this; }, start: function (index) { if (index === undefined) { index = 0; } if (this.game === null || this.target === null || this.timeline.length === 0 || this.isRunning) { return this; } for (var i = 0; i < this.timeline.length; i++) { for (var property in this.timeline[i].vEnd) { this.properties[property] = this.target[property] || 0; if (!Array.isArray(this.properties[property])) { this.properties[property] *= 1.0; } } } for (var i = 0; i < this.timeline.length; i++) { this.timeline[i].loadValues(); } this.manager.add(this); this.isRunning = true; if (index < 0 || index > this.timeline.length - 1) { index = 0; } this.current = index; this.timeline[this.current].start(); return this; }, stop: function (complete) { if (complete === undefined) { complete = false; } this.isRunning = false; this._onUpdateCallback = null; this._onUpdateCallbackContext = null; if (complete) { this.onComplete.dispatch(this.target, this); this._hasStarted = false; if (this.chainedTween) { this.chainedTween.start(); } } this.manager.remove(this); return this; }, updateTweenData: function (property, value, index) { if (this.timeline.length === 0) { return this; } if (index === undefined) { index = 0; } if (index === -1) { for (var i = 0; i < this.timeline.length; i++) { this.timeline[i][property] = value; } } else { this.timeline[index][property] = value; } return this; }, delay: function (duration, index) { return this.updateTweenData('delay', duration, index); }, repeat: function (total, repeatDelay, index) { if (repeatDelay === undefined) { repeatDelay = 0; } this.updateTweenData('repeatCounter', total, index); return this.updateTweenData('repeatDelay', repeatDelay, index); }, repeatDelay: function (duration, index) { return this.updateTweenData('repeatDelay', duration, index); }, yoyo: function(enable, yoyoDelay, index) { if (yoyoDelay === undefined) { yoyoDelay = 0; } this.updateTweenData('yoyo', enable, index); return this.updateTweenData('yoyoDelay', yoyoDelay, index); }, yoyoDelay: function (duration, index) { return this.updateTweenData('yoyoDelay', duration, index); }, easing: function (ease, index) { if (typeof ease === 'string' && this.manager.easeMap[ease]) { ease = this.manager.easeMap[ease]; } return this.updateTweenData('easingFunction', ease, index); }, interpolation: function (interpolation, context, index) { if (context === undefined) { context = Phaser.Math; } this.updateTweenData('interpolationFunction', interpolation, index); return this.updateTweenData('interpolationContext', context, index); }, repeatAll: function (total) { if (total === undefined) { total = 0; } this.repeatCounter = total; return this; }, chain: function () { var i = arguments.length; while (i--) { if (i > 0) { arguments[i - 1].chainedTween = arguments[i]; } else { this.chainedTween = arguments[i]; } } return this; }, loop: function (value) { if (value === undefined) { value = true; } this.repeatCounter = (value) ? -1 : 0; return this; }, onUpdateCallback: function (callback, callbackContext) { this._onUpdateCallback = callback; this._onUpdateCallbackContext = callbackContext; return this; }, pause: function () { this.isPaused = true; this._codePaused = true; this._pausedTime = this.game.time.time; }, _pause: function () { if (!this._codePaused) { this.isPaused = true; this._pausedTime = this.game.time.time; } }, resume: function () { if (this.isPaused) { this.isPaused = false; this._codePaused = false; for (var i = 0; i < this.timeline.length; i++) { if (!this.timeline[i].isRunning) { this.timeline[i].startTime += (this.game.time.time - this._pausedTime); } } } }, _resume: function () { if (this._codePaused) { return; } else { this.resume(); } }, update: function (time) { if (this.pendingDelete || !this.target) { return false; } if (this.isPaused) { return true; } var status = this.timeline[this.current].update(time); if (status === Phaser.TweenData.PENDING) { return true; } else if (status === Phaser.TweenData.RUNNING) { if (!this._hasStarted) { this.onStart.dispatch(this.target, this); this._hasStarted = true; } if (this._onUpdateCallback !== null) { this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]); } return this.isRunning; } else if (status === Phaser.TweenData.LOOPED) { if (this.timeline[this.current].repeatCounter === -1) { this.onLoop.dispatch(this.target, this); } else { this.onRepeat.dispatch(this.target, this); } return true; } else if (status === Phaser.TweenData.COMPLETE) { var complete = false; if (this.reverse) { this.current--; if (this.current < 0) { this.current = this.timeline.length - 1; complete = true; } } else { this.current++; if (this.current === this.timeline.length) { this.current = 0; complete = true; } } if (complete) { if (this.repeatCounter === -1) { this.timeline[this.current].start(); this.onLoop.dispatch(this.target, this); return true; } else if (this.repeatCounter > 0) { this.repeatCounter--; this.timeline[this.current].start(); this.onRepeat.dispatch(this.target, this); return true; } else { this.isRunning = false; this.onComplete.dispatch(this.target, this); this._hasStarted = false; if (this.chainedTween) { this.chainedTween.start(); } return false; } } else { this.onChildComplete.dispatch(this.target, this); this.timeline[this.current].start(); return true; } } }, generateData: function (frameRate, data) { if (this.game === null || this.target === null) { return null; } if (frameRate === undefined) { frameRate = 60; } if (data === undefined) { data = []; } for (var i = 0; i < this.timeline.length; i++) { for (var property in this.timeline[i].vEnd) { this.properties[property] = this.target[property] || 0; if (!Array.isArray(this.properties[property])) { this.properties[property] *= 1.0; } } } for (var i = 0; i < this.timeline.length; i++) { this.timeline[i].loadValues(); } for (var i = 0; i < this.timeline.length; i++) { data = data.concat(this.timeline[i].generateData(frameRate)); } return data; } }; Object.defineProperty(Phaser.Tween.prototype, 'totalDuration', { get: function () { var total = 0; for (var i = 0; i < this.timeline.length; i++) { total += this.timeline[i].duration; } return total; } }); Phaser.Tween.prototype.constructor = Phaser.Tween; Phaser.TweenData = function (parent) { this.parent = parent; this.game = parent.game; this.vStart = {}; this.vStartCache = {}; this.vEnd = {}; this.vEndCache = {}; this.duration = 1000; this.percent = 0; this.value = 0; this.repeatCounter = 0; this.repeatDelay = 0; this.repeatTotal = 0; this.interpolate = false; this.yoyo = false; this.yoyoDelay = 0; this.inReverse = false; this.delay = 0; this.dt = 0; this.startTime = null; this.easingFunction = Phaser.Easing.Default; this.interpolationFunction = Phaser.Math.linearInterpolation; this.interpolationContext = Phaser.Math; this.isRunning = false; this.isFrom = false; }; Phaser.TweenData.PENDING = 0; Phaser.TweenData.RUNNING = 1; Phaser.TweenData.LOOPED = 2; Phaser.TweenData.COMPLETE = 3; Phaser.TweenData.prototype = { to: function (properties, duration, ease, delay, repeat, yoyo) { this.vEnd = properties; this.duration = duration; this.easingFunction = ease; this.delay = delay; this.repeatTotal = repeat; this.yoyo = yoyo; this.isFrom = false; return this; }, from: function (properties, duration, ease, delay, repeat, yoyo) { this.vEnd = properties; this.duration = duration; this.easingFunction = ease; this.delay = delay; this.repeatTotal = repeat; this.yoyo = yoyo; this.isFrom = true; return this; }, start: function () { this.startTime = this.game.time.time + this.delay; if (this.parent.reverse) { this.dt = this.duration; } else { this.dt = 0; } if (this.delay > 0) { this.isRunning = false; } else { this.isRunning = true; } if (this.isFrom) { for (var property in this.vStartCache) { this.vStart[property] = this.vEndCache[property]; this.vEnd[property] = this.vStartCache[property]; this.parent.target[property] = this.vStart[property]; } } this.value = 0; this.yoyoCounter = 0; this.repeatCounter = this.repeatTotal; return this; }, loadValues: function () { for (var property in this.parent.properties) { this.vStart[property] = this.parent.properties[property]; if (Array.isArray(this.vEnd[property])) { if (this.vEnd[property].length === 0) { continue; } if (this.percent === 0) { this.vEnd[property] = [this.vStart[property]].concat(this.vEnd[property]); } } if (typeof this.vEnd[property] !== 'undefined') { if (typeof this.vEnd[property] === 'string') { this.vEnd[property] = this.vStart[property] + parseFloat(this.vEnd[property], 10); } this.parent.properties[property] = this.vEnd[property]; } else { this.vEnd[property] = this.vStart[property]; } this.vStartCache[property] = this.vStart[property]; this.vEndCache[property] = this.vEnd[property]; } return this; }, update: function (time) { if (!this.isRunning) { if (time >= this.startTime) { this.isRunning = true; } else { return Phaser.TweenData.PENDING; } } else { if (time < this.startTime) { return Phaser.TweenData.RUNNING; } } var ms = (this.parent.frameBased) ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS; if (this.parent.reverse) { this.dt -= ms * this.parent.timeScale; this.dt = Math.max(this.dt, 0); } else { this.dt += ms * this.parent.timeScale; this.dt = Math.min(this.dt, this.duration); } this.percent = this.dt / this.duration; this.value = this.easingFunction(this.percent); for (var property in this.vEnd) { var start = this.vStart[property]; var end = this.vEnd[property]; if (Array.isArray(end)) { this.parent.target[property] = this.interpolationFunction.call(this.interpolationContext, end, this.value); } else { this.parent.target[property] = start + ((end - start) * this.value); } } if ((!this.parent.reverse && this.percent === 1) || (this.parent.reverse && this.percent === 0)) { return this.repeat(); } return Phaser.TweenData.RUNNING; }, generateData: function (frameRate) { if (this.parent.reverse) { this.dt = this.duration; } else { this.dt = 0; } var data = []; var complete = false; var fps = (1 / frameRate) * 1000; do { if (this.parent.reverse) { this.dt -= fps; this.dt = Math.max(this.dt, 0); } else { this.dt += fps; this.dt = Math.min(this.dt, this.duration); } this.percent = this.dt / this.duration; this.value = this.easingFunction(this.percent); var blob = {}; for (var property in this.vEnd) { var start = this.vStart[property]; var end = this.vEnd[property]; if (Array.isArray(end)) { blob[property] = this.interpolationFunction(end, this.value); } else { blob[property] = start + ((end - start) * this.value); } } data.push(blob); if ((!this.parent.reverse && this.percent === 1) || (this.parent.reverse && this.percent === 0)) { complete = true; } } while (!complete); if (this.yoyo) { var reversed = data.slice(); reversed.reverse(); data = data.concat(reversed); } return data; }, repeat: function () { if (this.yoyo) { if (this.inReverse && this.repeatCounter === 0) { for (var property in this.vStartCache) { this.vStart[property] = this.vStartCache[property]; this.vEnd[property] = this.vEndCache[property]; } this.inReverse = false; return Phaser.TweenData.COMPLETE; } this.inReverse = !this.inReverse; } else { if (this.repeatCounter === 0) { return Phaser.TweenData.COMPLETE; } } if (this.inReverse) { for (var property in this.vStartCache) { this.vStart[property] = this.vEndCache[property]; this.vEnd[property] = this.vStartCache[property]; } } else { for (var property in this.vStartCache) { this.vStart[property] = this.vStartCache[property]; this.vEnd[property] = this.vEndCache[property]; } if (this.repeatCounter > 0) { this.repeatCounter--; } } this.startTime = this.game.time.time; if (this.yoyo && this.inReverse) { this.startTime += this.yoyoDelay; } else if (!this.inReverse) { this.startTime += this.repeatDelay; } if (this.parent.reverse) { this.dt = this.duration; } else { this.dt = 0; } return Phaser.TweenData.LOOPED; } }; Phaser.TweenData.prototype.constructor = Phaser.TweenData; Phaser.Easing = { Linear: { None: function ( k ) { return k; } }, Quadratic: { In: function ( k ) { return k * k; }, Out: function ( k ) { return k * ( 2 - k ); }, InOut: function ( k ) { if ( ( k *= 2 ) < 1 ) return 0.5 * k * k; return - 0.5 * ( --k * ( k - 2 ) - 1 ); } }, Cubic: { In: function ( k ) { return k * k * k; }, Out: function ( k ) { return --k * k * k + 1; }, InOut: function ( k ) { if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k; return 0.5 * ( ( k -= 2 ) * k * k + 2 ); } }, Quartic: { In: function ( k ) { return k * k * k * k; }, Out: function ( k ) { return 1 - ( --k * k * k * k ); }, InOut: function ( k ) { if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k; return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 ); } }, Quintic: { In: function ( k ) { return k * k * k * k * k; }, Out: function ( k ) { return --k * k * k * k * k + 1; }, InOut: function ( k ) { if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k; return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 ); } }, Sinusoidal: { In: function ( k ) { if (k === 0) return 0; if (k === 1) return 1; return 1 - Math.cos( k * Math.PI / 2 ); }, Out: function ( k ) { if (k === 0) return 0; if (k === 1) return 1; return Math.sin( k * Math.PI / 2 ); }, InOut: function ( k ) { if (k === 0) return 0; if (k === 1) return 1; return 0.5 * ( 1 - Math.cos( Math.PI * k ) ); } }, Exponential: { In: function ( k ) { return k === 0 ? 0 : Math.pow( 1024, k - 1 ); }, Out: function ( k ) { return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k ); }, InOut: function ( k ) { if ( k === 0 ) return 0; if ( k === 1 ) return 1; if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 ); return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 ); } }, Circular: { In: function ( k ) { return 1 - Math.sqrt( 1 - k * k ); }, Out: function ( k ) { return Math.sqrt( 1 - ( --k * k ) ); }, InOut: function ( k ) { if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1); return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1); } }, Elastic: { In: function ( k ) { var s, a = 0.1, p = 0.4; if ( k === 0 ) return 0; if ( k === 1 ) return 1; if ( !a || a < 1 ) { a = 1; s = p / 4; } else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI ); return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) ); }, Out: function ( k ) { var s, a = 0.1, p = 0.4; if ( k === 0 ) return 0; if ( k === 1 ) return 1; if ( !a || a < 1 ) { a = 1; s = p / 4; } else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI ); return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 ); }, InOut: function ( k ) { var s, a = 0.1, p = 0.4; if ( k === 0 ) return 0; if ( k === 1 ) return 1; if ( !a || a < 1 ) { a = 1; s = p / 4; } else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI ); if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) ); return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1; } }, Back: { In: function ( k ) { var s = 1.70158; return k * k * ( ( s + 1 ) * k - s ); }, Out: function ( k ) { var s = 1.70158; return --k * k * ( ( s + 1 ) * k + s ) + 1; }, InOut: function ( k ) { var s = 1.70158 * 1.525; if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) ); return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 ); } }, Bounce: { In: function ( k ) { return 1 - Phaser.Easing.Bounce.Out( 1 - k ); }, Out: function ( k ) { if ( k < ( 1 / 2.75 ) ) { return 7.5625 * k * k; } else if ( k < ( 2 / 2.75 ) ) { return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75; } else if ( k < ( 2.5 / 2.75 ) ) { return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375; } else { return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375; } }, InOut: function ( k ) { if ( k < 0.5 ) return Phaser.Easing.Bounce.In( k * 2 ) * 0.5; return Phaser.Easing.Bounce.Out( k * 2 - 1 ) * 0.5 + 0.5; } } }; Phaser.Easing.Default = Phaser.Easing.Linear.None; Phaser.Easing.Power0 = Phaser.Easing.Linear.None; Phaser.Easing.Power1 = Phaser.Easing.Quadratic.Out; Phaser.Easing.Power2 = Phaser.Easing.Cubic.Out; Phaser.Easing.Power3 = Phaser.Easing.Quartic.Out; Phaser.Easing.Power4 = Phaser.Easing.Quintic.Out; Phaser.Time = function (game) { this.game = game; this.time = 0; this.prevTime = 0; this.now = 0; this.elapsed = 0; this.elapsedMS = 0; this.physicsElapsed = 1 / 60; this.physicsElapsedMS = (1 / 60) * 1000; this.desiredFpsMult = 1.0 / 60; this._desiredFps = 60; this.suggestedFps = this.desiredFps; this.slowMotion = 1.0; this.advancedTiming = false; this.frames = 0; this.fps = 0; this.fpsMin = 1000; this.fpsMax = 0; this.msMin = 1000; this.msMax = 0; this.pauseDuration = 0; this.timeToCall = 0; this.timeExpected = 0; this.events = new Phaser.Timer(this.game, false); this._frameCount = 0; this._elapsedAccumulator = 0; this._started = 0; this._timeLastSecond = 0; this._pauseStarted = 0; this._justResumed = false; this._timers = []; }; Phaser.Time.prototype = { boot: function () { this._started = Date.now(); this.time = Date.now(); this.events.start(); this.timeExpected = this.time; }, add: function (timer) { this._timers.push(timer); return timer; }, create: function (autoDestroy) { if (autoDestroy === undefined) { autoDestroy = true; } var timer = new Phaser.Timer(this.game, autoDestroy); this._timers.push(timer); return timer; }, removeAll: function () { for (var i = 0; i < this._timers.length; i++) { this._timers[i].destroy(); } this._timers = []; this.events.removeAll(); }, refresh: function () { var previousDateNow = this.time; this.time = Date.now(); this.elapsedMS = this.time - previousDateNow; }, update: function (time) { var previousDateNow = this.time; this.time = Date.now(); this.elapsedMS = this.time - previousDateNow; this.prevTime = this.now; this.now = time; this.elapsed = this.now - this.prevTime; if (this.game.raf._isSetTimeOut) { this.timeToCall = Math.floor(Math.max(0, (1000.0 / this._desiredFps) - (this.timeExpected - time))); this.timeExpected = time + this.timeToCall; } if (this.advancedTiming) { this.updateAdvancedTiming(); } if (!this.game.paused) { this.events.update(this.time); if (this._timers.length) { this.updateTimers(); } } }, updateTimers: function () { var i = 0; var len = this._timers.length; while (i < len) { if (this._timers[i].update(this.time)) { i++; } else { this._timers.splice(i, 1); len--; } } }, updateAdvancedTiming: function () { this._frameCount++; this._elapsedAccumulator += this.elapsed; if (this._frameCount >= this._desiredFps * 2) { this.suggestedFps = Math.floor(200 / (this._elapsedAccumulator / this._frameCount)) * 5; this._frameCount = 0; this._elapsedAccumulator = 0; } this.msMin = Math.min(this.msMin, this.elapsed); this.msMax = Math.max(this.msMax, this.elapsed); this.frames++; if (this.now > this._timeLastSecond + 1000) { this.fps = Math.round((this.frames * 1000) / (this.now - this._timeLastSecond)); this.fpsMin = Math.min(this.fpsMin, this.fps); this.fpsMax = Math.max(this.fpsMax, this.fps); this._timeLastSecond = this.now; this.frames = 0; } }, gamePaused: function () { this._pauseStarted = Date.now(); this.events.pause(); var i = this._timers.length; while (i--) { this._timers[i]._pause(); } }, gameResumed: function () { this.time = Date.now(); this.pauseDuration = this.time - this._pauseStarted; this.events.resume(); var i = this._timers.length; while (i--) { this._timers[i]._resume(); } }, totalElapsedSeconds: function() { return (this.time - this._started) * 0.001; }, elapsedSince: function (since) { return this.time - since; }, elapsedSecondsSince: function (since) { return (this.time - since) * 0.001; }, reset: function () { this._started = this.time; this.removeAll(); } }; Object.defineProperty(Phaser.Time.prototype, "desiredFps", { get: function () { return this._desiredFps; }, set: function (value) { this._desiredFps = value; this.physicsElapsed = 1 / value; this.physicsElapsedMS = this.physicsElapsed * 1000; this.desiredFpsMult = 1.0 / value; } }); Phaser.Time.prototype.constructor = Phaser.Time; Phaser.Timer = function (game, autoDestroy) { if (autoDestroy === undefined) { autoDestroy = true; } this.game = game; this.running = false; this.autoDestroy = autoDestroy; this.expired = false; this.elapsed = 0; this.events = []; this.onComplete = new Phaser.Signal(); this.nextTick = 0; this.timeCap = 1000; this.paused = false; this._codePaused = false; this._started = 0; this._pauseStarted = 0; this._pauseTotal = 0; this._now = Date.now(); this._len = 0; this._marked = 0; this._i = 0; this._diff = 0; this._newTick = 0; }; Phaser.Timer.MINUTE = 60000; Phaser.Timer.SECOND = 1000; Phaser.Timer.HALF = 500; Phaser.Timer.QUARTER = 250; Phaser.Timer.prototype = { create: function (delay, loop, repeatCount, callback, callbackContext, args) { delay = Math.round(delay); var tick = delay; if (this._now === 0) { tick += this.game.time.time; } else { tick += this._now; } var event = new Phaser.TimerEvent(this, delay, tick, repeatCount, loop, callback, callbackContext, args); this.events.push(event); this.order(); this.expired = false; return event; }, add: function (delay, callback, callbackContext) { return this.create(delay, false, 0, callback, callbackContext, Array.prototype.slice.call(arguments, 3)); }, repeat: function (delay, repeatCount, callback, callbackContext) { return this.create(delay, false, repeatCount, callback, callbackContext, Array.prototype.slice.call(arguments, 4)); }, loop: function (delay, callback, callbackContext) { return this.create(delay, true, 0, callback, callbackContext, Array.prototype.slice.call(arguments, 3)); }, start: function (delay) { if (this.running) { return; } this._started = this.game.time.time + (delay || 0); this.running = true; for (var i = 0; i < this.events.length; i++) { this.events[i].tick = this.events[i].delay + this._started; } }, stop: function (clearEvents) { this.running = false; if (clearEvents === undefined) { clearEvents = true; } if (clearEvents) { this.events.length = 0; } }, remove: function (event) { for (var i = 0; i < this.events.length; i++) { if (this.events[i] === event) { this.events[i].pendingDelete = true; return true; } } return false; }, order: function () { if (this.events.length > 0) { this.events.sort(this.sortHandler); this.nextTick = this.events[0].tick; } }, sortHandler: function (a, b) { if (a.tick < b.tick) { return -1; } else if (a.tick > b.tick) { return 1; } return 0; }, clearPendingEvents: function () { this._i = this.events.length; while (this._i--) { if (this.events[this._i].pendingDelete) { this.events.splice(this._i, 1); } } this._len = this.events.length; this._i = 0; }, update: function (time) { if (this.paused) { return true; } this.elapsed = time - this._now; this._now = time; if (this.elapsed > this.timeCap) { this.adjustEvents(time - this.elapsed); } this._marked = 0; this.clearPendingEvents(); if (this.running && this._now >= this.nextTick && this._len > 0) { while (this._i < this._len && this.running) { if (this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete) { this._newTick = (this._now + this.events[this._i].delay) - (this._now - this.events[this._i].tick); if (this._newTick < 0) { this._newTick = this._now + this.events[this._i].delay; } if (this.events[this._i].loop === true) { this.events[this._i].tick = this._newTick; this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args); } else if (this.events[this._i].repeatCount > 0) { this.events[this._i].repeatCount--; this.events[this._i].tick = this._newTick; this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args); } else { this._marked++; this.events[this._i].pendingDelete = true; this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args); } this._i++; } else { break; } } if (this.events.length > this._marked) { this.order(); } else { this.expired = true; this.onComplete.dispatch(this); } } if (this.expired && this.autoDestroy) { return false; } else { return true; } }, pause: function () { if (!this.running) { return; } this._codePaused = true; if (this.paused) { return; } this._pauseStarted = this.game.time.time; this.paused = true; }, _pause: function () { if (this.paused || !this.running) { return; } this._pauseStarted = this.game.time.time; this.paused = true; }, adjustEvents: function (baseTime) { for (var i = 0; i < this.events.length; i++) { if (!this.events[i].pendingDelete) { var t = this.events[i].tick - baseTime; if (t < 0) { t = 0; } this.events[i].tick = this._now + t; } } var d = this.nextTick - baseTime; if (d < 0) { this.nextTick = this._now; } else { this.nextTick = this._now + d; } }, resume: function () { if (!this.paused) { return; } var now = this.game.time.time; this._pauseTotal += now - this._now; this._now = now; this.adjustEvents(this._pauseStarted); this.paused = false; this._codePaused = false; }, _resume: function () { if (this._codePaused) { return; } else { this.resume(); } }, removeAll: function () { this.onComplete.removeAll(); this.events.length = 0; this._len = 0; this._i = 0; }, destroy: function () { this.onComplete.removeAll(); this.running = false; this.events = []; this._len = 0; this._i = 0; } }; Object.defineProperty(Phaser.Timer.prototype, "next", { get: function () { return this.nextTick; } }); Object.defineProperty(Phaser.Timer.prototype, "duration", { get: function () { if (this.running && this.nextTick > this._now) { return this.nextTick - this._now; } else { return 0; } } }); Object.defineProperty(Phaser.Timer.prototype, "length", { get: function () { return this.events.length; } }); Object.defineProperty(Phaser.Timer.prototype, "ms", { get: function () { if (this.running) { return this._now - this._started - this._pauseTotal; } else { return 0; } } }); Object.defineProperty(Phaser.Timer.prototype, "seconds", { get: function () { if (this.running) { return this.ms * 0.001; } else { return 0; } } }); Phaser.Timer.prototype.constructor = Phaser.Timer; Phaser.TimerEvent = function (timer, delay, tick, repeatCount, loop, callback, callbackContext, args) { this.timer = timer; this.delay = delay; this.tick = tick; this.repeatCount = repeatCount - 1; this.loop = loop; this.callback = callback; this.callbackContext = callbackContext; this.args = args; this.pendingDelete = false; }; Phaser.TimerEvent.prototype.constructor = Phaser.TimerEvent; Phaser.AnimationManager = function (sprite) { this.sprite = sprite; this.game = sprite.game; this.currentFrame = null; this.currentAnim = null; this.updateIfVisible = true; this.isLoaded = false; this._frameData = null; this._anims = {}; this._outputFrames = []; }; Phaser.AnimationManager.prototype = { loadFrameData: function (frameData, frame) { if (frameData === undefined) { return false; } if (this.isLoaded) { for (var anim in this._anims) { this._anims[anim].updateFrameData(frameData); } } this._frameData = frameData; if (frame === undefined || frame === null) { this.frame = 0; } else { if (typeof frame === 'string') { this.frameName = frame; } else { this.frame = frame; } } this.isLoaded = true; return true; }, copyFrameData: function (frameData, frame) { this._frameData = frameData.clone(); if (this.isLoaded) { for (var anim in this._anims) { this._anims[anim].updateFrameData(this._frameData); } } if (frame === undefined || frame === null) { this.frame = 0; } else { if (typeof frame === 'string') { this.frameName = frame; } else { this.frame = frame; } } this.isLoaded = true; return true; }, add: function (name, frames, frameRate, loop, useNumericIndex) { frames = frames || []; frameRate = frameRate || 60; if (loop === undefined) { loop = false; } if (useNumericIndex === undefined) { if (frames && typeof frames[0] === 'number') { useNumericIndex = true; } else { useNumericIndex = false; } } this._outputFrames = []; this._frameData.getFrameIndexes(frames, useNumericIndex, this._outputFrames); this._anims[name] = new Phaser.Animation(this.game, this.sprite, name, this._frameData, this._outputFrames, frameRate, loop); this.currentAnim = this._anims[name]; if (this.sprite.tilingTexture) { this.sprite.refreshTexture = true; } return this._anims[name]; }, validateFrames: function (frames, useNumericIndex) { if (useNumericIndex === undefined) { useNumericIndex = true; } for (var i = 0; i < frames.length; i++) { if (useNumericIndex === true) { if (frames[i] > this._frameData.total) { return false; } } else { if (this._frameData.checkFrameName(frames[i]) === false) { return false; } } } return true; }, play: function (name, frameRate, loop, killOnComplete) { if (this._anims[name]) { if (this.currentAnim === this._anims[name]) { if (this.currentAnim.isPlaying === false) { this.currentAnim.paused = false; return this.currentAnim.play(frameRate, loop, killOnComplete); } return this.currentAnim; } else { if (this.currentAnim && this.currentAnim.isPlaying) { this.currentAnim.stop(); } this.currentAnim = this._anims[name]; this.currentAnim.paused = false; this.currentFrame = this.currentAnim.currentFrame; return this.currentAnim.play(frameRate, loop, killOnComplete); } } }, stop: function (name, resetFrame) { if (resetFrame === undefined) { resetFrame = false; } if (this.currentAnim && (typeof name !== 'string' || name === this.currentAnim.name)) { this.currentAnim.stop(resetFrame); } }, update: function () { if (this.updateIfVisible && !this.sprite.visible) { return false; } if (this.currentAnim && this.currentAnim.update()) { this.currentFrame = this.currentAnim.currentFrame; return true; } return false; }, next: function (quantity) { if (this.currentAnim) { this.currentAnim.next(quantity); this.currentFrame = this.currentAnim.currentFrame; } }, previous: function (quantity) { if (this.currentAnim) { this.currentAnim.previous(quantity); this.currentFrame = this.currentAnim.currentFrame; } }, getAnimation: function (name) { if (typeof name === 'string') { if (this._anims[name]) { return this._anims[name]; } } return null; }, refreshFrame: function () { }, destroy: function () { var anim = null; for (var anim in this._anims) { if (this._anims.hasOwnProperty(anim)) { this._anims[anim].destroy(); } } this._anims = {}; this._outputFrames = []; this._frameData = null; this.currentAnim = null; this.currentFrame = null; this.sprite = null; this.game = null; } }; Phaser.AnimationManager.prototype.constructor = Phaser.AnimationManager; Object.defineProperty(Phaser.AnimationManager.prototype, 'frameData', { get: function () { return this._frameData; } }); Object.defineProperty(Phaser.AnimationManager.prototype, 'frameTotal', { get: function () { return this._frameData.total; } }); Object.defineProperty(Phaser.AnimationManager.prototype, 'paused', { get: function () { return this.currentAnim.isPaused; }, set: function (value) { this.currentAnim.paused = value; } }); Object.defineProperty(Phaser.AnimationManager.prototype, 'name', { get: function () { if (this.currentAnim) { return this.currentAnim.name; } } }); Object.defineProperty(Phaser.AnimationManager.prototype, 'frame', { get: function () { if (this.currentFrame) { return this.currentFrame.index; } }, set: function (value) { if (typeof value === 'number' && this._frameData && this._frameData.getFrame(value) !== null) { this.currentFrame = this._frameData.getFrame(value); if (this.currentFrame) { this.sprite.setFrame(this.currentFrame); } } } }); Object.defineProperty(Phaser.AnimationManager.prototype, 'frameName', { get: function () { if (this.currentFrame) { return this.currentFrame.name; } }, set: function (value) { if (typeof value === 'string' && this._frameData && this._frameData.getFrameByName(value) !== null) { this.currentFrame = this._frameData.getFrameByName(value); if (this.currentFrame) { this._frameIndex = this.currentFrame.index; this.sprite.setFrame(this.currentFrame); } } else { console.warn('Cannot set frameName: ' + value); } } }); Phaser.Animation = function (game, parent, name, frameData, frames, frameRate, loop) { if (loop === undefined) { loop = false; } this.game = game; this._parent = parent; this._frameData = frameData; this.name = name; this._frames = []; this._frames = this._frames.concat(frames); this.delay = 1000 / frameRate; this.loop = loop; this.loopCount = 0; this.killOnComplete = false; this.isFinished = false; this.isPlaying = false; this.isPaused = false; this._pauseStartTime = 0; this._frameIndex = 0; this._frameDiff = 0; this._frameSkip = 1; this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]); this.onStart = new Phaser.Signal(); this.onUpdate = null; this.onComplete = new Phaser.Signal(); this.onLoop = new Phaser.Signal(); this.isReversed = false; this.game.onPause.add(this.onPause, this); this.game.onResume.add(this.onResume, this); }; Phaser.Animation.prototype = { play: function (frameRate, loop, killOnComplete) { if (typeof frameRate === 'number') { this.delay = 1000 / frameRate; } if (typeof loop === 'boolean') { this.loop = loop; } if (typeof killOnComplete !== 'undefined') { this.killOnComplete = killOnComplete; } this.isPlaying = true; this.isFinished = false; this.paused = false; this.loopCount = 0; this._timeLastFrame = this.game.time.time; this._timeNextFrame = this.game.time.time + this.delay; this._frameIndex = this.isReversed ? this._frames.length - 1 : 0; this.updateCurrentFrame(false, true); this._parent.events.onAnimationStart$dispatch(this._parent, this); this.onStart.dispatch(this._parent, this); this._parent.animations.currentAnim = this; this._parent.animations.currentFrame = this.currentFrame; return this; }, restart: function () { this.isPlaying = true; this.isFinished = false; this.paused = false; this.loopCount = 0; this._timeLastFrame = this.game.time.time; this._timeNextFrame = this.game.time.time + this.delay; this._frameIndex = 0; this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]); this._parent.setFrame(this.currentFrame); this._parent.animations.currentAnim = this; this._parent.animations.currentFrame = this.currentFrame; this.onStart.dispatch(this._parent, this); }, reverse: function () { this.reversed = !this.reversed; return this; }, reverseOnce: function () { this.onComplete.addOnce(this.reverse, this); return this.reverse(); }, setFrame: function(frameId, useLocalFrameIndex) { var frameIndex; if (useLocalFrameIndex === undefined) { useLocalFrameIndex = false; } if (typeof frameId === "string") { for (var i = 0; i < this._frames.length; i++) { if (this._frameData.getFrame(this._frames[i]).name === frameId) { frameIndex = i; } } } else if (typeof frameId === "number") { if (useLocalFrameIndex) { frameIndex = frameId; } else { for (var i = 0; i < this._frames.length; i++) { if (this._frames[i] === frameId) { frameIndex = i; } } } } if (frameIndex) { this._frameIndex = frameIndex - 1; this._timeNextFrame = this.game.time.time; this.update(); } }, stop: function (resetFrame, dispatchComplete) { if (resetFrame === undefined) { resetFrame = false; } if (dispatchComplete === undefined) { dispatchComplete = false; } this.isPlaying = false; this.isFinished = true; this.paused = false; if (resetFrame) { this.currentFrame = this._frameData.getFrame(this._frames[0]); this._parent.setFrame(this.currentFrame); } if (dispatchComplete) { this._parent.events.onAnimationComplete$dispatch(this._parent, this); this.onComplete.dispatch(this._parent, this); } }, onPause: function () { if (this.isPlaying) { this._frameDiff = this._timeNextFrame - this.game.time.time; } }, onResume: function () { if (this.isPlaying) { this._timeNextFrame = this.game.time.time + this._frameDiff; } }, update: function () { if (this.isPaused) { return false; } if (this.isPlaying && this.game.time.time >= this._timeNextFrame) { this._frameSkip = 1; this._frameDiff = this.game.time.time - this._timeNextFrame; this._timeLastFrame = this.game.time.time; if (this._frameDiff > this.delay) { this._frameSkip = Math.floor(this._frameDiff / this.delay); this._frameDiff -= (this._frameSkip * this.delay); } this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff); if (this.isReversed) { this._frameIndex -= this._frameSkip; } else { this._frameIndex += this._frameSkip; } if (!this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1) { if (this.loop) { this._frameIndex = Math.abs(this._frameIndex) % this._frames.length; if (this.isReversed) { this._frameIndex = this._frames.length - 1 - this._frameIndex; } this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]); if (this.currentFrame) { this._parent.setFrame(this.currentFrame); } this.loopCount++; this._parent.events.onAnimationLoop$dispatch(this._parent, this); this.onLoop.dispatch(this._parent, this); if (this.onUpdate) { this.onUpdate.dispatch(this, this.currentFrame); return !!this._frameData; } else { return true; } } else { this.complete(); return false; } } else { return this.updateCurrentFrame(true); } } return false; }, updateCurrentFrame: function (signalUpdate, fromPlay) { if (fromPlay === undefined) { fromPlay = false; } if (!this._frameData) { return false; } var idx = this.currentFrame.index; this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]); if (this.currentFrame && (fromPlay || (!fromPlay && idx !== this.currentFrame.index))) { this._parent.setFrame(this.currentFrame); } if (this.onUpdate && signalUpdate) { this.onUpdate.dispatch(this, this.currentFrame); return !!this._frameData; } else { return true; } }, next: function (quantity) { if (quantity === undefined) { quantity = 1; } var frame = this._frameIndex + quantity; if (frame >= this._frames.length) { if (this.loop) { frame %= this._frames.length; } else { frame = this._frames.length - 1; } } if (frame !== this._frameIndex) { this._frameIndex = frame; this.updateCurrentFrame(true); } }, previous: function (quantity) { if (quantity === undefined) { quantity = 1; } var frame = this._frameIndex - quantity; if (frame < 0) { if (this.loop) { frame = this._frames.length + frame; } else { frame++; } } if (frame !== this._frameIndex) { this._frameIndex = frame; this.updateCurrentFrame(true); } }, updateFrameData: function (frameData) { this._frameData = frameData; this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null; }, destroy: function () { if (!this._frameData) { return; } this.game.onPause.remove(this.onPause, this); this.game.onResume.remove(this.onResume, this); this.game = null; this._parent = null; this._frames = null; this._frameData = null; this.currentFrame = null; this.isPlaying = false; this.onStart.dispose(); this.onLoop.dispose(); this.onComplete.dispose(); if (this.onUpdate) { this.onUpdate.dispose(); } }, complete: function () { this._frameIndex = this._frames.length - 1; this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]); this.isPlaying = false; this.isFinished = true; this.paused = false; this._parent.events.onAnimationComplete$dispatch(this._parent, this); this.onComplete.dispatch(this._parent, this); if (this.killOnComplete) { this._parent.kill(); } } }; Phaser.Animation.prototype.constructor = Phaser.Animation; Object.defineProperty(Phaser.Animation.prototype, 'paused', { get: function () { return this.isPaused; }, set: function (value) { this.isPaused = value; if (value) { this._pauseStartTime = this.game.time.time; } else { if (this.isPlaying) { this._timeNextFrame = this.game.time.time + this.delay; } } } }); Object.defineProperty(Phaser.Animation.prototype, 'reversed', { get: function () { return this.isReversed; }, set: function (value) { this.isReversed = value; } }); Object.defineProperty(Phaser.Animation.prototype, 'frameTotal', { get: function () { return this._frames.length; } }); Object.defineProperty(Phaser.Animation.prototype, 'frame', { get: function () { if (this.currentFrame !== null) { return this.currentFrame.index; } else { return this._frameIndex; } }, set: function (value) { this.currentFrame = this._frameData.getFrame(this._frames[value]); if (this.currentFrame !== null) { this._frameIndex = value; this._parent.setFrame(this.currentFrame); if (this.onUpdate) { this.onUpdate.dispatch(this, this.currentFrame); } } } }); Object.defineProperty(Phaser.Animation.prototype, 'speed', { get: function () { return 1000 / this.delay; }, set: function (value) { if (value > 0) { this.delay = 1000 / value; } } }); Object.defineProperty(Phaser.Animation.prototype, 'enableUpdate', { get: function () { return (this.onUpdate !== null); }, set: function (value) { if (value && this.onUpdate === null) { this.onUpdate = new Phaser.Signal(); } else if (!value && this.onUpdate !== null) { this.onUpdate.dispose(); this.onUpdate = null; } } }); Phaser.Animation.generateFrameNames = function (prefix, start, stop, suffix, zeroPad) { if (suffix === undefined) { suffix = ''; } var output = []; var frame = ''; if (start < stop) { for (var i = start; i <= stop; i++) { if (typeof zeroPad === 'number') { frame = Phaser.Utils.pad(i.toString(), zeroPad, '0', 1); } else { frame = i.toString(); } frame = prefix + frame + suffix; output.push(frame); } } else { for (var i = start; i >= stop; i--) { if (typeof zeroPad === 'number') { frame = Phaser.Utils.pad(i.toString(), zeroPad, '0', 1); } else { frame = i.toString(); } frame = prefix + frame + suffix; output.push(frame); } } return output; }; Phaser.Frame = function (index, x, y, width, height, name) { this.index = index; this.x = x; this.y = y; this.width = width; this.height = height; this.name = name; this.centerX = Math.floor(width / 2); this.centerY = Math.floor(height / 2); this.distance = Phaser.Math.distance(0, 0, width, height); this.rotated = false; this.rotationDirection = 'cw'; this.trimmed = false; this.sourceSizeW = width; this.sourceSizeH = height; this.spriteSourceSizeX = 0; this.spriteSourceSizeY = 0; this.spriteSourceSizeW = 0; this.spriteSourceSizeH = 0; this.right = this.x + this.width; this.bottom = this.y + this.height; }; Phaser.Frame.prototype = { resize: function (width, height) { this.width = width; this.height = height; this.centerX = Math.floor(width / 2); this.centerY = Math.floor(height / 2); this.distance = Phaser.Math.distance(0, 0, width, height); this.sourceSizeW = width; this.sourceSizeH = height; this.right = this.x + width; this.bottom = this.y + height; }, setTrim: function (trimmed, actualWidth, actualHeight, destX, destY, destWidth, destHeight) { this.trimmed = trimmed; if (trimmed) { this.sourceSizeW = actualWidth; this.sourceSizeH = actualHeight; this.centerX = Math.floor(actualWidth / 2); this.centerY = Math.floor(actualHeight / 2); this.spriteSourceSizeX = destX; this.spriteSourceSizeY = destY; this.spriteSourceSizeW = destWidth; this.spriteSourceSizeH = destHeight; } }, clone: function () { var output = new Phaser.Frame(this.index, this.x, this.y, this.width, this.height, this.name); for (var prop in this) { if (this.hasOwnProperty(prop)) { output[prop] = this[prop]; } } return output; }, getRect: function (out) { if (out === undefined) { out = new Phaser.Rectangle(this.x, this.y, this.width, this.height); } else { out.setTo(this.x, this.y, this.width, this.height); } return out; } }; Phaser.Frame.prototype.constructor = Phaser.Frame; Phaser.FrameData = function () { this._frames = []; this._frameNames = []; }; Phaser.FrameData.prototype = { addFrame: function (frame) { frame.index = this._frames.length; this._frames.push(frame); if (frame.name !== '') { this._frameNames[frame.name] = frame.index; } return frame; }, getFrame: function (index) { if (index >= this._frames.length) { index = 0; } return this._frames[index]; }, getFrameByName: function (name) { if (typeof this._frameNames[name] === 'number') { return this._frames[this._frameNames[name]]; } return null; }, checkFrameName: function (name) { if (this._frameNames[name] == null) { return false; } return true; }, clone: function () { var output = new Phaser.FrameData(); for (var i = 0; i < this._frames.length; i++) { output._frames.push(this._frames[i].clone()); } for (var p in this._frameNames) { if (this._frameNames.hasOwnProperty(p)) { output._frameNames.push(this._frameNames[p]); } } return output; }, getFrameRange: function (start, end, output) { if (output === undefined) { output = []; } for (var i = start; i <= end; i++) { output.push(this._frames[i]); } return output; }, getFrames: function (frames, useNumericIndex, output) { if (useNumericIndex === undefined) { useNumericIndex = true; } if (output === undefined) { output = []; } if (frames === undefined || frames.length === 0) { for (var i = 0; i < this._frames.length; i++) { output.push(this._frames[i]); } } else { for (var i = 0; i < frames.length; i++) { if (useNumericIndex) { output.push(this.getFrame(frames[i])); } else { output.push(this.getFrameByName(frames[i])); } } } return output; }, getFrameIndexes: function (frames, useNumericIndex, output) { if (useNumericIndex === undefined) { useNumericIndex = true; } if (output === undefined) { output = []; } if (frames === undefined || frames.length === 0) { for (var i = 0; i < this._frames.length; i++) { output.push(this._frames[i].index); } } else { for (var i = 0; i < frames.length; i++) { if (useNumericIndex && this._frames[frames[i]]) { output.push(this._frames[frames[i]].index); } else { if (this.getFrameByName(frames[i])) { output.push(this.getFrameByName(frames[i]).index); } } } } return output; }, destroy: function () { this._frames = null; this._frameNames = null; } }; Phaser.FrameData.prototype.constructor = Phaser.FrameData; Object.defineProperty(Phaser.FrameData.prototype, "total", { get: function () { return this._frames.length; } }); Phaser.AnimationParser = { spriteSheet: function (game, key, frameWidth, frameHeight, frameMax, margin, spacing) { var img = key; if (typeof key === 'string') { img = game.cache.getImage(key); } if (img === null) { return null; } var width = img.width; var height = img.height; if (frameWidth <= 0) { frameWidth = Math.floor(-width / Math.min(-1, frameWidth)); } if (frameHeight <= 0) { frameHeight = Math.floor(-height / Math.min(-1, frameHeight)); } var row = Math.floor((width - margin) / (frameWidth + spacing)); var column = Math.floor((height - margin) / (frameHeight + spacing)); var total = row * column; if (frameMax !== -1) { total = frameMax; } if (width === 0 || height === 0 || width < frameWidth || height < frameHeight || total === 0) { console.warn("Phaser.AnimationParser.spriteSheet: '" + key + "'s width/height zero or width/height < given frameWidth/frameHeight"); return null; } var data = new Phaser.FrameData(); var x = margin; var y = margin; for (var i = 0; i < total; i++) { data.addFrame(new Phaser.Frame(i, x, y, frameWidth, frameHeight, '')); x += frameWidth + spacing; if (x + frameWidth > width) { x = margin; y += frameHeight + spacing; } } return data; }, JSONData: function (game, json) { if (!json['frames']) { console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array"); console.log(json); return; } var data = new Phaser.FrameData(); var frames = json['frames']; var newFrame; for (var i = 0; i < frames.length; i++) { newFrame = data.addFrame(new Phaser.Frame( i, frames[i].frame.x, frames[i].frame.y, frames[i].frame.w, frames[i].frame.h, frames[i].filename )); if (frames[i].trimmed) { newFrame.setTrim( frames[i].trimmed, frames[i].sourceSize.w, frames[i].sourceSize.h, frames[i].spriteSourceSize.x, frames[i].spriteSourceSize.y, frames[i].spriteSourceSize.w, frames[i].spriteSourceSize.h ); } } return data; }, JSONDataPyxel: function (game, json) { var signature = ['layers', 'tilewidth','tileheight','tileswide', 'tileshigh']; signature.forEach( function(key) { if (!json[key]) { console.warn('Phaser.AnimationParser.JSONDataPyxel: Invalid Pyxel Tilemap JSON given, missing "' + key + '" key.'); console.log(json); return; } }); if (json['layers'].length !== 1) { console.warn('Phaser.AnimationParser.JSONDataPyxel: Too many layers, this parser only supports flat Tilemaps.'); console.log(json); return; } var data = new Phaser.FrameData(); var tileheight = json['tileheight']; var tilewidth = json['tilewidth']; var frames = json['layers'][0]['tiles']; var newFrame; for (var i = 0; i < frames.length; i++) { newFrame = data.addFrame(new Phaser.Frame( i, frames[i].x, frames[i].y, tilewidth, tileheight, "frame_" + i )); newFrame.setTrim(false); } return data; }, JSONDataHash: function (game, json) { if (!json['frames']) { console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object"); console.log(json); return; } var data = new Phaser.FrameData(); var frames = json['frames']; var newFrame; var i = 0; for (var key in frames) { newFrame = data.addFrame(new Phaser.Frame( i, frames[key].frame.x, frames[key].frame.y, frames[key].frame.w, frames[key].frame.h, key )); if (frames[key].trimmed) { newFrame.setTrim( frames[key].trimmed, frames[key].sourceSize.w, frames[key].sourceSize.h, frames[key].spriteSourceSize.x, frames[key].spriteSourceSize.y, frames[key].spriteSourceSize.w, frames[key].spriteSourceSize.h ); } i++; } return data; }, XMLData: function (game, xml) { if (!xml.getElementsByTagName('TextureAtlas')) { console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag"); return; } var data = new Phaser.FrameData(); var frames = xml.getElementsByTagName('SubTexture'); var newFrame; var name; var frame; var x; var y; var width; var height; var frameX; var frameY; var frameWidth; var frameHeight; for (var i = 0; i < frames.length; i++) { frame = frames[i].attributes; name = frame.name.value; x = parseInt(frame.x.value, 10); y = parseInt(frame.y.value, 10); width = parseInt(frame.width.value, 10); height = parseInt(frame.height.value, 10); frameX = null; frameY = null; if (frame.frameX) { frameX = Math.abs(parseInt(frame.frameX.value, 10)); frameY = Math.abs(parseInt(frame.frameY.value, 10)); frameWidth = parseInt(frame.frameWidth.value, 10); frameHeight = parseInt(frame.frameHeight.value, 10); } newFrame = data.addFrame(new Phaser.Frame(i, x, y, width, height, name)); if (frameX !== null || frameY !== null) { newFrame.setTrim(true, width, height, frameX, frameY, frameWidth, frameHeight); } } return data; } };