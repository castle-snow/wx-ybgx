var PIXI = PIXI || {}; PIXI.game = null; PIXI.WEBGL_RENDERER = 0; PIXI.CANVAS_RENDERER = 1; PIXI.VERSION = "v2.2.9"; PIXI._UID = 0; if (typeof(Float32Array) != 'undefined') { PIXI.Float32Array = Float32Array; PIXI.Uint16Array = Uint16Array; PIXI.Uint32Array = Uint32Array; PIXI.ArrayBuffer = ArrayBuffer; } else { PIXI.Float32Array = Array; PIXI.Uint16Array = Array; } PIXI.PI_2 = Math.PI * 2; PIXI.RAD_TO_DEG = 180 / Math.PI; PIXI.DEG_TO_RAD = Math.PI / 180; PIXI.RETINA_PREFIX = "@2x"; PIXI.DisplayObject = function () { this.position = new PIXI.Point(0, 0); this.scale = new PIXI.Point(1, 1); this.pivot = new PIXI.Point(0, 0); this.rotation = 0; this.alpha = 1; this.visible = true; this.hitArea = null; this.renderable = false; this.parent = null; this.worldAlpha = 1; this.worldTransform = new PIXI.Matrix(); this.worldPosition = new PIXI.Point(0, 0); this.worldScale = new PIXI.Point(1, 1); this.worldRotation = 0; this.filterArea = null; this._sr = 0; this._cr = 1; this._bounds = new PIXI.Rectangle(0, 0, 0, 0); this._currentBounds = null; this._mask = null; this._cacheAsBitmap = false; this._cacheIsDirty = false; }; PIXI.DisplayObject.prototype.constructor = PIXI.DisplayObject; PIXI.DisplayObject.prototype = { destroy: function () { if (this.children) { var i = this.children.length; while (i--) { this.children[i].destroy(); } this.children = []; } this.hitArea = null; this.parent = null; this.worldTransform = null; this.filterArea = null; this.renderable = false; this._bounds = null; this._currentBounds = null; this._mask = null; this._destroyCachedSprite(); }, updateTransform: function (parent) { if (!parent && !this.parent && !this.game) { return this; } var p = this.parent; if (parent) { p = parent; } else if (!this.parent) { p = this.game.world; } var pt = p.worldTransform; var wt = this.worldTransform; var a, b, c, d, tx, ty; if (this.rotation % PIXI.PI_2) { if (this.rotation !== this.rotationCache) { this.rotationCache = this.rotation; this._sr = Math.sin(this.rotation); this._cr = Math.cos(this.rotation); } a  =  this._cr * this.scale.x; b  =  this._sr * this.scale.x; c  = -this._sr * this.scale.y; d  =  this._cr * this.scale.y; tx =  this.position.x; ty =  this.position.y; if (this.pivot.x || this.pivot.y) { tx -= this.pivot.x * a + this.pivot.y * c; ty -= this.pivot.x * b + this.pivot.y * d; } wt.a  = a  * pt.a + b  * pt.c; wt.b  = a  * pt.b + b  * pt.d; wt.c  = c  * pt.a + d  * pt.c; wt.d  = c  * pt.b + d  * pt.d; wt.tx = tx * pt.a + ty * pt.c + pt.tx; wt.ty = tx * pt.b + ty * pt.d + pt.ty; } else { a  = this.scale.x; d  = this.scale.y; tx = this.position.x - this.pivot.x * a; ty = this.position.y - this.pivot.y * d; wt.a  = a  * pt.a; wt.b  = a  * pt.b; wt.c  = d  * pt.c; wt.d  = d  * pt.d; wt.tx = tx * pt.a + ty * pt.c + pt.tx; wt.ty = tx * pt.b + ty * pt.d + pt.ty; } this.worldAlpha = this.alpha * p.worldAlpha; this.worldPosition.set(wt.tx, wt.ty); this.worldScale.set(this.scale.x * Math.sqrt(wt.a * wt.a + wt.c * wt.c), this.scale.y * Math.sqrt(wt.b * wt.b + wt.d * wt.d)); this.worldRotation = Math.atan2(-wt.c, wt.d); this._currentBounds = null; if (this.transformCallback) { this.transformCallback.call(this.transformCallbackContext, wt, pt); } return this; }, preUpdate: function () { }, generateTexture: function (resolution, scaleMode, renderer) { var bounds = this.getLocalBounds(); var renderTexture = new PIXI.RenderTexture(bounds.width | 0, bounds.height | 0, renderer, scaleMode, resolution); PIXI.DisplayObject._tempMatrix.tx = -bounds.x; PIXI.DisplayObject._tempMatrix.ty = -bounds.y; renderTexture.render(this, PIXI.DisplayObject._tempMatrix); return renderTexture; }, updateCache: function () { this._generateCachedSprite(); return this; }, toGlobal: function (position) { this.updateTransform(); return this.worldTransform.apply(position); }, toLocal: function (position, from) { if (from) { position = from.toGlobal(position); } this.updateTransform(); return this.worldTransform.applyInverse(position); }, _renderCachedSprite: function (renderSession) { this._cachedSprite.worldAlpha = this.worldAlpha; if (renderSession.gl) { PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession); } else { PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession); } }, _generateCachedSprite: function () { this._cacheAsBitmap = false; var bounds = this.getLocalBounds(); bounds.width = Math.max(1, Math.ceil(bounds.width)); bounds.height = Math.max(1, Math.ceil(bounds.height)); this.updateTransform(); if (!this._cachedSprite) { var renderTexture = new PIXI.RenderTexture(bounds.width, bounds.height); this._cachedSprite = new PIXI.Sprite(renderTexture); this._cachedSprite.worldTransform = this.worldTransform; } else { this._cachedSprite.texture.resize(bounds.width, bounds.height); } var tempFilters = this._filters; this._filters = null; this._cachedSprite.filters = tempFilters; PIXI.DisplayObject._tempMatrix.tx = -bounds.x; PIXI.DisplayObject._tempMatrix.ty = -bounds.y; this._cachedSprite.texture.render(this, PIXI.DisplayObject._tempMatrix, true); this._cachedSprite.anchor.x = -(bounds.x / bounds.width); this._cachedSprite.anchor.y = -(bounds.y / bounds.height); this._filters = tempFilters; this._cacheAsBitmap = true; }, _destroyCachedSprite: function () { if (!this._cachedSprite) { return; } this._cachedSprite.texture.destroy(true); this._cachedSprite = null; } }; PIXI.DisplayObject.prototype.displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform; Object.defineProperties(PIXI.DisplayObject.prototype, { 'x': { get: function () { return this.position.x; }, set: function (value) { this.position.x = value; } }, 'y': { get: function () { return this.position.y; }, set: function (value) { this.position.y = value; } }, 'worldVisible': { get: function () { if (!this.visible) { return false; } else { var item = this.parent; if (!item) { return this.visible; } else { do { if (!item.visible) { return false; } item = item.parent; } while (item); } return true; } } }, 'mask': { get: function () { return this._mask; }, set: function (value) { if (this._mask) { this._mask.isMask = false; } this._mask = value; if (value) { this._mask.isMask = true; } } }, 'filters': { get: function () { return this._filters; }, set: function (value) { if (Array.isArray(value)) { var passes = []; for (var i = 0; i < value.length; i++) { var filterPasses = value[i].passes; for (var j = 0; j < filterPasses.length; j++) { passes.push(filterPasses[j]); } } this._filterBlock = { target: this, filterPasses: passes }; } this._filters = value; if (this.blendMode && this.blendMode === PIXI.blendModes.MULTIPLY) { this.blendMode = PIXI.blendModes.NORMAL; } } }, 'cacheAsBitmap': { get: function () { return this._cacheAsBitmap; }, set: function (value) { if (this._cacheAsBitmap === value) { return; } if (value) { this._generateCachedSprite(); } else { this._destroyCachedSprite(); } this._cacheAsBitmap = value; } } }); PIXI.DisplayObjectContainer = function () { PIXI.DisplayObject.call(this); this.children = []; this.ignoreChildInput = false; }; PIXI.DisplayObjectContainer.prototype = Object.create( PIXI.DisplayObject.prototype ); PIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer; PIXI.DisplayObjectContainer.prototype.addChild = function (child) { return this.addChildAt(child, this.children.length); }; PIXI.DisplayObjectContainer.prototype.addChildAt = function (child, index) { if (index >= 0 && index <= this.children.length) { if (child.parent) { child.parent.removeChild(child); } child.parent = this; this.children.splice(index, 0, child); return child; } else { throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length); } }; PIXI.DisplayObjectContainer.prototype.swapChildren = function (child, child2) { if (child === child2) { return; } var index1 = this.getChildIndex(child); var index2 = this.getChildIndex(child2); if (index1 < 0 || index2 < 0) { throw new Error('swapChildren: Both the supplied DisplayObjects must be a child of the caller.'); } this.children[index1] = child2; this.children[index2] = child; }; PIXI.DisplayObjectContainer.prototype.getChildIndex = function (child) { var index = this.children.indexOf(child); if (index === -1) { throw new Error('The supplied DisplayObject must be a child of the caller'); } return index; }; PIXI.DisplayObjectContainer.prototype.setChildIndex = function (child, index) { if (index < 0 || index >= this.children.length) { throw new Error('The supplied index is out of bounds'); } var currentIndex = this.getChildIndex(child); this.children.splice(currentIndex, 1); this.children.splice(index, 0, child); }; PIXI.DisplayObjectContainer.prototype.getChildAt = function (index) { if (index < 0 || index >= this.children.length) { throw new Error('getChildAt: Supplied index '+ index +' does not exist in the child list, or the supplied DisplayObject must be a child of the caller'); } return this.children[index]; }; PIXI.DisplayObjectContainer.prototype.removeChild = function (child) { var index = this.children.indexOf(child); if (index === -1) { return; } return this.removeChildAt(index); }; PIXI.DisplayObjectContainer.prototype.removeChildAt = function (index) { var child = this.getChildAt(index); if (child) { child.parent = undefined; this.children.splice(index, 1); } return child; }; PIXI.DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex) { if (beginIndex === undefined) { beginIndex = 0; } if (endIndex === undefined) { endIndex = this.children.length; } var range = endIndex - beginIndex; if (range > 0 && range <= endIndex) { var removed = this.children.splice(begin, range); for (var i = 0; i < removed.length; i++) { var child = removed[i]; child.parent = undefined; } return removed; } else if (range === 0 && this.children.length === 0) { return []; } else { throw new Error( 'removeChildren: Range Error, numeric values are outside the acceptable range' ); } }; PIXI.DisplayObjectContainer.prototype.updateTransform = function () { if (!this.visible) { return; } this.displayObjectUpdateTransform(); if (this._cacheAsBitmap) { return; } for (var i = 0; i < this.children.length; i++) { this.children[i].updateTransform(); } }; PIXI.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = PIXI.DisplayObjectContainer.prototype.updateTransform; PIXI.DisplayObjectContainer.prototype.getBounds = function (targetCoordinateSpace) { var isTargetCoordinateSpaceDisplayObject = (targetCoordinateSpace && targetCoordinateSpace instanceof PIXI.DisplayObject); var isTargetCoordinateSpaceThisOrParent = true; if (!isTargetCoordinateSpaceDisplayObject) { targetCoordinateSpace = this; } else if (targetCoordinateSpace instanceof PIXI.DisplayObjectContainer) { isTargetCoordinateSpaceThisOrParent = targetCoordinateSpace.contains(this); } else { isTargetCoordinateSpaceThisOrParent = false; } var i; if (isTargetCoordinateSpaceDisplayObject) { var matrixCache = targetCoordinateSpace.worldTransform; targetCoordinateSpace.worldTransform = PIXI.identityMatrix; for (i = 0; i < targetCoordinateSpace.children.length; i++) { targetCoordinateSpace.children[i].updateTransform(); } } var minX = Infinity; var minY = Infinity; var maxX = -Infinity; var maxY = -Infinity; var childBounds; var childMaxX; var childMaxY; var childVisible = false; for (i = 0; i < this.children.length; i++) { var child = this.children[i]; if (!child.visible) { continue; } childVisible = true; childBounds = this.children[i].getBounds(); minX = (minX < childBounds.x) ? minX : childBounds.x; minY = (minY < childBounds.y) ? minY : childBounds.y; childMaxX = childBounds.width + childBounds.x; childMaxY = childBounds.height + childBounds.y; maxX = (maxX > childMaxX) ? maxX : childMaxX; maxY = (maxY > childMaxY) ? maxY : childMaxY; } var bounds = this._bounds; if (!childVisible) { bounds = new PIXI.Rectangle(); var w0 = bounds.x; var w1 = bounds.width + bounds.x; var h0 = bounds.y; var h1 = bounds.height + bounds.y; var worldTransform = this.worldTransform; var a = worldTransform.a; var b = worldTransform.b; var c = worldTransform.c; var d = worldTransform.d; var tx = worldTransform.tx; var ty = worldTransform.ty; var x1 = a * w1 + c * h1 + tx; var y1 = d * h1 + b * w1 + ty; var x2 = a * w0 + c * h1 + tx; var y2 = d * h1 + b * w0 + ty; var x3 = a * w0 + c * h0 + tx; var y3 = d * h0 + b * w0 + ty; var x4 = a * w1 + c * h0 + tx; var y4 = d * h0 + b * w1 + ty; maxX = x1; maxY = y1; minX = x1; minY = y1; minX = x2 < minX ? x2 : minX; minX = x3 < minX ? x3 : minX; minX = x4 < minX ? x4 : minX; minY = y2 < minY ? y2 : minY; minY = y3 < minY ? y3 : minY; minY = y4 < minY ? y4 : minY; maxX = x2 > maxX ? x2 : maxX; maxX = x3 > maxX ? x3 : maxX; maxX = x4 > maxX ? x4 : maxX; maxY = y2 > maxY ? y2 : maxY; maxY = y3 > maxY ? y3 : maxY; maxY = y4 > maxY ? y4 : maxY; } bounds.x = minX; bounds.y = minY; bounds.width = maxX - minX; bounds.height = maxY - minY; if (isTargetCoordinateSpaceDisplayObject) { targetCoordinateSpace.worldTransform = matrixCache; for (i = 0; i < targetCoordinateSpace.children.length; i++) { targetCoordinateSpace.children[i].updateTransform(); } } if (!isTargetCoordinateSpaceThisOrParent) { var targetCoordinateSpaceBounds = targetCoordinateSpace.getBounds(); bounds.x -= targetCoordinateSpaceBounds.x; bounds.y -= targetCoordinateSpaceBounds.y; } return bounds; }; PIXI.DisplayObjectContainer.prototype.getLocalBounds = function () { return this.getBounds(this); }; PIXI.DisplayObjectContainer.prototype.contains = function (child) { if (!child) { return false; } else if (child === this) { return true; } else { return this.contains(child.parent); } }; PIXI.DisplayObjectContainer.prototype._renderWebGL = function (renderSession) { if (!this.visible || this.alpha <= 0) { return; } if (this._cacheAsBitmap) { this._renderCachedSprite(renderSession); return; } var i; if (this._mask || this._filters) { if (this._filters) { renderSession.spriteBatch.flush(); renderSession.filterManager.pushFilter(this._filterBlock); } if (this._mask) { renderSession.spriteBatch.stop(); renderSession.maskManager.pushMask(this.mask, renderSession); renderSession.spriteBatch.start(); } for (i = 0; i < this.children.length; i++) { this.children[i]._renderWebGL(renderSession); } renderSession.spriteBatch.stop(); if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession); if (this._filters) renderSession.filterManager.popFilter(); renderSession.spriteBatch.start(); } else { for (i = 0; i < this.children.length; i++) { this.children[i]._renderWebGL(renderSession); } } }; PIXI.DisplayObjectContainer.prototype._renderCanvas = function (renderSession) { if (this.visible === false || this.alpha === 0) { return; } if (this._cacheAsBitmap) { this._renderCachedSprite(renderSession); return; } if (this._mask) { renderSession.maskManager.pushMask(this._mask, renderSession); } for (var i = 0; i < this.children.length; i++) { this.children[i]._renderCanvas(renderSession); } if (this._mask) { renderSession.maskManager.popMask(renderSession); } }; Object.defineProperty(PIXI.DisplayObjectContainer.prototype, 'width', { get: function() { return this.getLocalBounds().width * this.scale.x; }, set: function(value) { var width = this.getLocalBounds().width; if (width !== 0) { this.scale.x = value / width; } else { this.scale.x = 1; } this._width = value; } }); Object.defineProperty(PIXI.DisplayObjectContainer.prototype, 'height', { get: function() { return this.getLocalBounds().height * this.scale.y; }, set: function(value) { var height = this.getLocalBounds().height; if (height !== 0) { this.scale.y = value / height; } else { this.scale.y = 1; } this._height = value; } }); PIXI.Sprite = function (texture) { PIXI.DisplayObjectContainer.call(this); this.anchor = new PIXI.Point(); this.texture = texture || PIXI.Texture.emptyTexture; this._width = 0; this._height = 0; this.tint = 0xFFFFFF; this.cachedTint = -1; this.tintedTexture = null; this.blendMode = PIXI.blendModes.NORMAL; this.shader = null; this.exists = true; if (this.texture.baseTexture.hasLoaded) { this.onTextureUpdate(); } this.renderable = true; }; PIXI.Sprite.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PIXI.Sprite.prototype.constructor = PIXI.Sprite; Object.defineProperty(PIXI.Sprite.prototype, 'width', { get: function() { return this.scale.x * this.texture.frame.width; }, set: function(value) { this.scale.x = value / this.texture.frame.width; this._width = value; } }); Object.defineProperty(PIXI.Sprite.prototype, 'height', { get: function() { return  this.scale.y * this.texture.frame.height; }, set: function(value) { this.scale.y = value / this.texture.frame.height; this._height = value; } }); PIXI.Sprite.prototype.setTexture = function(texture, destroyBase) { if (destroyBase !== undefined) { this.texture.baseTexture.destroy(); } this.texture.baseTexture.skipRender = false; this.texture = texture; this.texture.valid = true; this.cachedTint = -1; }; PIXI.Sprite.prototype.onTextureUpdate = function() { if (this._width) this.scale.x = this._width / this.texture.frame.width; if (this._height) this.scale.y = this._height / this.texture.frame.height; }; PIXI.Sprite.prototype.getBounds = function(matrix) { var width = this.texture.frame.width; var height = this.texture.frame.height; var w0 = width * (1-this.anchor.x); var w1 = width * -this.anchor.x; var h0 = height * (1-this.anchor.y); var h1 = height * -this.anchor.y; var worldTransform = matrix || this.worldTransform; var a = worldTransform.a; var b = worldTransform.b; var c = worldTransform.c; var d = worldTransform.d; var tx = worldTransform.tx; var ty = worldTransform.ty; var maxX = -Infinity; var maxY = -Infinity; var minX = Infinity; var minY = Infinity; if (b === 0 && c === 0) { if (a < 0) { a *= -1; var temp = w0; w0 = -w1; w1 = -temp; } if (d < 0) { d *= -1; var temp = h0; h0 = -h1; h1 = -temp; } minX = a * w1 + tx; maxX = a * w0 + tx; minY = d * h1 + ty; maxY = d * h0 + ty; } else { var x1 = a * w1 + c * h1 + tx; var y1 = d * h1 + b * w1 + ty; var x2 = a * w0 + c * h1 + tx; var y2 = d * h1 + b * w0 + ty; var x3 = a * w0 + c * h0 + tx; var y3 = d * h0 + b * w0 + ty; var x4 =  a * w1 + c * h0 + tx; var y4 =  d * h0 + b * w1 + ty; minX = x1 < minX ? x1 : minX; minX = x2 < minX ? x2 : minX; minX = x3 < minX ? x3 : minX; minX = x4 < minX ? x4 : minX; minY = y1 < minY ? y1 : minY; minY = y2 < minY ? y2 : minY; minY = y3 < minY ? y3 : minY; minY = y4 < minY ? y4 : minY; maxX = x1 > maxX ? x1 : maxX; maxX = x2 > maxX ? x2 : maxX; maxX = x3 > maxX ? x3 : maxX; maxX = x4 > maxX ? x4 : maxX; maxY = y1 > maxY ? y1 : maxY; maxY = y2 > maxY ? y2 : maxY; maxY = y3 > maxY ? y3 : maxY; maxY = y4 > maxY ? y4 : maxY; } var bounds = this._bounds; bounds.x = minX; bounds.width = maxX - minX; bounds.y = minY; bounds.height = maxY - minY; this._currentBounds = bounds; return bounds; }; PIXI.Sprite.prototype.getLocalBounds = function () { var matrixCache = this.worldTransform; this.worldTransform = PIXI.identityMatrix; for (var i = 0; i < this.children.length; i++) { this.children[i].updateTransform(); } var bounds = this.getBounds(); this.worldTransform = matrixCache; for (i = 0; i < this.children.length; i++) { this.children[i].updateTransform(); } return bounds; }; PIXI.Sprite.prototype._renderWebGL = function(renderSession, matrix) { if (!this.visible || this.alpha <= 0 || !this.renderable) return; var wt = this.worldTransform; if (matrix) { wt = matrix; } if (this._mask || this._filters) { var spriteBatch = renderSession.spriteBatch; if (this._filters) { spriteBatch.flush(); renderSession.filterManager.pushFilter(this._filterBlock); } if (this._mask) { spriteBatch.stop(); renderSession.maskManager.pushMask(this.mask, renderSession); spriteBatch.start(); } spriteBatch.render(this); for (var i = 0; i < this.children.length; i++) { this.children[i]._renderWebGL(renderSession); } spriteBatch.stop(); if (this._mask) renderSession.maskManager.popMask(this._mask, renderSession); if (this._filters) renderSession.filterManager.popFilter(); spriteBatch.start(); } else { renderSession.spriteBatch.render(this); for (var i = 0; i < this.children.length; i++) { this.children[i]._renderWebGL(renderSession, wt); } } }; PIXI.Sprite.prototype._renderCanvas = function(renderSession, matrix) { if (!this.visible || this.alpha === 0 || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0) { return; } var wt = this.worldTransform; if (matrix) { wt = matrix; } if (this.blendMode !== renderSession.currentBlendMode) { renderSession.currentBlendMode = this.blendMode; renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode]; } if (this._mask) { renderSession.maskManager.pushMask(this._mask, renderSession); } if (this.texture.valid) { var resolution = this.texture.baseTexture.resolution / renderSession.resolution; renderSession.context.globalAlpha = this.worldAlpha; if (renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode) { renderSession.scaleMode = this.texture.baseTexture.scaleMode; renderSession.context[renderSession.smoothProperty] = (renderSession.scaleMode === PIXI.scaleModes.LINEAR); } var dx = (this.texture.trim) ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width; var dy = (this.texture.trim) ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height; var tx = (wt.tx * renderSession.resolution) + renderSession.shakeX; var ty = (wt.ty * renderSession.resolution) + renderSession.shakeY; if (renderSession.roundPixels) { renderSession.context.setTransform(wt.a, wt.b, wt.c, wt.d, tx | 0, ty | 0); dx |= 0; dy |= 0; } else { renderSession.context.setTransform(wt.a, wt.b, wt.c, wt.d, tx, ty); } var cw = this.texture.crop.width; var ch = this.texture.crop.height; dx /= resolution; dy /= resolution; if (this.tint !== 0xFFFFFF) { if (this.texture.requiresReTint || this.cachedTint !== this.tint) { this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint); this.cachedTint = this.tint; this.texture.requiresReTint = false; } renderSession.context.drawImage(this.tintedTexture, 0, 0, cw, ch, dx, dy, cw / resolution, ch / resolution); } else { var cx = this.texture.crop.x; var cy = this.texture.crop.y; renderSession.context.drawImage(this.texture.baseTexture.source, cx, cy, cw, ch, dx, dy, cw / resolution, ch / resolution); } } for (var i = 0; i < this.children.length; i++) { this.children[i]._renderCanvas(renderSession); } if (this._mask) { renderSession.maskManager.popMask(renderSession); } }; PIXI.SpriteBatch = function(texture) { PIXI.DisplayObjectContainer.call( this); this.textureThing = texture; this.ready = false; }; PIXI.SpriteBatch.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PIXI.SpriteBatch.prototype.constructor = PIXI.SpriteBatch; PIXI.SpriteBatch.prototype.initWebGL = function(gl) { this.fastSpriteBatch = new PIXI.WebGLFastSpriteBatch(gl); this.ready = true; }; PIXI.SpriteBatch.prototype.updateTransform = function() { this.displayObjectUpdateTransform(); }; PIXI.SpriteBatch.prototype._renderWebGL = function(renderSession) { if (!this.visible || this.alpha <= 0 || !this.children.length) return; if (!this.ready) { this.initWebGL(renderSession.gl); } if (this.fastSpriteBatch.gl !== renderSession.gl) { this.fastSpriteBatch.setContext(renderSession.gl); } renderSession.spriteBatch.stop(); renderSession.shaderManager.setShader(renderSession.shaderManager.fastShader); this.fastSpriteBatch.begin(this, renderSession); this.fastSpriteBatch.render(this); renderSession.spriteBatch.start(); }; PIXI.SpriteBatch.prototype._renderCanvas = function(renderSession) { if (!this.visible || this.alpha <= 0 || !this.children.length) return; var context = renderSession.context; context.globalAlpha = this.worldAlpha; this.displayObjectUpdateTransform(); var transform = this.worldTransform; var isRotated = true; for (var i = 0; i < this.children.length; i++) { var child = this.children[i]; if (!child.visible) continue; var texture = child.texture; var frame = texture.frame; context.globalAlpha = this.worldAlpha * child.alpha; if (child.rotation % (Math.PI * 2) === 0) { if (isRotated) { context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty); isRotated = false; } context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x + 0.5 + renderSession.shakeX) | 0, ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y + 0.5 + renderSession.shakeY) | 0, frame.width * child.scale.x, frame.height * child.scale.y); } else { if (!isRotated) isRotated = true; child.displayObjectUpdateTransform(); var childTransform = child.worldTransform; var tx = (childTransform.tx * renderSession.resolution) + renderSession.shakeX; var ty = (childTransform.ty * renderSession.resolution) + renderSession.shakeY; if (renderSession.roundPixels) { context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, tx | 0, ty | 0); } else { context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, tx, ty); } context.drawImage(texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, ((child.anchor.x) * (-frame.width) + 0.5) | 0, ((child.anchor.y) * (-frame.height) + 0.5) | 0, frame.width, frame.height); } } }; PIXI.hex2rgb = function(hex) { return [(hex >> 16 & 0xFF) / 255, ( hex >> 8 & 0xFF) / 255, (hex & 0xFF)/ 255]; }; PIXI.rgb2hex = function(rgb) { return ((rgb[0]*255 << 16) + (rgb[1]*255 << 8) + rgb[2]*255); }; PIXI.canUseNewCanvasBlendModes = function() { if (document === undefined) return false; var pngHead = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/'; var pngEnd = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg=='; var magenta = new Image(); magenta.src = pngHead + 'AP804Oa6' + pngEnd; var yellow = new Image(); yellow.src = pngHead + '/wCKxvRF' + pngEnd; var canvas = PIXI.CanvasPool.create(this, 6, 1); var context = canvas.getContext('2d'); context.globalCompositeOperation = 'multiply'; context.drawImage(magenta, 0, 0); context.drawImage(yellow, 2, 0); if (!context.getImageData(2,0,1,1)) { return false; } var data = context.getImageData(2,0,1,1).data; PIXI.CanvasPool.remove(this); return (data[0] === 255 && data[1] === 0 && data[2] === 0); }; PIXI.getNextPowerOfTwo = function(number) { if (number > 0 && (number & (number - 1)) === 0) return number; else { var result = 1; while (result < number) result <<= 1; return result; } }; PIXI.isPowerOfTwo = function(width, height) { return (width > 0 && (width & (width - 1)) === 0 && height > 0 && (height & (height - 1)) === 0); }; PIXI.CanvasPool = { create: function (parent, width, height) { var idx = PIXI.CanvasPool.getFirst(); var canvas; if (idx === -1) { var container = { parent: parent, canvas: document.createElement('canvas') }; PIXI.CanvasPool.pool.push(container); canvas = container.canvas; } else { PIXI.CanvasPool.pool[idx].parent = parent; canvas = PIXI.CanvasPool.pool[idx].canvas; } if (width !== undefined) { canvas.width = width; canvas.height = height; } return canvas; }, getFirst: function () { var pool = PIXI.CanvasPool.pool; for (var i = 0; i < pool.length; i++) { if (!pool[i].parent) { return i; } } return -1; }, remove: function (parent) { var pool = PIXI.CanvasPool.pool; for (var i = 0; i < pool.length; i++) { if (pool[i].parent === parent) { pool[i].parent = null; pool[i].canvas.width = 1; pool[i].canvas.height = 1; } } }, removeByCanvas: function (canvas) { var pool = PIXI.CanvasPool.pool; for (var i = 0; i < pool.length; i++) { if (pool[i].canvas === canvas) { pool[i].parent = null; pool[i].canvas.width = 1; pool[i].canvas.height = 1; } } }, getTotal: function () { var pool = PIXI.CanvasPool.pool; var c = 0; for (var i = 0; i < pool.length; i++) { if (pool[i].parent) { c++; } } return c; }, getFree: function () { var pool = PIXI.CanvasPool.pool; var c = 0; for (var i = 0; i < pool.length; i++) { if (!pool[i].parent) { c++; } } return c; } }; PIXI.CanvasPool.pool = []; PIXI.initDefaultShaders = function() { }; PIXI.CompileVertexShader = function(gl, shaderSrc) { return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER); }; PIXI.CompileFragmentShader = function(gl, shaderSrc) { return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER); }; PIXI._CompileShader = function(gl, shaderSrc, shaderType) { var src = shaderSrc; if (Array.isArray(shaderSrc)) { src = shaderSrc.join("\n"); } var shader = gl.createShader(shaderType); gl.shaderSource(shader, src); gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { window.console.log(gl.getShaderInfoLog(shader)); return null; } return shader; }; PIXI.compileProgram = function(gl, vertexSrc, fragmentSrc) { var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc); var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc); var shaderProgram = gl.createProgram(); gl.attachShader(shaderProgram, vertexShader); gl.attachShader(shaderProgram, fragmentShader); gl.linkProgram(shaderProgram); if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) { window.console.log(gl.getProgramInfoLog(shaderProgram)); window.console.log("Could not initialise shaders"); } return shaderProgram; }; PIXI.PixiShader = function(gl) { this._UID = PIXI._UID++; this.gl = gl; this.program = null; this.fragmentSrc = [ 'precision lowp float;', 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'uniform sampler2D uSampler;', 'void main(void) {', '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;', '}' ]; this.textureCount = 0; this.firstRun = true; this.dirty = true; this.attributes = []; this.init(); }; PIXI.PixiShader.prototype.constructor = PIXI.PixiShader; PIXI.PixiShader.prototype.init = function() { var gl = this.gl; var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc); gl.useProgram(program); this.uSampler = gl.getUniformLocation(program, 'uSampler'); this.projectionVector = gl.getUniformLocation(program, 'projectionVector'); this.offsetVector = gl.getUniformLocation(program, 'offsetVector'); this.dimensions = gl.getUniformLocation(program, 'dimensions'); this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition'); this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord'); this.colorAttribute = gl.getAttribLocation(program, 'aColor'); if(this.colorAttribute === -1) { this.colorAttribute = 2; } this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute]; for (var key in this.uniforms) { this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key); } this.initUniforms(); this.program = program; }; PIXI.PixiShader.prototype.initUniforms = function() { this.textureCount = 1; var gl = this.gl; var uniform; for (var key in this.uniforms) { uniform = this.uniforms[key]; var type = uniform.type; if (type === 'sampler2D') { uniform._init = false; if (uniform.value !== null) { this.initSampler2D(uniform); } } else if (type === 'mat2' || type === 'mat3' || type === 'mat4') { uniform.glMatrix = true; uniform.glValueLength = 1; if (type === 'mat2') { uniform.glFunc = gl.uniformMatrix2fv; } else if (type === 'mat3') { uniform.glFunc = gl.uniformMatrix3fv; } else if (type === 'mat4') { uniform.glFunc = gl.uniformMatrix4fv; } } else { uniform.glFunc = gl['uniform' + type]; if (type === '2f' || type === '2i') { uniform.glValueLength = 2; } else if (type === '3f' || type === '3i') { uniform.glValueLength = 3; } else if (type === '4f' || type === '4i') { uniform.glValueLength = 4; } else { uniform.glValueLength = 1; } } } }; PIXI.PixiShader.prototype.initSampler2D = function(uniform) { if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded) { return; } var gl = this.gl; gl.activeTexture(gl['TEXTURE' + this.textureCount]); gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]); if (uniform.textureData) { var data = uniform.textureData; var magFilter = (data.magFilter) ? data.magFilter : gl.LINEAR; var minFilter = (data.minFilter) ? data.minFilter : gl.LINEAR; var wrapS = (data.wrapS) ? data.wrapS : gl.CLAMP_TO_EDGE; var wrapT = (data.wrapT) ? data.wrapT : gl.CLAMP_TO_EDGE; var format = (data.luminance) ? gl.LUMINANCE : gl.RGBA; if (data.repeat) { wrapS = gl.REPEAT; wrapT = gl.REPEAT; } gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY); if (data.width) { var width = (data.width) ? data.width : 512; var height = (data.height) ? data.height : 2; var border = (data.border) ? data.border : 0; gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null); } else { gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source); } gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT); } gl.uniform1i(uniform.uniformLocation, this.textureCount); uniform._init = true; this.textureCount++; }; PIXI.PixiShader.prototype.syncUniforms = function() { this.textureCount = 1; var uniform; var gl = this.gl; for (var key in this.uniforms) { uniform = this.uniforms[key]; if (uniform.glValueLength === 1) { if (uniform.glMatrix === true) { uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value); } else { uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value); } } else if (uniform.glValueLength === 2) { uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y); } else if (uniform.glValueLength === 3) { uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z); } else if (uniform.glValueLength === 4) { uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w); } else if (uniform.type === 'sampler2D') { if (uniform._init) { gl.activeTexture(gl['TEXTURE' + this.textureCount]); if(uniform.value.baseTexture._dirty[gl.id]) { PIXI.instances[gl.id].updateTexture(uniform.value.baseTexture); } else { gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]); } gl.uniform1i(uniform.uniformLocation, this.textureCount); this.textureCount++; } else { this.initSampler2D(uniform); } } } }; PIXI.PixiShader.prototype.destroy = function() { this.gl.deleteProgram( this.program ); this.uniforms = null; this.gl = null; this.attributes = null; }; PIXI.PixiShader.defaultVertexSrc = [ 'attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'attribute vec4 aColor;', 'uniform vec2 projectionVector;', 'uniform vec2 offsetVector;', 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'const vec2 center = vec2(-1.0, 1.0);', 'void main(void) {', '   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);', '   vTextureCoord = aTextureCoord;', '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);', '}' ]; PIXI.PixiFastShader = function(gl) { this._UID = PIXI._UID++; this.gl = gl; this.program = null; this.fragmentSrc = [ 'precision lowp float;', 'varying vec2 vTextureCoord;', 'varying float vColor;', 'uniform sampler2D uSampler;', 'void main(void) {', '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;', '}' ]; this.vertexSrc = [ 'attribute vec2 aVertexPosition;', 'attribute vec2 aPositionCoord;', 'attribute vec2 aScale;', 'attribute float aRotation;', 'attribute vec2 aTextureCoord;', 'attribute float aColor;', 'uniform vec2 projectionVector;', 'uniform vec2 offsetVector;', 'uniform mat3 uMatrix;', 'varying vec2 vTextureCoord;', 'varying float vColor;', 'const vec2 center = vec2(-1.0, 1.0);', 'void main(void) {', '   vec2 v;', '   vec2 sv = aVertexPosition * aScale;', '   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);', '   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);', '   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;', '   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);', '   vTextureCoord = aTextureCoord;', '   vColor = aColor;', '}' ]; this.textureCount = 0; this.init(); }; PIXI.PixiFastShader.prototype.constructor = PIXI.PixiFastShader; PIXI.PixiFastShader.prototype.init = function() { var gl = this.gl; var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc); gl.useProgram(program); this.uSampler = gl.getUniformLocation(program, 'uSampler'); this.projectionVector = gl.getUniformLocation(program, 'projectionVector'); this.offsetVector = gl.getUniformLocation(program, 'offsetVector'); this.dimensions = gl.getUniformLocation(program, 'dimensions'); this.uMatrix = gl.getUniformLocation(program, 'uMatrix'); this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition'); this.aPositionCoord = gl.getAttribLocation(program, 'aPositionCoord'); this.aScale = gl.getAttribLocation(program, 'aScale'); this.aRotation = gl.getAttribLocation(program, 'aRotation'); this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord'); this.colorAttribute = gl.getAttribLocation(program, 'aColor'); if(this.colorAttribute === -1) { this.colorAttribute = 2; } this.attributes = [this.aVertexPosition, this.aPositionCoord,  this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute]; this.program = program; }; PIXI.PixiFastShader.prototype.destroy = function() { this.gl.deleteProgram( this.program ); this.uniforms = null; this.gl = null; this.attributes = null; }; PIXI.StripShader = function(gl) { this._UID = PIXI._UID++; this.gl = gl; this.program = null; this.fragmentSrc = [ 'precision mediump float;', 'varying vec2 vTextureCoord;', 'uniform float alpha;', 'uniform sampler2D uSampler;', 'void main(void) {', '   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;', '}' ]; this.vertexSrc  = [ 'attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform mat3 translationMatrix;', 'uniform vec2 projectionVector;', 'uniform vec2 offsetVector;', 'varying vec2 vTextureCoord;', 'void main(void) {', '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);', '   v -= offsetVector.xyx;', '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);', '   vTextureCoord = aTextureCoord;', '}' ]; this.init(); }; PIXI.StripShader.prototype.constructor = PIXI.StripShader; PIXI.StripShader.prototype.init = function() { var gl = this.gl; var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc); gl.useProgram(program); this.uSampler = gl.getUniformLocation(program, 'uSampler'); this.projectionVector = gl.getUniformLocation(program, 'projectionVector'); this.offsetVector = gl.getUniformLocation(program, 'offsetVector'); this.colorAttribute = gl.getAttribLocation(program, 'aColor'); this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition'); this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord'); this.attributes = [this.aVertexPosition, this.aTextureCoord]; this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix'); this.alpha = gl.getUniformLocation(program, 'alpha'); this.program = program; }; PIXI.StripShader.prototype.destroy = function() { this.gl.deleteProgram( this.program ); this.uniforms = null; this.gl = null; this.attribute = null; }; PIXI.PrimitiveShader = function(gl) { this._UID = PIXI._UID++; this.gl = gl; this.program = null; this.fragmentSrc = [ 'precision mediump float;', 'varying vec4 vColor;', 'void main(void) {', '   gl_FragColor = vColor;', '}' ]; this.vertexSrc  = [ 'attribute vec2 aVertexPosition;', 'attribute vec4 aColor;', 'uniform mat3 translationMatrix;', 'uniform vec2 projectionVector;', 'uniform vec2 offsetVector;', 'uniform float alpha;', 'uniform float flipY;', 'uniform vec3 tint;', 'varying vec4 vColor;', 'void main(void) {', '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);', '   v -= offsetVector.xyx;', '   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);', '   vColor = aColor * vec4(tint * alpha, alpha);', '}' ]; this.init(); }; PIXI.PrimitiveShader.prototype.constructor = PIXI.PrimitiveShader; PIXI.PrimitiveShader.prototype.init = function() { var gl = this.gl; var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc); gl.useProgram(program); this.projectionVector = gl.getUniformLocation(program, 'projectionVector'); this.offsetVector = gl.getUniformLocation(program, 'offsetVector'); this.tintColor = gl.getUniformLocation(program, 'tint'); this.flipY = gl.getUniformLocation(program, 'flipY'); this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition'); this.colorAttribute = gl.getAttribLocation(program, 'aColor'); this.attributes = [this.aVertexPosition, this.colorAttribute]; this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix'); this.alpha = gl.getUniformLocation(program, 'alpha'); this.program = program; }; PIXI.PrimitiveShader.prototype.destroy = function() { this.gl.deleteProgram( this.program ); this.uniforms = null; this.gl = null; this.attributes = null; }; PIXI.ComplexPrimitiveShader = function(gl) { this._UID = PIXI._UID++; this.gl = gl; this.program = null; this.fragmentSrc = [ 'precision mediump float;', 'varying vec4 vColor;', 'void main(void) {', '   gl_FragColor = vColor;', '}' ]; this.vertexSrc  = [ 'attribute vec2 aVertexPosition;', 'uniform mat3 translationMatrix;', 'uniform vec2 projectionVector;', 'uniform vec2 offsetVector;', 'uniform vec3 tint;', 'uniform float alpha;', 'uniform vec3 color;', 'uniform float flipY;', 'varying vec4 vColor;', 'void main(void) {', '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);', '   v -= offsetVector.xyx;', '   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);', '   vColor = vec4(color * alpha * tint, alpha);', '}' ]; this.init(); }; PIXI.ComplexPrimitiveShader.prototype.constructor = PIXI.ComplexPrimitiveShader; PIXI.ComplexPrimitiveShader.prototype.init = function() { var gl = this.gl; var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc); gl.useProgram(program); this.projectionVector = gl.getUniformLocation(program, 'projectionVector'); this.offsetVector = gl.getUniformLocation(program, 'offsetVector'); this.tintColor = gl.getUniformLocation(program, 'tint'); this.color = gl.getUniformLocation(program, 'color'); this.flipY = gl.getUniformLocation(program, 'flipY'); this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition'); this.attributes = [this.aVertexPosition, this.colorAttribute]; this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix'); this.alpha = gl.getUniformLocation(program, 'alpha'); this.program = program; }; PIXI.ComplexPrimitiveShader.prototype.destroy = function() { this.gl.deleteProgram( this.program ); this.uniforms = null; this.gl = null; this.attribute = null; }; PIXI.glContexts = []; PIXI.instances = []; PIXI.WebGLRenderer = function(game) { this.game = game; if (!PIXI.defaultRenderer) { PIXI.defaultRenderer = this; } this.type = PIXI.WEBGL_RENDERER; this.resolution = game.resolution; this.transparent = game.transparent; this.autoResize = false; this.preserveDrawingBuffer = game.preserveDrawingBuffer; this.clearBeforeRender = game.clearBeforeRender; this.width = game.width; this.height = game.height; this.view = game.canvas; this._contextOptions = { alpha: this.transparent, antialias: game.antialias, premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied', stencil: true, preserveDrawingBuffer: this.preserveDrawingBuffer }; this.projection = new PIXI.Point(); this.offset = new PIXI.Point(); this.shaderManager = new PIXI.WebGLShaderManager(); this.spriteBatch = new PIXI.WebGLSpriteBatch(); this.maskManager = new PIXI.WebGLMaskManager(); this.filterManager = new PIXI.WebGLFilterManager(); this.stencilManager = new PIXI.WebGLStencilManager(); this.blendModeManager = new PIXI.WebGLBlendModeManager(); this.renderSession = {}; this.renderSession.game = this.game; this.renderSession.gl = this.gl; this.renderSession.drawCount = 0; this.renderSession.shaderManager = this.shaderManager; this.renderSession.maskManager = this.maskManager; this.renderSession.filterManager = this.filterManager; this.renderSession.blendModeManager = this.blendModeManager; this.renderSession.spriteBatch = this.spriteBatch; this.renderSession.stencilManager = this.stencilManager; this.renderSession.renderer = this; this.renderSession.resolution = this.resolution; this.initContext(); this.mapBlendModes(); }; PIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer; PIXI.WebGLRenderer.prototype.initContext = function() { var gl = this.view.getContext('webgl', this._contextOptions) || this.view.getContext('experimental-webgl', this._contextOptions); this.gl = gl; if (!gl) { throw new Error('This browser does not support webGL. Try using the canvas renderer'); } this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId++; PIXI.glContexts[this.glContextId] = gl; PIXI.instances[this.glContextId] = this; gl.disable(gl.DEPTH_TEST); gl.disable(gl.CULL_FACE); gl.enable(gl.BLEND); this.shaderManager.setContext(gl); this.spriteBatch.setContext(gl); this.maskManager.setContext(gl); this.filterManager.setContext(gl); this.blendModeManager.setContext(gl); this.stencilManager.setContext(gl); this.renderSession.gl = this.gl; this.resize(this.width, this.height); }; PIXI.WebGLRenderer.prototype.render = function(stage) { if (this.contextLost) { return; } var gl = this.gl; gl.viewport(0, 0, this.width, this.height); gl.bindFramebuffer(gl.FRAMEBUFFER, null); if (this.game.clearBeforeRender) { gl.clearColor(stage._bgColor.r, stage._bgColor.g, stage._bgColor.b, stage._bgColor.a); gl.clear(gl.COLOR_BUFFER_BIT); } this.offset.x = this.game.camera._shake.x; this.offset.y = this.game.camera._shake.y; this.renderDisplayObject(stage, this.projection); }; PIXI.WebGLRenderer.prototype.renderDisplayObject = function(displayObject, projection, buffer, matrix) { this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL); this.renderSession.drawCount = 0; this.renderSession.flipY = buffer ? -1 : 1; this.renderSession.projection = projection; this.renderSession.offset = this.offset; this.spriteBatch.begin(this.renderSession); this.filterManager.begin(this.renderSession, buffer); displayObject._renderWebGL(this.renderSession, matrix); this.spriteBatch.end(); }; PIXI.WebGLRenderer.prototype.resize = function(width, height) { this.width = width * this.resolution; this.height = height * this.resolution; this.view.width = this.width; this.view.height = this.height; if (this.autoResize) { this.view.style.width = this.width / this.resolution + 'px'; this.view.style.height = this.height / this.resolution + 'px'; } this.gl.viewport(0, 0, this.width, this.height); this.projection.x =  this.width / 2 / this.resolution; this.projection.y =  -this.height / 2 / this.resolution; }; PIXI.WebGLRenderer.prototype.updateTexture = function(texture) { if (!texture.hasLoaded) { return false; } var gl = this.gl; if (!texture._glTextures[gl.id]) { texture._glTextures[gl.id] = gl.createTexture(); } gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]); gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST); if (texture.mipmap && PIXI.isPowerOfTwo(texture.width, texture.height)) { gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST); gl.generateMipmap(gl.TEXTURE_2D); } else { gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST); } if (!texture._powerOf2) { gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); } else { gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT); } texture._dirty[gl.id] = false; return true; }; PIXI.WebGLRenderer.prototype.destroy = function() { PIXI.glContexts[this.glContextId] = null; this.projection = null; this.offset = null; this.shaderManager.destroy(); this.spriteBatch.destroy(); this.maskManager.destroy(); this.filterManager.destroy(); this.shaderManager = null; this.spriteBatch = null; this.maskManager = null; this.filterManager = null; this.gl = null; this.renderSession = null; PIXI.CanvasPool.remove(this); PIXI.instances[this.glContextId] = null; PIXI.WebGLRenderer.glContextId--; }; PIXI.WebGLRenderer.prototype.mapBlendModes = function() { var gl = this.gl; if (!PIXI.blendModesWebGL) { var b = []; var modes = PIXI.blendModes; b[modes.NORMAL]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.ADD]           = [gl.SRC_ALPHA, gl.DST_ALPHA]; b[modes.MULTIPLY]      = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA]; b[modes.SCREEN]        = [gl.SRC_ALPHA, gl.ONE]; b[modes.OVERLAY]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.DARKEN]        = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.LIGHTEN]       = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.COLOR_DODGE]   = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.COLOR_BURN]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.HARD_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.SOFT_LIGHT]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.DIFFERENCE]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.EXCLUSION]     = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.HUE]           = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.SATURATION]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.COLOR]         = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; b[modes.LUMINOSITY]    = [gl.ONE,       gl.ONE_MINUS_SRC_ALPHA]; PIXI.blendModesWebGL = b; } }; PIXI.WebGLRenderer.glContextId = 0; PIXI.WebGLBlendModeManager = function() { this.currentBlendMode = 99999; }; PIXI.WebGLBlendModeManager.prototype.constructor = PIXI.WebGLBlendModeManager; PIXI.WebGLBlendModeManager.prototype.setContext = function(gl) { this.gl = gl; }; PIXI.WebGLBlendModeManager.prototype.setBlendMode = function(blendMode) { if(this.currentBlendMode === blendMode)return false; this.currentBlendMode = blendMode; var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode]; if (blendModeWebGL) { this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]); } return true; }; PIXI.WebGLBlendModeManager.prototype.destroy = function() { this.gl = null; }; PIXI.WebGLMaskManager = function() { }; PIXI.WebGLMaskManager.prototype.constructor = PIXI.WebGLMaskManager; PIXI.WebGLMaskManager.prototype.setContext = function(gl) { this.gl = gl; }; PIXI.WebGLMaskManager.prototype.pushMask = function(maskData, renderSession) { var gl = renderSession.gl; if (maskData.dirty) { PIXI.WebGLGraphics.updateGraphics(maskData, gl); } if (maskData._webGL[gl.id] === undefined || maskData._webGL[gl.id].data === undefined || maskData._webGL[gl.id].data.length === 0) { return; } renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession); }; PIXI.WebGLMaskManager.prototype.popMask = function(maskData, renderSession) { var gl = this.gl; if (maskData._webGL[gl.id] === undefined || maskData._webGL[gl.id].data === undefined || maskData._webGL[gl.id].data.length === 0) { return; } renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession); }; PIXI.WebGLMaskManager.prototype.destroy = function() { this.gl = null; }; PIXI.WebGLStencilManager = function() { this.stencilStack = []; this.reverse = true; this.count = 0; }; PIXI.WebGLStencilManager.prototype.setContext = function(gl) { this.gl = gl; }; PIXI.WebGLStencilManager.prototype.pushStencil = function(graphics, webGLData, renderSession) { var gl = this.gl; this.bindGraphics(graphics, webGLData, renderSession); if(this.stencilStack.length === 0) { gl.enable(gl.STENCIL_TEST); gl.clear(gl.STENCIL_BUFFER_BIT); this.reverse = true; this.count = 0; } this.stencilStack.push(webGLData); var level = this.count; gl.colorMask(false, false, false, false); gl.stencilFunc(gl.ALWAYS,0,0xFF); gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT); if(webGLData.mode === 1) { gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 ); if(this.reverse) { gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF); gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR); } else { gl.stencilFunc(gl.EQUAL,level, 0xFF); gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR); } gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 ); if(this.reverse) { gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF); } else { gl.stencilFunc(gl.EQUAL,level+1, 0xFF); } this.reverse = !this.reverse; } else { if(!this.reverse) { gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF); gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR); } else { gl.stencilFunc(gl.EQUAL,level, 0xFF); gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR); } gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 ); if(!this.reverse) { gl.stencilFunc(gl.EQUAL,0xFF-(level+1), 0xFF); } else { gl.stencilFunc(gl.EQUAL,level+1, 0xFF); } } gl.colorMask(true, true, true, true); gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP); this.count++; }; PIXI.WebGLStencilManager.prototype.bindGraphics = function(graphics, webGLData, renderSession) { this._currentGraphics = graphics; var gl = this.gl; var projection = renderSession.projection, offset = renderSession.offset, shader; if(webGLData.mode === 1) { shader = renderSession.shaderManager.complexPrimitiveShader; renderSession.shaderManager.setShader( shader ); gl.uniform1f(shader.flipY, renderSession.flipY); gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true)); gl.uniform2f(shader.projectionVector, projection.x, -projection.y); gl.uniform2f(shader.offsetVector, -offset.x, -offset.y); gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint)); gl.uniform3fv(shader.color, webGLData.color); gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha); gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer); } else { shader = renderSession.shaderManager.primitiveShader; renderSession.shaderManager.setShader( shader ); gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true)); gl.uniform1f(shader.flipY, renderSession.flipY); gl.uniform2f(shader.projectionVector, projection.x, -projection.y); gl.uniform2f(shader.offsetVector, -offset.x, -offset.y); gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint)); gl.uniform1f(shader.alpha, graphics.worldAlpha); gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0); gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer); } }; PIXI.WebGLStencilManager.prototype.popStencil = function(graphics, webGLData, renderSession) { var gl = this.gl; this.stencilStack.pop(); this.count--; if(this.stencilStack.length === 0) { gl.disable(gl.STENCIL_TEST); } else { var level = this.count; this.bindGraphics(graphics, webGLData, renderSession); gl.colorMask(false, false, false, false); if(webGLData.mode === 1) { this.reverse = !this.reverse; if(this.reverse) { gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF); gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR); } else { gl.stencilFunc(gl.EQUAL,level+1, 0xFF); gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR); } gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 ); gl.stencilFunc(gl.ALWAYS,0,0xFF); gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT); gl.drawElements(gl.TRIANGLE_FAN,  webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0 ); if(!this.reverse) { gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF); } else { gl.stencilFunc(gl.EQUAL,level, 0xFF); } } else { if(!this.reverse) { gl.stencilFunc(gl.EQUAL, 0xFF - (level+1), 0xFF); gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR); } else { gl.stencilFunc(gl.EQUAL,level+1, 0xFF); gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR); } gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 ); if(!this.reverse) { gl.stencilFunc(gl.EQUAL,0xFF-(level), 0xFF); } else { gl.stencilFunc(gl.EQUAL,level, 0xFF); } } gl.colorMask(true, true, true, true); gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP); } }; PIXI.WebGLStencilManager.prototype.destroy = function() { this.stencilStack = null; this.gl = null; }; PIXI.WebGLShaderManager = function() { this.maxAttibs = 10; this.attribState = []; this.tempAttribState = []; for (var i = 0; i < this.maxAttibs; i++) { this.attribState[i] = false; } this.stack = []; }; PIXI.WebGLShaderManager.prototype.constructor = PIXI.WebGLShaderManager; PIXI.WebGLShaderManager.prototype.setContext = function(gl) { this.gl = gl; this.primitiveShader = new PIXI.PrimitiveShader(gl); this.complexPrimitiveShader = new PIXI.ComplexPrimitiveShader(gl); this.defaultShader = new PIXI.PixiShader(gl); this.fastShader = new PIXI.PixiFastShader(gl); this.stripShader = new PIXI.StripShader(gl); this.setShader(this.defaultShader); }; PIXI.WebGLShaderManager.prototype.setAttribs = function(attribs) { var i; for (i = 0; i < this.tempAttribState.length; i++) { this.tempAttribState[i] = false; } for (i = 0; i < attribs.length; i++) { var attribId = attribs[i]; this.tempAttribState[attribId] = true; } var gl = this.gl; for (i = 0; i < this.attribState.length; i++) { if(this.attribState[i] !== this.tempAttribState[i]) { this.attribState[i] = this.tempAttribState[i]; if(this.tempAttribState[i]) { gl.enableVertexAttribArray(i); } else { gl.disableVertexAttribArray(i); } } } }; PIXI.WebGLShaderManager.prototype.setShader = function(shader) { if(this._currentId === shader._UID)return false; this._currentId = shader._UID; this.currentShader = shader; this.gl.useProgram(shader.program); this.setAttribs(shader.attributes); return true; }; PIXI.WebGLShaderManager.prototype.destroy = function() { this.attribState = null; this.tempAttribState = null; this.primitiveShader.destroy(); this.complexPrimitiveShader.destroy(); this.defaultShader.destroy(); this.fastShader.destroy(); this.stripShader.destroy(); this.gl = null; }; PIXI.WebGLSpriteBatch = function() { this.vertSize = 5; this.size = 2000; var numVerts = this.size * 4 * 4 * this.vertSize; var numIndices = this.size * 6; this.vertices = new PIXI.ArrayBuffer(numVerts); this.positions = new PIXI.Float32Array(this.vertices); this.colors = new PIXI.Uint32Array(this.vertices); this.indices = new PIXI.Uint16Array(numIndices); this.lastIndexCount = 0; for (var i=0, j=0; i < numIndices; i += 6, j += 4) { this.indices[i + 0] = j + 0; this.indices[i + 1] = j + 1; this.indices[i + 2] = j + 2; this.indices[i + 3] = j + 0; this.indices[i + 4] = j + 2; this.indices[i + 5] = j + 3; } this.drawing = false; this.currentBatchSize = 0; this.currentBaseTexture = null; this.dirty = true; this.textures = []; this.blendModes = []; this.shaders = []; this.sprites = []; this.defaultShader = new PIXI.AbstractFilter([ 'precision lowp float;', 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'uniform sampler2D uSampler;', 'void main(void) {', '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;', '}' ]); }; PIXI.WebGLSpriteBatch.prototype.setContext = function(gl) { this.gl = gl; this.vertexBuffer = gl.createBuffer(); this.indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW); this.currentBlendMode = 99999; var shader = new PIXI.PixiShader(gl); shader.fragmentSrc = this.defaultShader.fragmentSrc; shader.uniforms = {}; shader.init(); this.defaultShader.shaders[gl.id] = shader; }; PIXI.WebGLSpriteBatch.prototype.begin = function(renderSession) { this.renderSession = renderSession; this.shader = this.renderSession.shaderManager.defaultShader; this.start(); }; PIXI.WebGLSpriteBatch.prototype.end = function() { this.flush(); }; PIXI.WebGLSpriteBatch.prototype.render = function(sprite, matrix) { var texture = sprite.texture; var wt = sprite.worldTransform; if (matrix) { wt = matrix; } if (this.currentBatchSize >= this.size) { this.flush(); this.currentBaseTexture = texture.baseTexture; } var uvs = texture._uvs; if (!uvs) { return; } var aX = sprite.anchor.x; var aY = sprite.anchor.y; var w0, w1, h0, h1; if (texture.trim) { var trim = texture.trim; w1 = trim.x - aX * trim.width; w0 = w1 + texture.crop.width; h1 = trim.y - aY * trim.height; h0 = h1 + texture.crop.height; } else { w0 = (texture.frame.width) * (1-aX); w1 = (texture.frame.width) * -aX; h0 = texture.frame.height * (1-aY); h1 = texture.frame.height * -aY; } var i = this.currentBatchSize * 4 * this.vertSize; var resolution = texture.baseTexture.resolution; var a = wt.a / resolution; var b = wt.b / resolution; var c = wt.c / resolution; var d = wt.d / resolution; var tx = wt.tx; var ty = wt.ty; var colors = this.colors; var positions = this.positions; if (this.renderSession.roundPixels) { positions[i] = a * w1 + c * h1 + tx | 0; positions[i+1] = d * h1 + b * w1 + ty | 0; positions[i+5] = a * w0 + c * h1 + tx | 0; positions[i+6] = d * h1 + b * w0 + ty | 0; positions[i+10] = a * w0 + c * h0 + tx | 0; positions[i+11] = d * h0 + b * w0 + ty | 0; positions[i+15] = a * w1 + c * h0 + tx | 0; positions[i+16] = d * h0 + b * w1 + ty | 0; } else { positions[i] = a * w1 + c * h1 + tx; positions[i+1] = d * h1 + b * w1 + ty; positions[i+5] = a * w0 + c * h1 + tx; positions[i+6] = d * h1 + b * w0 + ty; positions[i+10] = a * w0 + c * h0 + tx; positions[i+11] = d * h0 + b * w0 + ty; positions[i+15] = a * w1 + c * h0 + tx; positions[i+16] = d * h0 + b * w1 + ty; } positions[i+2] = uvs.x0; positions[i+3] = uvs.y0; positions[i+7] = uvs.x1; positions[i+8] = uvs.y1; positions[i+12] = uvs.x2; positions[i+13] = uvs.y2; positions[i+17] = uvs.x3; positions[i+18] = uvs.y3; var tint = sprite.tint; colors[i+4] = colors[i+9] = colors[i+14] = colors[i+19] = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24); this.sprites[this.currentBatchSize++] = sprite; }; PIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function(sprite) { var texture = sprite.tilingTexture; if (this.currentBatchSize >= this.size) { this.flush(); this.currentBaseTexture = texture.baseTexture; } if (!sprite._uvs) { sprite._uvs = new PIXI.TextureUvs(); } var uvs = sprite._uvs; var w = texture.baseTexture.width; var h = texture.baseTexture.height; sprite.tilePosition.x %= w * sprite.tileScaleOffset.x; sprite.tilePosition.y %= h * sprite.tileScaleOffset.y; var offsetX = sprite.tilePosition.x / (w * sprite.tileScaleOffset.x); var offsetY = sprite.tilePosition.y / (h * sprite.tileScaleOffset.y); var scaleX = (sprite.width / w) / (sprite.tileScale.x * sprite.tileScaleOffset.x); var scaleY = (sprite.height / h) / (sprite.tileScale.y * sprite.tileScaleOffset.y); uvs.x0 = 0 - offsetX; uvs.y0 = 0 - offsetY; uvs.x1 = (1 * scaleX) - offsetX; uvs.y1 = 0 - offsetY; uvs.x2 = (1 * scaleX) - offsetX; uvs.y2 = (1 * scaleY) - offsetY; uvs.x3 = 0 - offsetX; uvs.y3 = (1 * scaleY) - offsetY; var tint = sprite.tint; var color = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24); var positions = this.positions; var colors = this.colors; var width = sprite.width; var height = sprite.height; var aX = sprite.anchor.x; var aY = sprite.anchor.y; var w0 = width * (1-aX); var w1 = width * -aX; var h0 = height * (1-aY); var h1 = height * -aY; var i = this.currentBatchSize * 4 * this.vertSize; var resolution = texture.baseTexture.resolution; var wt = sprite.worldTransform; var a = wt.a / resolution; var b = wt.b / resolution; var c = wt.c / resolution; var d = wt.d / resolution; var tx = wt.tx; var ty = wt.ty; positions[i++] = a * w1 + c * h1 + tx; positions[i++] = d * h1 + b * w1 + ty; positions[i++] = uvs.x0; positions[i++] = uvs.y0; colors[i++] = color; positions[i++] = (a * w0 + c * h1 + tx); positions[i++] = d * h1 + b * w0 + ty; positions[i++] = uvs.x1; positions[i++] = uvs.y1; colors[i++] = color; positions[i++] = a * w0 + c * h0 + tx; positions[i++] = d * h0 + b * w0 + ty; positions[i++] = uvs.x2; positions[i++] = uvs.y2; colors[i++] = color; positions[i++] = a * w1 + c * h0 + tx; positions[i++] = d * h0 + b * w1 + ty; positions[i++] = uvs.x3; positions[i++] = uvs.y3; colors[i++] = color; this.sprites[this.currentBatchSize++] = sprite; }; PIXI.WebGLSpriteBatch.prototype.flush = function() { if (this.currentBatchSize === 0) { return; } var gl = this.gl; var shader; if (this.dirty) { this.dirty = false; gl.activeTexture(gl.TEXTURE0); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); shader = this.defaultShader.shaders[gl.id]; var stride = this.vertSize * 4; gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0); gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4); gl.vertexAttribPointer(shader.colorAttribute, 4, gl.UNSIGNED_BYTE, true, stride, 4 * 4); } if (this.currentBatchSize > (this.size * 0.5)) { gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices); } else { var view = this.positions.subarray(0, this.currentBatchSize * 4 * this.vertSize); gl.bufferSubData(gl.ARRAY_BUFFER, 0, view); } var nextTexture, nextBlendMode, nextShader; var batchSize = 0; var start = 0; var currentBaseTexture = null; var currentBlendMode = this.renderSession.blendModeManager.currentBlendMode; var currentShader = null; var blendSwap = false; var shaderSwap = false; var sprite; for (var i = 0, j = this.currentBatchSize; i < j; i++) { sprite = this.sprites[i]; if (sprite.tilingTexture) { nextTexture = sprite.tilingTexture.baseTexture; } else { nextTexture = sprite.texture.baseTexture; } nextBlendMode = sprite.blendMode; nextShader = sprite.shader || this.defaultShader; blendSwap = currentBlendMode !== nextBlendMode; shaderSwap = currentShader !== nextShader; var skip = nextTexture.skipRender; if (skip && sprite.children.length > 0) { skip = false; } if ((currentBaseTexture !== nextTexture && !skip) || blendSwap || shaderSwap) { this.renderBatch(currentBaseTexture, batchSize, start); start = i; batchSize = 0; currentBaseTexture = nextTexture; if (blendSwap) { currentBlendMode = nextBlendMode; this.renderSession.blendModeManager.setBlendMode(currentBlendMode); } if (shaderSwap) { currentShader = nextShader; shader = currentShader.shaders[gl.id]; if (!shader) { shader = new PIXI.PixiShader(gl); shader.fragmentSrc = currentShader.fragmentSrc; shader.uniforms = currentShader.uniforms; shader.init(); currentShader.shaders[gl.id] = shader; } this.renderSession.shaderManager.setShader(shader); if (shader.dirty) { shader.syncUniforms(); } var projection = this.renderSession.projection; gl.uniform2f(shader.projectionVector, projection.x, projection.y); var offsetVector = this.renderSession.offset; gl.uniform2f(shader.offsetVector, offsetVector.x, offsetVector.y); } } batchSize++; } this.renderBatch(currentBaseTexture, batchSize, start); this.currentBatchSize = 0; }; PIXI.WebGLSpriteBatch.prototype.renderBatch = function(texture, size, startIndex) { if (size === 0) { return; } var gl = this.gl; if (texture._dirty[gl.id]) { if (!this.renderSession.renderer.updateTexture(texture)) { return; } } else { gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]); } gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2); this.renderSession.drawCount++; }; PIXI.WebGLSpriteBatch.prototype.stop = function() { this.flush(); this.dirty = true; }; PIXI.WebGLSpriteBatch.prototype.start = function() { this.dirty = true; }; PIXI.WebGLSpriteBatch.prototype.destroy = function() { this.vertices = null; this.indices = null; this.gl.deleteBuffer(this.vertexBuffer); this.gl.deleteBuffer(this.indexBuffer); this.currentBaseTexture = null; this.gl = null; }; PIXI.WebGLFastSpriteBatch = function(gl) { this.vertSize = 10; this.maxSize = 6000; this.size = this.maxSize; var numVerts = this.size * 4 *  this.vertSize; var numIndices = this.maxSize * 6; this.vertices = new PIXI.Float32Array(numVerts); this.indices = new PIXI.Uint16Array(numIndices); this.vertexBuffer = null; this.indexBuffer = null; this.lastIndexCount = 0; for (var i=0, j=0; i < numIndices; i += 6, j += 4) { this.indices[i + 0] = j + 0; this.indices[i + 1] = j + 1; this.indices[i + 2] = j + 2; this.indices[i + 3] = j + 0; this.indices[i + 4] = j + 2; this.indices[i + 5] = j + 3; } this.drawing = false; this.currentBatchSize = 0; this.currentBaseTexture = null; this.currentBlendMode = 0; this.renderSession = null; this.shader = null; this.matrix = null; this.setContext(gl); }; PIXI.WebGLFastSpriteBatch.prototype.constructor = PIXI.WebGLFastSpriteBatch; PIXI.WebGLFastSpriteBatch.prototype.setContext = function(gl) { this.gl = gl; this.vertexBuffer = gl.createBuffer(); this.indexBuffer = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW); }; PIXI.WebGLFastSpriteBatch.prototype.begin = function(spriteBatch, renderSession) { this.renderSession = renderSession; this.shader = this.renderSession.shaderManager.fastShader; this.matrix = spriteBatch.worldTransform.toArray(true); this.start(); }; PIXI.WebGLFastSpriteBatch.prototype.end = function() { this.flush(); }; PIXI.WebGLFastSpriteBatch.prototype.render = function(spriteBatch) { var children = spriteBatch.children; var sprite = children[0]; if(!sprite.texture._uvs)return; this.currentBaseTexture = sprite.texture.baseTexture; if(sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode) { this.flush(); this.renderSession.blendModeManager.setBlendMode(sprite.blendMode); } for(var i=0,j= children.length; i<j; i++) { this.renderSprite(children[i]); } this.flush(); }; PIXI.WebGLFastSpriteBatch.prototype.renderSprite = function(sprite) { if(!sprite.visible)return; if(sprite.texture.baseTexture !== this.currentBaseTexture && !sprite.texture.baseTexture.skipRender) { this.flush(); this.currentBaseTexture = sprite.texture.baseTexture; if(!sprite.texture._uvs)return; } var uvs, vertices = this.vertices, width, height, w0, w1, h0, h1, index; uvs = sprite.texture._uvs; width = sprite.texture.frame.width; height = sprite.texture.frame.height; if (sprite.texture.trim) { var trim = sprite.texture.trim; w1 = trim.x - sprite.anchor.x * trim.width; w0 = w1 + sprite.texture.crop.width; h1 = trim.y - sprite.anchor.y * trim.height; h0 = h1 + sprite.texture.crop.height; } else { w0 = (sprite.texture.frame.width ) * (1-sprite.anchor.x); w1 = (sprite.texture.frame.width ) * -sprite.anchor.x; h0 = sprite.texture.frame.height * (1-sprite.anchor.y); h1 = sprite.texture.frame.height * -sprite.anchor.y; } index = this.currentBatchSize * 4 * this.vertSize; vertices[index++] = w1; vertices[index++] = h1; vertices[index++] = sprite.position.x; vertices[index++] = sprite.position.y; vertices[index++] = sprite.scale.x; vertices[index++] = sprite.scale.y; vertices[index++] = sprite.rotation; vertices[index++] = uvs.x0; vertices[index++] = uvs.y1; vertices[index++] = sprite.alpha; vertices[index++] = w0; vertices[index++] = h1; vertices[index++] = sprite.position.x; vertices[index++] = sprite.position.y; vertices[index++] = sprite.scale.x; vertices[index++] = sprite.scale.y; vertices[index++] = sprite.rotation; vertices[index++] = uvs.x1; vertices[index++] = uvs.y1; vertices[index++] = sprite.alpha; vertices[index++] = w0; vertices[index++] = h0; vertices[index++] = sprite.position.x; vertices[index++] = sprite.position.y; vertices[index++] = sprite.scale.x; vertices[index++] = sprite.scale.y; vertices[index++] = sprite.rotation; vertices[index++] = uvs.x2; vertices[index++] = uvs.y2; vertices[index++] = sprite.alpha; vertices[index++] = w1; vertices[index++] = h0; vertices[index++] = sprite.position.x; vertices[index++] = sprite.position.y; vertices[index++] = sprite.scale.x; vertices[index++] = sprite.scale.y; vertices[index++] = sprite.rotation; vertices[index++] = uvs.x3; vertices[index++] = uvs.y3; vertices[index++] = sprite.alpha; this.currentBatchSize++; if(this.currentBatchSize >= this.size) { this.flush(); } }; PIXI.WebGLFastSpriteBatch.prototype.flush = function() { if (this.currentBatchSize===0)return; var gl = this.gl; if(!this.currentBaseTexture._glTextures[gl.id])this.renderSession.renderer.updateTexture(this.currentBaseTexture, gl); gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]); if(this.currentBatchSize > ( this.size * 0.5 ) ) { gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices); } else { var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize); gl.bufferSubData(gl.ARRAY_BUFFER, 0, view); } gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0); this.currentBatchSize = 0; this.renderSession.drawCount++; }; PIXI.WebGLFastSpriteBatch.prototype.stop = function() { this.flush(); }; PIXI.WebGLFastSpriteBatch.prototype.start = function() { var gl = this.gl; gl.activeTexture(gl.TEXTURE0); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); var projection = this.renderSession.projection; gl.uniform2f(this.shader.projectionVector, projection.x, projection.y); gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix); var stride =  this.vertSize * 4; gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0); gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4); gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4); gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4); gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4); gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4); }; PIXI.WebGLFilterManager = function() { this.filterStack = []; this.offsetX = 0; this.offsetY = 0; }; PIXI.WebGLFilterManager.prototype.constructor = PIXI.WebGLFilterManager; PIXI.WebGLFilterManager.prototype.setContext = function(gl) { this.gl = gl; this.texturePool = []; this.initShaderBuffers(); }; PIXI.WebGLFilterManager.prototype.begin = function(renderSession, buffer) { this.renderSession = renderSession; this.defaultShader = renderSession.shaderManager.defaultShader; var projection = this.renderSession.projection; this.width = projection.x * 2; this.height = -projection.y * 2; this.buffer = buffer; }; PIXI.WebGLFilterManager.prototype.pushFilter = function(filterBlock) { var gl = this.gl; var projection = this.renderSession.projection; var offset = this.renderSession.offset; filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds(); filterBlock._previous_stencil_mgr = this.renderSession.stencilManager; this.renderSession.stencilManager = new PIXI.WebGLStencilManager(); this.renderSession.stencilManager.setContext(gl); gl.disable(gl.STENCIL_TEST); this.filterStack.push(filterBlock); var filter = filterBlock.filterPasses[0]; this.offsetX += filterBlock._filterArea.x; this.offsetY += filterBlock._filterArea.y; var texture = this.texturePool.pop(); if(!texture) { texture = new PIXI.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution); } else { texture.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution); } gl.bindTexture(gl.TEXTURE_2D,  texture.texture); var filterArea = filterBlock._filterArea; var padding = filter.padding; filterArea.x -= padding; filterArea.y -= padding; filterArea.width += padding * 2; filterArea.height += padding * 2; if(filterArea.x < 0)filterArea.x = 0; if(filterArea.width > this.width)filterArea.width = this.width; if(filterArea.y < 0)filterArea.y = 0; if(filterArea.height > this.height)filterArea.height = this.height; gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer); gl.viewport(0, 0, filterArea.width * this.renderSession.resolution, filterArea.height * this.renderSession.resolution); projection.x = filterArea.width/2; projection.y = -filterArea.height/2; offset.x = -filterArea.x; offset.y = -filterArea.y; gl.colorMask(true, true, true, true); gl.clearColor(0,0,0, 0); gl.clear(gl.COLOR_BUFFER_BIT); filterBlock._glFilterTexture = texture; }; PIXI.WebGLFilterManager.prototype.popFilter = function() { var gl = this.gl; var filterBlock = this.filterStack.pop(); var filterArea = filterBlock._filterArea; var texture = filterBlock._glFilterTexture; var projection = this.renderSession.projection; var offset = this.renderSession.offset; if(filterBlock.filterPasses.length > 1) { gl.viewport(0, 0, filterArea.width * this.renderSession.resolution, filterArea.height * this.renderSession.resolution); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); this.vertexArray[0] = 0; this.vertexArray[1] = filterArea.height; this.vertexArray[2] = filterArea.width; this.vertexArray[3] = filterArea.height; this.vertexArray[4] = 0; this.vertexArray[5] = 0; this.vertexArray[6] = filterArea.width; this.vertexArray[7] = 0; gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray); gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer); this.uvArray[2] = filterArea.width/this.width; this.uvArray[5] = filterArea.height/this.height; this.uvArray[6] = filterArea.width/this.width; this.uvArray[7] = filterArea.height/this.height; gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray); var inputTexture = texture; var outputTexture = this.texturePool.pop(); if(!outputTexture)outputTexture = new PIXI.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution); outputTexture.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution); gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer ); gl.clear(gl.COLOR_BUFFER_BIT); gl.disable(gl.BLEND); for (var i = 0; i < filterBlock.filterPasses.length-1; i++) { var filterPass = filterBlock.filterPasses[i]; gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer ); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture); this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height); var temp = inputTexture; inputTexture = outputTexture; outputTexture = temp; } gl.enable(gl.BLEND); texture = inputTexture; this.texturePool.push(outputTexture); } var filter = filterBlock.filterPasses[filterBlock.filterPasses.length-1]; this.offsetX -= filterArea.x; this.offsetY -= filterArea.y; var sizeX = this.width; var sizeY = this.height; var offsetX = 0; var offsetY = 0; var buffer = this.buffer; if(this.filterStack.length === 0) { gl.colorMask(true, true, true, true); } else { var currentFilter = this.filterStack[this.filterStack.length-1]; filterArea = currentFilter._filterArea; sizeX = filterArea.width; sizeY = filterArea.height; offsetX = filterArea.x; offsetY = filterArea.y; buffer =  currentFilter._glFilterTexture.frameBuffer; } projection.x = sizeX/2; projection.y = -sizeY/2; offset.x = offsetX; offset.y = offsetY; filterArea = filterBlock._filterArea; var x = filterArea.x-offsetX; var y = filterArea.y-offsetY; gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); this.vertexArray[0] = x; this.vertexArray[1] = y + filterArea.height; this.vertexArray[2] = x + filterArea.width; this.vertexArray[3] = y + filterArea.height; this.vertexArray[4] = x; this.vertexArray[5] = y; this.vertexArray[6] = x + filterArea.width; this.vertexArray[7] = y; gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray); gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer); this.uvArray[2] = filterArea.width/this.width; this.uvArray[5] = filterArea.height/this.height; this.uvArray[6] = filterArea.width/this.width; this.uvArray[7] = filterArea.height/this.height; gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray); gl.viewport(0, 0, sizeX * this.renderSession.resolution, sizeY * this.renderSession.resolution); gl.bindFramebuffer(gl.FRAMEBUFFER, buffer ); gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texture.texture); if (this.renderSession.stencilManager) { this.renderSession.stencilManager.destroy(); } this.renderSession.stencilManager = filterBlock._previous_stencil_mgr; filterBlock._previous_stencil_mgr = null; if (this.renderSession.stencilManager.count > 0) { gl.enable(gl.STENCIL_TEST); } else { gl.disable(gl.STENCIL_TEST); } this.applyFilterPass(filter, filterArea, sizeX, sizeY); this.texturePool.push(texture); filterBlock._glFilterTexture = null; }; PIXI.WebGLFilterManager.prototype.applyFilterPass = function(filter, filterArea, width, height) { var gl = this.gl; var shader = filter.shaders[gl.id]; if(!shader) { shader = new PIXI.PixiShader(gl); shader.fragmentSrc = filter.fragmentSrc; shader.uniforms = filter.uniforms; shader.init(); filter.shaders[gl.id] = shader; } this.renderSession.shaderManager.setShader(shader); gl.uniform2f(shader.projectionVector, width/2, -height/2); gl.uniform2f(shader.offsetVector, 0,0); if(filter.uniforms.dimensions) { filter.uniforms.dimensions.value[0] = this.width; filter.uniforms.dimensions.value[1] = this.height; filter.uniforms.dimensions.value[2] = this.vertexArray[0]; filter.uniforms.dimensions.value[3] = this.vertexArray[5]; } shader.syncUniforms(); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer); gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer); gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 ); this.renderSession.drawCount++; }; PIXI.WebGLFilterManager.prototype.initShaderBuffers = function() { var gl = this.gl; this.vertexBuffer = gl.createBuffer(); this.uvBuffer = gl.createBuffer(); this.colorBuffer = gl.createBuffer(); this.indexBuffer = gl.createBuffer(); this.vertexArray = new PIXI.Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]); gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.vertexArray, gl.STATIC_DRAW); this.uvArray = new PIXI.Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]); gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.uvArray, gl.STATIC_DRAW); this.colorArray = new PIXI.Float32Array([1.0, 0xFFFFFF, 1.0, 0xFFFFFF, 1.0, 0xFFFFFF, 1.0, 0xFFFFFF]); gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.colorArray, gl.STATIC_DRAW); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), gl.STATIC_DRAW); }; PIXI.WebGLFilterManager.prototype.destroy = function() { var gl = this.gl; this.filterStack = null; this.offsetX = 0; this.offsetY = 0; for (var i = 0; i < this.texturePool.length; i++) { this.texturePool[i].destroy(); } this.texturePool = null; gl.deleteBuffer(this.vertexBuffer); gl.deleteBuffer(this.uvBuffer); gl.deleteBuffer(this.colorBuffer); gl.deleteBuffer(this.indexBuffer); }; PIXI.FilterTexture = function(gl, width, height, scaleMode) { this.gl = gl; this.frameBuffer = gl.createFramebuffer(); this.texture = gl.createTexture(); scaleMode = scaleMode || PIXI.scaleModes.DEFAULT; gl.bindTexture(gl.TEXTURE_2D,  this.texture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer ); gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer ); gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0); this.renderBuffer = gl.createRenderbuffer(); gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer); gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer); this.resize(width, height); }; PIXI.FilterTexture.prototype.constructor = PIXI.FilterTexture; PIXI.FilterTexture.prototype.clear = function() { var gl = this.gl; gl.clearColor(0,0,0, 0); gl.clear(gl.COLOR_BUFFER_BIT); }; PIXI.FilterTexture.prototype.resize = function(width, height) { if(this.width === width && this.height === height) return; this.width = width; this.height = height; var gl = this.gl; gl.bindTexture(gl.TEXTURE_2D,  this.texture); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  width , height , 0, gl.RGBA, gl.UNSIGNED_BYTE, null); gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer); gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width , height ); }; PIXI.FilterTexture.prototype.destroy = function() { var gl = this.gl; gl.deleteFramebuffer( this.frameBuffer ); gl.deleteTexture( this.texture ); this.frameBuffer = null; this.texture = null; }; PIXI.CanvasBuffer = function(width, height) { this.width = width; this.height = height; this.canvas = PIXI.CanvasPool.create(this, this.width, this.height); this.context = this.canvas.getContext("2d"); this.canvas.width = width; this.canvas.height = height; }; PIXI.CanvasBuffer.prototype.constructor = PIXI.CanvasBuffer; PIXI.CanvasBuffer.prototype.clear = function() { this.context.setTransform(1, 0, 0, 1, 0, 0); this.context.clearRect(0,0, this.width, this.height); }; PIXI.CanvasBuffer.prototype.resize = function(width, height) { this.width = this.canvas.width = width; this.height = this.canvas.height = height; }; PIXI.CanvasBuffer.prototype.destroy = function() { PIXI.CanvasPool.remove(this); }; PIXI.CanvasMaskManager = function() { }; PIXI.CanvasMaskManager.prototype.constructor = PIXI.CanvasMaskManager; PIXI.CanvasMaskManager.prototype.pushMask = function(maskData, renderSession) { var context = renderSession.context; context.save(); var cacheAlpha = maskData.alpha; var transform = maskData.worldTransform; var resolution = renderSession.resolution; context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution); PIXI.CanvasGraphics.renderGraphicsMask(maskData, context); context.clip(); maskData.worldAlpha = cacheAlpha; }; PIXI.CanvasMaskManager.prototype.popMask = function(renderSession) { renderSession.context.restore(); }; PIXI.CanvasTinter = function() {}; PIXI.CanvasTinter.getTintedTexture = function(sprite, color) { var canvas = sprite.tintedTexture || PIXI.CanvasPool.create(this); PIXI.CanvasTinter.tintMethod(sprite.texture, color, canvas); return canvas; }; PIXI.CanvasTinter.tintWithMultiply = function(texture, color, canvas) { var context = canvas.getContext("2d"); var crop = texture.crop; if (canvas.width !== crop.width || canvas.height !== crop.height) { canvas.width = crop.width; canvas.height = crop.height; } context.clearRect(0, 0, crop.width, crop.height); context.fillStyle = "#" + ("00000" + (color | 0).toString(16)).substr(-6); context.fillRect(0, 0, crop.width, crop.height); context.globalCompositeOperation = "multiply"; context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height); context.globalCompositeOperation = "destination-atop"; context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height); }; PIXI.CanvasTinter.tintWithPerPixel = function(texture, color, canvas) { var context = canvas.getContext("2d"); var crop = texture.crop; canvas.width = crop.width; canvas.height = crop.height; context.globalCompositeOperation = "copy"; context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height); var rgbValues = PIXI.hex2rgb(color); var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2]; var pixelData = context.getImageData(0, 0, crop.width, crop.height); var pixels = pixelData.data; for (var i = 0; i < pixels.length; i += 4) { pixels[i + 0] *= r; pixels[i + 1] *= g; pixels[i + 2] *= b; if (!PIXI.CanvasTinter.canHandleAlpha) { var alpha = pixels[i + 3]; pixels[i + 0] /= 255 / alpha; pixels[i + 1] /= 255 / alpha; pixels[i + 2] /= 255 / alpha; } } }; PIXI.CanvasTinter.checkInverseAlpha = function() { var canvas = new PIXI.CanvasBuffer(2, 1); canvas.context.fillStyle = "rgba(10, 20, 30, 0.5)"; canvas.context.fillRect(0, 0, 1, 1); var s1 = canvas.context.getImageData(0, 0, 1, 1); if (s1 === null || s1.data.length === 0) { return false; } canvas.context.putImageData(s1, 1, 0); var s2 = canvas.context.getImageData(1, 0, 1, 1); return (s2.data[0] === s1.data[0] && s2.data[1] === s1.data[1] && s2.data[2] === s1.data[2] && s2.data[3] === s1.data[3]); }; PIXI.CanvasTinter.canHandleAlpha = PIXI.CanvasTinter.checkInverseAlpha(); PIXI.CanvasTinter.canUseMultiply = PIXI.canUseNewCanvasBlendModes(); PIXI.CanvasTinter.tintMethod = PIXI.CanvasTinter.canUseMultiply ? PIXI.CanvasTinter.tintWithMultiply :  PIXI.CanvasTinter.tintWithPerPixel; PIXI.CanvasRenderer = function (game) { this.game = game; if (!PIXI.defaultRenderer) { PIXI.defaultRenderer = this; } this.type = PIXI.CANVAS_RENDERER; this.resolution = game.resolution; this.clearBeforeRender = game.clearBeforeRender; this.transparent = game.transparent; this.autoResize = false; this.width = game.width * this.resolution; this.height = game.height * this.resolution; this.view = game.canvas; this.context = this.view.getContext("2d", { alpha: this.transparent } ); this.refresh = true; this.count = 0; this.maskManager = new PIXI.CanvasMaskManager(); this.renderSession = { context: this.context, maskManager: this.maskManager, scaleMode: null, smoothProperty: null, roundPixels: false }; this.mapBlendModes(); this.resize(this.width, this.height); }; PIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer; PIXI.CanvasRenderer.prototype.render = function (root) { this.context.setTransform(1, 0, 0, 1, 0, 0); this.context.globalAlpha = 1; this.renderSession.currentBlendMode = 0; this.renderSession.shakeX = this.game.camera._shake.x; this.renderSession.shakeY = this.game.camera._shake.y; this.context.globalCompositeOperation = 'source-over'; if (navigator.isCocoonJS && this.view.screencanvas) { this.context.fillStyle = "black"; this.context.clear(); } if (this.clearBeforeRender) { if (this.transparent) { this.context.clearRect(0, 0, this.width, this.height); } else if (root._bgColor) { this.context.fillStyle = root._bgColor.rgba; this.context.fillRect(0, 0, this.width , this.height); } } this.renderDisplayObject(root); }; PIXI.CanvasRenderer.prototype.destroy = function (removeView) { if (removeView === undefined) { removeView = true; } if (removeView && this.view.parent) { this.view.parent.removeChild(this.view); } this.view = null; this.context = null; this.maskManager = null; this.renderSession = null; }; PIXI.CanvasRenderer.prototype.resize = function (width, height) { this.width = width * this.resolution; this.height = height * this.resolution; this.view.width = this.width; this.view.height = this.height; if (this.autoResize) { this.view.style.width = this.width / this.resolution + "px"; this.view.style.height = this.height / this.resolution + "px"; } if (this.renderSession.smoothProperty) { this.context[this.renderSession.smoothProperty] = (this.renderSession.scaleMode === PIXI.scaleModes.LINEAR); } }; PIXI.CanvasRenderer.prototype.renderDisplayObject = function (displayObject, context, matrix) { this.renderSession.context = context || this.context; this.renderSession.resolution = this.resolution; displayObject._renderCanvas(this.renderSession, matrix); }; PIXI.CanvasRenderer.prototype.mapBlendModes = function () { if (!PIXI.blendModesCanvas) { var b = []; var modes = PIXI.blendModes; var useNew = PIXI.canUseNewCanvasBlendModes(); b[modes.NORMAL] = 'source-over'; b[modes.ADD] = 'lighter'; b[modes.MULTIPLY] = (useNew) ? 'multiply' : 'source-over'; b[modes.SCREEN] = (useNew) ? 'screen' : 'source-over'; b[modes.OVERLAY] = (useNew) ? 'overlay' : 'source-over'; b[modes.DARKEN] = (useNew) ? 'darken' : 'source-over'; b[modes.LIGHTEN] = (useNew) ? 'lighten' : 'source-over'; b[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : 'source-over'; b[modes.COLOR_BURN] = (useNew) ? 'color-burn' : 'source-over'; b[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : 'source-over'; b[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : 'source-over'; b[modes.DIFFERENCE] = (useNew) ? 'difference' : 'source-over'; b[modes.EXCLUSION] = (useNew) ? 'exclusion' : 'source-over'; b[modes.HUE] = (useNew) ? 'hue' : 'source-over'; b[modes.SATURATION] = (useNew) ? 'saturation' : 'source-over'; b[modes.COLOR] = (useNew) ? 'color' : 'source-over'; b[modes.LUMINOSITY] = (useNew) ? 'luminosity' : 'source-over'; PIXI.blendModesCanvas = b; } }; PIXI.BaseTexture = function(source, scaleMode) { this.resolution = 1; this.width = 100; this.height = 100; this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT; this.hasLoaded = false; this.source = source; this.premultipliedAlpha = true; this._glTextures = []; this.mipmap = false; this._dirty = [true, true, true, true]; if (!source) { return; } if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) { this.hasLoaded = true; this.width = this.source.naturalWidth || this.source.width; this.height = this.source.naturalHeight || this.source.height; this.dirty(); } this.skipRender = false; this._powerOf2 = false; }; PIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture; PIXI.BaseTexture.prototype.forceLoaded = function(width, height) { this.hasLoaded = true; this.width = width; this.height = height; this.dirty(); }; PIXI.BaseTexture.prototype.destroy = function() { if (this.source) { PIXI.CanvasPool.removeByCanvas(this.source); } this.source = null; this.unloadFromGPU(); }; PIXI.BaseTexture.prototype.updateSourceImage = function(newSrc) { console.warn("PIXI.BaseTexture.updateSourceImage is deprecated. Use Phaser.Sprite.loadTexture instead."); }; PIXI.BaseTexture.prototype.dirty = function() { for (var i = 0; i < this._glTextures.length; i++) { this._dirty[i] = true; } }; PIXI.BaseTexture.prototype.unloadFromGPU = function() { this.dirty(); for (var i = this._glTextures.length - 1; i >= 0; i--) { var glTexture = this._glTextures[i]; var gl = PIXI.glContexts[i]; if(gl && glTexture) { gl.deleteTexture(glTexture); } } this._glTextures.length = 0; this.dirty(); }; PIXI.BaseTexture.fromCanvas = function(canvas, scaleMode) { if (canvas.width === 0) { canvas.width = 1; } if (canvas.height === 0) { canvas.height = 1; } return new PIXI.BaseTexture(canvas, scaleMode); }; PIXI.TextureSilentFail = false; PIXI.Texture = function(baseTexture, frame, crop, trim) { this.noFrame = false; if (!frame) { this.noFrame = true; frame = new PIXI.Rectangle(0,0,1,1); } if (baseTexture instanceof PIXI.Texture) { baseTexture = baseTexture.baseTexture; } this.baseTexture = baseTexture; this.frame = frame; this.trim = trim; this.valid = false; this.isTiling = false; this.requiresUpdate = false; this.requiresReTint = false; this._uvs = null; this.width = 0; this.height = 0; this.crop = crop || new PIXI.Rectangle(0, 0, 1, 1); if (baseTexture.hasLoaded) { if (this.noFrame) frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height); this.setFrame(frame); } }; PIXI.Texture.prototype.constructor = PIXI.Texture; PIXI.Texture.prototype.onBaseTextureLoaded = function() { var baseTexture = this.baseTexture; if (this.noFrame) { this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height); } this.setFrame(this.frame); }; PIXI.Texture.prototype.destroy = function(destroyBase) { if (destroyBase) this.baseTexture.destroy(); this.valid = false; }; PIXI.Texture.prototype.setFrame = function(frame) { this.noFrame = false; this.frame = frame; this.width = frame.width; this.height = frame.height; this.crop.x = frame.x; this.crop.y = frame.y; this.crop.width = frame.width; this.crop.height = frame.height; if (!this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)) { if (!PIXI.TextureSilentFail) { throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this); } this.valid = false; return; } this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded; if (this.trim) { this.width = this.trim.width; this.height = this.trim.height; this.frame.width = this.trim.width; this.frame.height = this.trim.height; } if (this.valid) this._updateUvs(); }; PIXI.Texture.prototype._updateUvs = function() { if(!this._uvs)this._uvs = new PIXI.TextureUvs(); var frame = this.crop; var tw = this.baseTexture.width; var th = this.baseTexture.height; this._uvs.x0 = frame.x / tw; this._uvs.y0 = frame.y / th; this._uvs.x1 = (frame.x + frame.width) / tw; this._uvs.y1 = frame.y / th; this._uvs.x2 = (frame.x + frame.width) / tw; this._uvs.y2 = (frame.y + frame.height) / th; this._uvs.x3 = frame.x / tw; this._uvs.y3 = (frame.y + frame.height) / th; }; PIXI.Texture.fromCanvas = function(canvas, scaleMode) { var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode); return new PIXI.Texture(baseTexture); }; PIXI.TextureUvs = function() { this.x0 = 0; this.y0 = 0; this.x1 = 0; this.y1 = 0; this.x2 = 0; this.y2 = 0; this.x3 = 0; this.y3 = 0; }; PIXI.RenderTexture = function(width, height, renderer, scaleMode, resolution) { this.width = width || 100; this.height = height || 100; this.resolution = resolution || 1; this.frame = new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution); this.crop = new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution); this.baseTexture = new PIXI.BaseTexture(); this.baseTexture.width = this.width * this.resolution; this.baseTexture.height = this.height * this.resolution; this.baseTexture._glTextures = []; this.baseTexture.resolution = this.resolution; this.baseTexture.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT; this.baseTexture.hasLoaded = true; PIXI.Texture.call(this, this.baseTexture, new PIXI.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution) ); this.renderer = renderer || PIXI.defaultRenderer; if (this.renderer.type === PIXI.WEBGL_RENDERER) { var gl = this.renderer.gl; this.baseTexture._dirty[gl.id] = false; this.textureBuffer = new PIXI.FilterTexture(gl, this.width, this.height, this.baseTexture.scaleMode); this.baseTexture._glTextures[gl.id] =  this.textureBuffer.texture; this.render = this.renderWebGL; this.projection = new PIXI.Point(this.width * 0.5, -this.height * 0.5); } else { this.render = this.renderCanvas; this.textureBuffer = new PIXI.CanvasBuffer(this.width * this.resolution, this.height * this.resolution); this.baseTexture.source = this.textureBuffer.canvas; } this.valid = true; this._updateUvs(); }; PIXI.RenderTexture.prototype = Object.create(PIXI.Texture.prototype); PIXI.RenderTexture.prototype.constructor = PIXI.RenderTexture; PIXI.RenderTexture.prototype.resize = function(width, height, updateBase) { if (width === this.width && height === this.height)return; this.valid = (width > 0 && height > 0); this.width = width; this.height = height; this.frame.width = this.crop.width = width * this.resolution; this.frame.height = this.crop.height = height * this.resolution; if (updateBase) { this.baseTexture.width = this.width * this.resolution; this.baseTexture.height = this.height * this.resolution; } if (this.renderer.type === PIXI.WEBGL_RENDERER) { this.projection.x = this.width / 2; this.projection.y = -this.height / 2; } if(!this.valid)return; this.textureBuffer.resize(this.width, this.height); }; PIXI.RenderTexture.prototype.clear = function() { if (!this.valid) { return; } if (this.renderer.type === PIXI.WEBGL_RENDERER) { this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer); } this.textureBuffer.clear(); }; PIXI.RenderTexture.prototype.renderWebGL = function(displayObject, matrix, clear) { if (!this.valid || displayObject.alpha === 0) { return; } var wt = displayObject.worldTransform; wt.identity(); wt.translate(0, this.projection.y * 2); if (matrix) { wt.append(matrix); } wt.scale(1, -1); for (var i = 0; i < displayObject.children.length; i++) { displayObject.children[i].updateTransform(); } var gl = this.renderer.gl; gl.viewport(0, 0, this.width * this.resolution, this.height * this.resolution); gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer ); if (clear) { this.textureBuffer.clear(); } this.renderer.spriteBatch.dirty = true; this.renderer.renderDisplayObject(displayObject, this.projection, this.textureBuffer.frameBuffer, matrix); this.renderer.spriteBatch.dirty = true; }; PIXI.RenderTexture.prototype.renderCanvas = function(displayObject, matrix, clear) { if (!this.valid || displayObject.alpha === 0) { return; } var wt = displayObject.worldTransform; wt.identity(); if (matrix) { wt.append(matrix); } for (var i = 0; i < displayObject.children.length; i++) { displayObject.children[i].updateTransform(); } if (clear) { this.textureBuffer.clear(); } var realResolution = this.renderer.resolution; this.renderer.resolution = this.resolution; this.renderer.renderDisplayObject(displayObject, this.textureBuffer.context, matrix); this.renderer.resolution = realResolution; }; PIXI.RenderTexture.prototype.getImage = function() { var image = new Image(); image.src = this.getBase64(); return image; }; PIXI.RenderTexture.prototype.getBase64 = function() { return this.getCanvas().toDataURL(); }; PIXI.RenderTexture.prototype.getCanvas = function() { if (this.renderer.type === PIXI.WEBGL_RENDERER) { var gl =  this.renderer.gl; var width = this.textureBuffer.width; var height = this.textureBuffer.height; var webGLPixels = new Uint8Array(4 * width * height); gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer); gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels); gl.bindFramebuffer(gl.FRAMEBUFFER, null); var tempCanvas = new PIXI.CanvasBuffer(width, height); var canvasData = tempCanvas.context.getImageData(0, 0, width, height); canvasData.data.set(webGLPixels); tempCanvas.context.putImageData(canvasData, 0, 0); return tempCanvas.canvas; } else { return this.textureBuffer.canvas; } }; PIXI.AbstractFilter = function(fragmentSrc, uniforms) { this.passes = [this]; this.shaders = []; this.dirty = true; this.padding = 0; this.uniforms = uniforms || {}; this.fragmentSrc = fragmentSrc || []; }; PIXI.AbstractFilter.prototype.constructor = PIXI.AbstractFilter; PIXI.AbstractFilter.prototype.syncUniforms = function() { for(var i=0,j=this.shaders.length; i<j; i++) { this.shaders[i].dirty = true; } }; PIXI.Strip = function(texture) { PIXI.DisplayObjectContainer.call( this ); this.texture = texture; this.uvs = new PIXI.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]); this.vertices = new PIXI.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]); this.colors = new PIXI.Float32Array([1, 1, 1, 1]); this.indices = new PIXI.Uint16Array([0, 1, 2, 3]); this.dirty = true; this.blendMode = PIXI.blendModes.NORMAL; this.canvasPadding = 0; this.drawMode = PIXI.Strip.DrawModes.TRIANGLE_STRIP; }; PIXI.Strip.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); PIXI.Strip.prototype.constructor = PIXI.Strip; PIXI.Strip.prototype._renderWebGL = function(renderSession) { if(!this.visible || this.alpha <= 0)return; renderSession.spriteBatch.stop(); if(!this._vertexBuffer)this._initWebGL(renderSession); renderSession.shaderManager.setShader(renderSession.shaderManager.stripShader); this._renderStrip(renderSession); renderSession.spriteBatch.start(); }; PIXI.Strip.prototype._initWebGL = function(renderSession) { var gl = renderSession.gl; this._vertexBuffer = gl.createBuffer(); this._indexBuffer = gl.createBuffer(); this._uvBuffer = gl.createBuffer(); this._colorBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer); gl.bufferData(gl.ARRAY_BUFFER,  this.uvs, gl.STATIC_DRAW); gl.bindBuffer(gl.ARRAY_BUFFER, this._colorBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.colors, gl.STATIC_DRAW); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW); }; PIXI.Strip.prototype._renderStrip = function(renderSession) { var gl = renderSession.gl; var projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.stripShader; var drawMode = this.drawMode === PIXI.Strip.DrawModes.TRIANGLE_STRIP ? gl.TRIANGLE_STRIP : gl.TRIANGLES; renderSession.blendModeManager.setBlendMode(this.blendMode); gl.uniformMatrix3fv(shader.translationMatrix, false, this.worldTransform.toArray(true)); gl.uniform2f(shader.projectionVector, projection.x, -projection.y); gl.uniform2f(shader.offsetVector, -offset.x, -offset.y); gl.uniform1f(shader.alpha, this.worldAlpha); if(!this.dirty) { gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer); gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer); gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0); gl.activeTexture(gl.TEXTURE0); if(this.texture.baseTexture._dirty[gl.id]) { renderSession.renderer.updateTexture(this.texture.baseTexture); } else { gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id]); } gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer); } else { this.dirty = false; gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0); gl.bindBuffer(gl.ARRAY_BUFFER, this._uvBuffer); gl.bufferData(gl.ARRAY_BUFFER, this.uvs, gl.STATIC_DRAW); gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0); gl.activeTexture(gl.TEXTURE0); if(this.texture.baseTexture._dirty[gl.id]) { renderSession.renderer.updateTexture(this.texture.baseTexture); } else { gl.bindTexture(gl.TEXTURE_2D, this.texture.baseTexture._glTextures[gl.id]); } gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW); } gl.drawElements(drawMode, this.indices.length, gl.UNSIGNED_SHORT, 0); }; PIXI.Strip.prototype._renderCanvas = function(renderSession) { var context = renderSession.context; var transform = this.worldTransform; var tx = (transform.tx * renderSession.resolution) + renderSession.shakeX; var ty = (transform.ty * renderSession.resolution) + renderSession.shakeY; if (renderSession.roundPixels) { context.setTransform(transform.a, transform.b, transform.c, transform.d, tx | 0, ty | 0); } else { context.setTransform(transform.a, transform.b, transform.c, transform.d, tx, ty); } if (this.drawMode === PIXI.Strip.DrawModes.TRIANGLE_STRIP) { this._renderCanvasTriangleStrip(context); } else { this._renderCanvasTriangles(context); } }; PIXI.Strip.prototype._renderCanvasTriangleStrip = function(context) { var vertices = this.vertices; var uvs = this.uvs; var length = vertices.length / 2; this.count++; for (var i = 0; i < length - 2; i++) { var index = i * 2; this._renderCanvasDrawTriangle(context, vertices, uvs, index, (index + 2), (index + 4)); } }; PIXI.Strip.prototype._renderCanvasTriangles = function(context) { var vertices = this.vertices; var uvs = this.uvs; var indices = this.indices; var length = indices.length; this.count++; for (var i = 0; i < length; i += 3) { var index0 = indices[i] * 2, index1 = indices[i + 1] * 2, index2 = indices[i + 2] * 2; this._renderCanvasDrawTriangle(context, vertices, uvs, index0, index1, index2); } }; PIXI.Strip.prototype._renderCanvasDrawTriangle = function(context, vertices, uvs, index0, index1, index2) { var textureSource = this.texture.baseTexture.source; var textureWidth = this.texture.width; var textureHeight = this.texture.height; var x0 = vertices[index0], x1 = vertices[index1], x2 = vertices[index2]; var y0 = vertices[index0 + 1], y1 = vertices[index1 + 1], y2 = vertices[index2 + 1]; var u0 = uvs[index0] * textureWidth, u1 = uvs[index1] * textureWidth, u2 = uvs[index2] * textureWidth; var v0 = uvs[index0 + 1] * textureHeight, v1 = uvs[index1 + 1] * textureHeight, v2 = uvs[index2 + 1] * textureHeight; if (this.canvasPadding > 0) { var paddingX = this.canvasPadding / this.worldTransform.a; var paddingY = this.canvasPadding / this.worldTransform.d; var centerX = (x0 + x1 + x2) / 3; var centerY = (y0 + y1 + y2) / 3; var normX = x0 - centerX; var normY = y0 - centerY; var dist = Math.sqrt(normX * normX + normY * normY); x0 = centerX + (normX / dist) * (dist + paddingX); y0 = centerY + (normY / dist) * (dist + paddingY); normX = x1 - centerX; normY = y1 - centerY; dist = Math.sqrt(normX * normX + normY * normY); x1 = centerX + (normX / dist) * (dist + paddingX); y1 = centerY + (normY / dist) * (dist + paddingY); normX = x2 - centerX; normY = y2 - centerY; dist = Math.sqrt(normX * normX + normY * normY); x2 = centerX + (normX / dist) * (dist + paddingX); y2 = centerY + (normY / dist) * (dist + paddingY); } context.save(); context.beginPath(); context.moveTo(x0, y0); context.lineTo(x1, y1); context.lineTo(x2, y2); context.closePath(); context.clip(); var delta =  (u0 * v1)      + (v0 * u2)      + (u1 * v2)      - (v1 * u2)      - (v0 * u1)      - (u0 * v2); var deltaA = (x0 * v1)      + (v0 * x2)      + (x1 * v2)      - (v1 * x2)      - (v0 * x1)      - (x0 * v2); var deltaB = (u0 * x1)      + (x0 * u2)      + (u1 * x2)      - (x1 * u2)      - (x0 * u1)      - (u0 * x2); var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2); var deltaD = (y0 * v1)      + (v0 * y2)      + (y1 * v2)      - (v1 * y2)      - (v0 * y1)      - (y0 * v2); var deltaE = (u0 * y1)      + (y0 * u2)      + (u1 * y2)      - (y1 * u2)      - (y0 * u1)      - (u0 * y2); var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2); context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta); context.drawImage(textureSource, 0, 0); context.restore(); }; PIXI.Strip.prototype.renderStripFlat = function(strip) { var context = this.context; var vertices = strip.vertices; var length = vertices.length/2; this.count++; context.beginPath(); for (var i=1; i < length-2; i++) { var index = i*2; var x0 = vertices[index],   x1 = vertices[index+2], x2 = vertices[index+4]; var y0 = vertices[index+1], y1 = vertices[index+3], y2 = vertices[index+5]; context.moveTo(x0, y0); context.lineTo(x1, y1); context.lineTo(x2, y2); } context.fillStyle = '#FF0000'; context.fill(); context.closePath(); }; PIXI.Strip.prototype.onTextureUpdate = function() { this.updateFrame = true; }; PIXI.Strip.prototype.getBounds = function(matrix) { var worldTransform = matrix || this.worldTransform; var a = worldTransform.a; var b = worldTransform.b; var c = worldTransform.c; var d = worldTransform.d; var tx = worldTransform.tx; var ty = worldTransform.ty; var maxX = -Infinity; var maxY = -Infinity; var minX = Infinity; var minY = Infinity; var vertices = this.vertices; for (var i = 0, n = vertices.length; i < n; i += 2) { var rawX = vertices[i], rawY = vertices[i + 1]; var x = (a * rawX) + (c * rawY) + tx; var y = (d * rawY) + (b * rawX) + ty; minX = x < minX ? x : minX; minY = y < minY ? y : minY; maxX = x > maxX ? x : maxX; maxY = y > maxY ? y : maxY; } if (minX === -Infinity || maxY === Infinity) { return PIXI.EmptyRectangle; } var bounds = this._bounds; bounds.x = minX; bounds.width = maxX - minX; bounds.y = minY; bounds.height = maxY - minY; this._currentBounds = bounds; return bounds; }; PIXI.Strip.DrawModes = { TRIANGLE_STRIP: 0, TRIANGLES: 1 }; PIXI.Rope = function(texture, points) { PIXI.Strip.call( this, texture ); this.points = points; this.vertices = new PIXI.Float32Array(points.length * 4); this.uvs = new PIXI.Float32Array(points.length * 4); this.colors = new PIXI.Float32Array(points.length * 2); this.indices = new PIXI.Uint16Array(points.length * 2); this.refresh(); }; PIXI.Rope.prototype = Object.create( PIXI.Strip.prototype ); PIXI.Rope.prototype.constructor = PIXI.Rope; PIXI.Rope.prototype.refresh = function() { var points = this.points; if(points.length < 1) return; var uvs = this.uvs; var lastPoint = points[0]; var indices = this.indices; var colors = this.colors; this.count-=0.2; uvs[0] = 0; uvs[1] = 0; uvs[2] = 0; uvs[3] = 1; colors[0] = 1; colors[1] = 1; indices[0] = 0; indices[1] = 1; var total = points.length, point, index, amount; for (var i = 1; i < total; i++) { point = points[i]; index = i * 4; amount = i / (total-1); if(i%2) { uvs[index] = amount; uvs[index+1] = 0; uvs[index+2] = amount; uvs[index+3] = 1; } else { uvs[index] = amount; uvs[index+1] = 0; uvs[index+2] = amount; uvs[index+3] = 1; } index = i * 2; colors[index] = 1; colors[index+1] = 1; index = i * 2; indices[index] = index; indices[index + 1] = index + 1; lastPoint = point; } }; PIXI.Rope.prototype.updateTransform = function() { var points = this.points; if(points.length < 1)return; var lastPoint = points[0]; var nextPoint; var perp = {x:0, y:0}; this.count-=0.2; var vertices = this.vertices; var total = points.length, point, index, ratio, perpLength, num; for (var i = 0; i < total; i++) { point = points[i]; index = i * 4; if(i < points.length-1) { nextPoint = points[i+1]; } else { nextPoint = point; } perp.y = -(nextPoint.x - lastPoint.x); perp.x = nextPoint.y - lastPoint.y; ratio = (1 - (i / (total-1))) * 10; if(ratio > 1) ratio = 1; perpLength = Math.sqrt(perp.x * perp.x + perp.y * perp.y); num = this.texture.height / 2; perp.x /= perpLength; perp.y /= perpLength; perp.x *= num; perp.y *= num; vertices[index] = point.x + perp.x; vertices[index+1] = point.y + perp.y; vertices[index+2] = point.x - perp.x; vertices[index+3] = point.y - perp.y; lastPoint = point; } PIXI.DisplayObjectContainer.prototype.updateTransform.call( this ); }; PIXI.Rope.prototype.setTexture = function(texture) { this.texture = texture; }; PIXI.TilingSprite = function(texture, width, height) { PIXI.Sprite.call(this, texture); this._width = width || 128; this._height = height || 128; this.tileScale = new PIXI.Point(1, 1); this.tileScaleOffset = new PIXI.Point(1, 1); this.tilePosition = new PIXI.Point(); this.renderable = true; this.tint = 0xFFFFFF; this.textureDebug = false; this.blendMode = PIXI.blendModes.NORMAL; this.canvasBuffer = null; this.tilingTexture = null; this.tilePattern = null; this.refreshTexture = true; this.frameWidth = 0; this.frameHeight = 0; }; PIXI.TilingSprite.prototype = Object.create(PIXI.Sprite.prototype); PIXI.TilingSprite.prototype.constructor = PIXI.TilingSprite; PIXI.TilingSprite.prototype.setTexture = function(texture) { if (this.texture !== texture) { this.texture = texture; this.refreshTexture = true; this.cachedTint = 0xFFFFFF; } }; PIXI.TilingSprite.prototype._renderWebGL = function(renderSession) { if (!this.visible || !this.renderable || this.alpha === 0) { return; } if (this._mask) { renderSession.spriteBatch.stop(); renderSession.maskManager.pushMask(this.mask, renderSession); renderSession.spriteBatch.start(); } if (this._filters) { renderSession.spriteBatch.flush(); renderSession.filterManager.pushFilter(this._filterBlock); } if (this.refreshTexture) { this.generateTilingTexture(true, renderSession); if (this.tilingTexture) { if (this.tilingTexture.needsUpdate) { renderSession.renderer.updateTexture(this.tilingTexture.baseTexture); this.tilingTexture.needsUpdate = false; } } else { return; } } renderSession.spriteBatch.renderTilingSprite(this); for (var i = 0; i < this.children.length; i++) { this.children[i]._renderWebGL(renderSession); } renderSession.spriteBatch.stop(); if (this._filters) { renderSession.filterManager.popFilter(); } if (this._mask) { renderSession.maskManager.popMask(this._mask, renderSession); } renderSession.spriteBatch.start(); }; PIXI.TilingSprite.prototype._renderCanvas = function(renderSession) { if (!this.visible || !this.renderable || this.alpha === 0) { return; } var context = renderSession.context; if (this._mask) { renderSession.maskManager.pushMask(this._mask, renderSession); } context.globalAlpha = this.worldAlpha; var wt = this.worldTransform; var resolution = renderSession.resolution; var tx = (wt.tx * resolution) + renderSession.shakeX; var ty = (wt.ty * resolution) + renderSession.shakeY; context.setTransform(wt.a * resolution, wt.b * resolution, wt.c * resolution, wt.d * resolution, tx, ty); if (this.refreshTexture) { this.generateTilingTexture(false, renderSession); if (this.tilingTexture) { this.tilePattern = context.createPattern(this.tilingTexture.baseTexture.source, 'repeat'); } else { return; } } var sessionBlendMode = renderSession.currentBlendMode; if (this.blendMode !== renderSession.currentBlendMode) { renderSession.currentBlendMode = this.blendMode; context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode]; } var tilePosition = this.tilePosition; var tileScale = this.tileScale; tilePosition.x %= this.tilingTexture.baseTexture.width; tilePosition.y %= this.tilingTexture.baseTexture.height; context.scale(tileScale.x, tileScale.y); context.translate(tilePosition.x + (this.anchor.x * -this._width), tilePosition.y + (this.anchor.y * -this._height)); context.fillStyle = this.tilePattern; var tx = -tilePosition.x; var ty = -tilePosition.y; var tw = this._width / tileScale.x; var th = this._height / tileScale.y; if (renderSession.roundPixels) { tx |= 0; ty |= 0; tw |= 0; th |= 0; } context.fillRect(tx, ty, tw, th); context.scale(1 / tileScale.x, 1 / tileScale.y); context.translate(-tilePosition.x + (this.anchor.x * this._width), -tilePosition.y + (this.anchor.y * this._height)); if (this._mask) { renderSession.maskManager.popMask(renderSession); } for (var i = 0; i < this.children.length; i++) { this.children[i]._renderCanvas(renderSession); } if (sessionBlendMode !== this.blendMode) { renderSession.currentBlendMode = sessionBlendMode; context.globalCompositeOperation = PIXI.blendModesCanvas[sessionBlendMode]; } }; PIXI.TilingSprite.prototype.onTextureUpdate = function() { }; PIXI.TilingSprite.prototype.generateTilingTexture = function(forcePowerOfTwo, renderSession) { if (!this.texture.baseTexture.hasLoaded) { return; } var texture = this.texture; var frame = texture.frame; var targetWidth = this._frame.sourceSizeW || this._frame.width; var targetHeight = this._frame.sourceSizeH || this._frame.height; var dx = 0; var dy = 0; if (this._frame.trimmed) { dx = this._frame.spriteSourceSizeX; dy = this._frame.spriteSourceSizeY; } if (forcePowerOfTwo) { targetWidth = PIXI.getNextPowerOfTwo(targetWidth); targetHeight = PIXI.getNextPowerOfTwo(targetHeight); } if (this.canvasBuffer) { this.canvasBuffer.resize(targetWidth, targetHeight); this.tilingTexture.baseTexture.width = targetWidth; this.tilingTexture.baseTexture.height = targetHeight; this.tilingTexture.needsUpdate = true; } else { this.canvasBuffer = new PIXI.CanvasBuffer(targetWidth, targetHeight); this.tilingTexture = PIXI.Texture.fromCanvas(this.canvasBuffer.canvas); this.tilingTexture.isTiling = true; this.tilingTexture.needsUpdate = true; } if (this.textureDebug) { this.canvasBuffer.context.strokeStyle = '#00ff00'; this.canvasBuffer.context.strokeRect(0, 0, targetWidth, targetHeight); } var w = texture.crop.width; var h = texture.crop.height; if (w !== targetWidth || h !== targetHeight) { w = targetWidth; h = targetHeight; } this.canvasBuffer.context.drawImage(texture.baseTexture.source, texture.crop.x, texture.crop.y, texture.crop.width, texture.crop.height, dx, dy, w, h); this.tileScaleOffset.x = frame.width / targetWidth; this.tileScaleOffset.y = frame.height / targetHeight; this.refreshTexture = false; this.tilingTexture.baseTexture._powerOf2 = true; }; PIXI.TilingSprite.prototype.getBounds = function() { var width = this._width; var height = this._height; var w0 = width * (1-this.anchor.x); var w1 = width * -this.anchor.x; var h0 = height * (1-this.anchor.y); var h1 = height * -this.anchor.y; var worldTransform = this.worldTransform; var a = worldTransform.a; var b = worldTransform.b; var c = worldTransform.c; var d = worldTransform.d; var tx = worldTransform.tx; var ty = worldTransform.ty; var x1 = a * w1 + c * h1 + tx; var y1 = d * h1 + b * w1 + ty; var x2 = a * w0 + c * h1 + tx; var y2 = d * h1 + b * w0 + ty; var x3 = a * w0 + c * h0 + tx; var y3 = d * h0 + b * w0 + ty; var x4 =  a * w1 + c * h0 + tx; var y4 =  d * h0 + b * w1 + ty; var maxX = -Infinity; var maxY = -Infinity; var minX = Infinity; var minY = Infinity; minX = x1 < minX ? x1 : minX; minX = x2 < minX ? x2 : minX; minX = x3 < minX ? x3 : minX; minX = x4 < minX ? x4 : minX; minY = y1 < minY ? y1 : minY; minY = y2 < minY ? y2 : minY; minY = y3 < minY ? y3 : minY; minY = y4 < minY ? y4 : minY; maxX = x1 > maxX ? x1 : maxX; maxX = x2 > maxX ? x2 : maxX; maxX = x3 > maxX ? x3 : maxX; maxX = x4 > maxX ? x4 : maxX; maxY = y1 > maxY ? y1 : maxY; maxY = y2 > maxY ? y2 : maxY; maxY = y3 > maxY ? y3 : maxY; maxY = y4 > maxY ? y4 : maxY; var bounds = this._bounds; bounds.x = minX; bounds.width = maxX - minX; bounds.y = minY; bounds.height = maxY - minY; this._currentBounds = bounds; return bounds; }; PIXI.TilingSprite.prototype.destroy = function () { PIXI.Sprite.prototype.destroy.call(this); if (this.canvasBuffer) { this.canvasBuffer.destroy(); this.canvasBuffer = null; } this.tileScale = null; this.tileScaleOffset = null; this.tilePosition = null; if (this.tilingTexture) { this.tilingTexture.destroy(true); this.tilingTexture = null; } }; Object.defineProperty(PIXI.TilingSprite.prototype, 'width', { get: function() { return this._width; }, set: function(value) { this._width = value; } }); Object.defineProperty(PIXI.TilingSprite.prototype, 'height', { get: function() { return  this._height; }, set: function(value) { this._height = value; } }); module.exports = PIXI;