import PIXI from './pixi-wx.js'; import Phaser from './phaser-wx-main.js'; Phaser.Utils.Debug = function (game) { this.game = game; this.sprite = null; this.bmd = null; this.canvas = null; this.context = null; this.font = '14px Courier'; this.columnWidth = 100; this.lineHeight = 16; this.renderShadow = true; this.currentX = 0; this.currentY = 0; this.currentAlpha = 1; this.dirty = false; }; Phaser.Utils.Debug.prototype = { boot: function () { if (this.game.renderType === Phaser.CANVAS) { this.context = this.game.context; } else { this.bmd = new Phaser.BitmapData(this.game, '__DEBUG', this.game.width, this.game.height, true); this.sprite = this.game.make.image(0, 0, this.bmd); this.game.stage.addChild(this.sprite); this.game.scale.onSizeChange.add(this.resize, this); this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height); this.context = this.canvas.getContext('2d'); } }, resize: function (scaleManager, width, height) { this.bmd.resize(width, height); this.canvas.width = width; this.canvas.height = height; }, preUpdate: function () { if (this.dirty && this.sprite) { this.bmd.clear(); this.bmd.draw(this.canvas, 0, 0); this.context.clearRect(0, 0, this.game.width, this.game.height); this.dirty = false; } }, reset: function () { if (this.context) { this.context.clearRect(0, 0, this.game.width, this.game.height); } if (this.sprite) { this.bmd.clear(); } }, start: function (x, y, color, columnWidth) { if (typeof x !== 'number') { x = 0; } if (typeof y !== 'number') { y = 0; } color = color || 'rgb(255,255,255)'; if (columnWidth === undefined) { columnWidth = 0; } this.currentX = x; this.currentY = y; this.currentColor = color; this.columnWidth = columnWidth; this.dirty = true; this.context.save(); this.context.setTransform(1, 0, 0, 1, 0, 0); this.context.strokeStyle = color; this.context.fillStyle = color; this.context.font = this.font; this.context.globalAlpha = this.currentAlpha; }, stop: function () { this.context.restore(); }, line: function () { var x = this.currentX; for (var i = 0; i < arguments.length; i++) { if (this.renderShadow) { this.context.fillStyle = 'rgb(0,0,0)'; this.context.fillText(arguments[i], x + 1, this.currentY + 1); this.context.fillStyle = this.currentColor; } this.context.fillText(arguments[i], x, this.currentY); x += this.columnWidth; } this.currentY += this.lineHeight; }, soundInfo: function (sound, x, y, color) { this.start(x, y, color); this.line('Sound: ' + sound.key + ' Locked: ' + sound.game.sound.touchLocked); this.line('Is Ready?: ' + this.game.cache.isSoundReady(sound.key) + ' Pending Playback: ' + sound.pendingPlayback); this.line('Decoded: ' + sound.isDecoded + ' Decoding: ' + sound.isDecoding); this.line('Total Duration: ' + sound.totalDuration + ' Playing: ' + sound.isPlaying); this.line('Time: ' + sound.currentTime); this.line('Volume: ' + sound.volume + ' Muted: ' + sound.mute); this.line('WebAudio: ' + sound.usingWebAudio + ' Audio: ' + sound.usingAudioTag); if (sound.currentMarker !== '') { this.line('Marker: ' + sound.currentMarker + ' Duration: ' + sound.duration + ' (ms: ' + sound.durationMS + ')'); this.line('Start: ' + sound.markers[sound.currentMarker].start + ' Stop: ' + sound.markers[sound.currentMarker].stop); this.line('Position: ' + sound.position); } this.stop(); }, cameraInfo: function (camera, x, y, color) { this.start(x, y, color); this.line('Camera (' + camera.width + ' x ' + camera.height + ')'); this.line('X: ' + camera.x + ' Y: ' + camera.y); if (camera.bounds) { this.line('Bounds x: ' + camera.bounds.x + ' Y: ' + camera.bounds.y + ' w: ' + camera.bounds.width + ' h: ' + camera.bounds.height); } this.line('View x: ' + camera.view.x + ' Y: ' + camera.view.y + ' w: ' + camera.view.width + ' h: ' + camera.view.height); this.line('Total in view: ' + camera.totalInView); this.stop(); }, timer: function (timer, x, y, color) { this.start(x, y, color); this.line('Timer (running: ' + timer.running + ' expired: ' + timer.expired + ')'); this.line('Next Tick: ' + timer.next + ' Duration: ' + timer.duration); this.line('Paused: ' + timer.paused + ' Length: ' + timer.length); this.stop(); }, pointer: function (pointer, hideIfUp, downColor, upColor, color) { if (pointer == null) { return; } if (hideIfUp === undefined) { hideIfUp = false; } downColor = downColor || 'rgba(0,255,0,0.5)'; upColor = upColor || 'rgba(255,0,0,0.5)'; if (hideIfUp === true && pointer.isUp === true) { return; } this.start(pointer.x, pointer.y - 100, color); this.context.beginPath(); this.context.arc(pointer.x, pointer.y, pointer.circle.radius, 0, Math.PI * 2); if (pointer.active) { this.context.fillStyle = downColor; } else { this.context.fillStyle = upColor; } this.context.fill(); this.context.closePath(); this.context.beginPath(); this.context.moveTo(pointer.positionDown.x, pointer.positionDown.y); this.context.lineTo(pointer.position.x, pointer.position.y); this.context.lineWidth = 2; this.context.stroke(); this.context.closePath(); this.line('ID: ' + pointer.id + " Active: " + pointer.active); this.line('World X: ' + pointer.worldX + " World Y: " + pointer.worldY); this.line('Screen X: ' + pointer.x + " Screen Y: " + pointer.y + " In: " + pointer.withinGame); this.line('Duration: ' + pointer.duration + " ms"); this.line('is Down: ' + pointer.isDown + " is Up: " + pointer.isUp); this.stop(); }, spriteInputInfo: function (sprite, x, y, color) { this.start(x, y, color); this.line('Sprite Input: (' + sprite.width + ' x ' + sprite.height + ')'); this.line('x: ' + sprite.input.pointerX().toFixed(1) + ' y: ' + sprite.input.pointerY().toFixed(1)); this.line('over: ' + sprite.input.pointerOver() + ' duration: ' + sprite.input.overDuration().toFixed(0)); this.line('down: ' + sprite.input.pointerDown() + ' duration: ' + sprite.input.downDuration().toFixed(0)); this.line('just over: ' + sprite.input.justOver() + ' just out: ' + sprite.input.justOut()); this.stop(); }, key: function (key, x, y, color) { this.start(x, y, color, 150); this.line('Key:', key.keyCode, 'isDown:', key.isDown); this.line('justDown:', key.justDown, 'justUp:', key.justUp); this.line('Time Down:', key.timeDown.toFixed(0), 'duration:', key.duration.toFixed(0)); this.stop(); }, inputInfo: function (x, y, color) { this.start(x, y, color); this.line('Input'); this.line('X: ' + this.game.input.x + ' Y: ' + this.game.input.y); this.line('World X: ' + this.game.input.worldX + ' World Y: ' + this.game.input.worldY); this.line('Scale X: ' + this.game.input.scale.x.toFixed(1) + ' Scale Y: ' + this.game.input.scale.x.toFixed(1)); this.line('Screen X: ' + this.game.input.activePointer.screenX + ' Screen Y: ' + this.game.input.activePointer.screenY); this.stop(); }, spriteBounds: function (sprite, color, filled) { var bounds = sprite.getBounds(); bounds.x += this.game.camera.x; bounds.y += this.game.camera.y; this.rectangle(bounds, color, filled); }, ropeSegments: function (rope, color, filled) { var segments = rope.segments; var self = this; segments.forEach(function(segment) { self.rectangle(segment, color, filled); }, this); }, spriteInfo: function (sprite, x, y, color) { this.start(x, y, color); this.line('Sprite: ' + ' (' + sprite.width + ' x ' + sprite.height + ') anchor: ' + sprite.anchor.x + ' x ' + sprite.anchor.y); this.line('x: ' + sprite.x.toFixed(1) + ' y: ' + sprite.y.toFixed(1)); this.line('angle: ' + sprite.angle.toFixed(1) + ' rotation: ' + sprite.rotation.toFixed(1)); this.line('visible: ' + sprite.visible + ' in camera: ' + sprite.inCamera); this.line('bounds x: ' + sprite._bounds.x.toFixed(1) + ' y: ' + sprite._bounds.y.toFixed(1) + ' w: ' + sprite._bounds.width.toFixed(1) + ' h: ' + sprite._bounds.height.toFixed(1)); this.stop(); }, spriteCoords: function (sprite, x, y, color) { this.start(x, y, color, 100); if (sprite.name) { this.line(sprite.name); } this.line('x:', sprite.x.toFixed(2), 'y:', sprite.y.toFixed(2)); this.line('pos x:', sprite.position.x.toFixed(2), 'pos y:', sprite.position.y.toFixed(2)); this.line('world x:', sprite.world.x.toFixed(2), 'world y:', sprite.world.y.toFixed(2)); this.stop(); }, lineInfo: function (line, x, y, color) { this.start(x, y, color, 80); this.line('start.x:', line.start.x.toFixed(2), 'start.y:', line.start.y.toFixed(2)); this.line('end.x:', line.end.x.toFixed(2), 'end.y:', line.end.y.toFixed(2)); this.line('length:', line.length.toFixed(2), 'angle:', line.angle); this.stop(); }, pixel: function (x, y, color, size) { size = size || 2; this.start(); this.context.fillStyle = color; this.context.fillRect(x, y, size, size); this.stop(); }, geom: function (object, color, filled, forceType) { if (filled === undefined) { filled = true; } if (forceType === undefined) { forceType = 0; } color = color || 'rgba(0,255,0,0.4)'; this.start(); this.context.fillStyle = color; this.context.strokeStyle = color; if (object instanceof Phaser.Rectangle || forceType === 1) { if (filled) { this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height); } else { this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height); } } else if (object instanceof Phaser.Circle || forceType === 2) { this.context.beginPath(); this.context.arc(object.x - this.game.camera.x, object.y - this.game.camera.y, object.radius, 0, Math.PI * 2, false); this.context.closePath(); if (filled) { this.context.fill(); } else { this.context.stroke(); } } else if (object instanceof Phaser.Point || forceType === 3) { this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, 4, 4); } else if (object instanceof Phaser.Line || forceType === 4) { this.context.lineWidth = 1; this.context.beginPath(); this.context.moveTo((object.start.x + 0.5) - this.game.camera.x, (object.start.y + 0.5) - this.game.camera.y); this.context.lineTo((object.end.x + 0.5) - this.game.camera.x, (object.end.y + 0.5) - this.game.camera.y); this.context.closePath(); this.context.stroke(); } this.stop(); }, rectangle: function (object, color, filled) { if (filled === undefined) { filled = true; } color = color || 'rgba(0, 255, 0, 0.4)'; this.start(); if (filled) { this.context.fillStyle = color; this.context.fillRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height); } else { this.context.strokeStyle = color; this.context.strokeRect(object.x - this.game.camera.x, object.y - this.game.camera.y, object.width, object.height); } this.stop(); }, text: function (text, x, y, color, font) { color = color || 'rgb(255,255,255)'; font = font || '16px Courier'; this.start(); this.context.font = font; if (this.renderShadow) { this.context.fillStyle = 'rgb(0,0,0)'; this.context.fillText(text, x + 1, y + 1); } this.context.fillStyle = color; this.context.fillText(text, x, y); this.stop(); }, quadTree: function (quadtree, color) { color = color || 'rgba(255,0,0,0.3)'; this.start(); var bounds = quadtree.bounds; if (quadtree.nodes.length === 0) { this.context.strokeStyle = color; this.context.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height); this.text('size: ' + quadtree.objects.length, bounds.x + 4, bounds.y + 16, 'rgb(0,200,0)', '12px Courier'); this.context.strokeStyle = 'rgb(0,255,0)'; for (var i = 0; i < quadtree.objects.length; i++) { this.context.strokeRect(quadtree.objects[i].x, quadtree.objects[i].y, quadtree.objects[i].width, quadtree.objects[i].height); } } else { for (var i = 0; i < quadtree.nodes.length; i++) { this.quadTree(quadtree.nodes[i]); } } this.stop(); }, body: function (sprite, color, filled) { if (sprite.body) { this.start(); if (sprite.body.type === Phaser.Physics.ARCADE) { Phaser.Physics.Arcade.Body.render(this.context, sprite.body, color, filled); } else if (sprite.body.type === Phaser.Physics.NINJA) { Phaser.Physics.Ninja.Body.render(this.context, sprite.body, color, filled); } else if (sprite.body.type === Phaser.Physics.BOX2D) { Phaser.Physics.Box2D.renderBody(this.context, sprite.body, color); } this.stop(); } }, bodyInfo: function (sprite, x, y, color) { if (sprite.body) { this.start(x, y, color, 210); if (sprite.body.type === Phaser.Physics.ARCADE) { Phaser.Physics.Arcade.Body.renderBodyInfo(this, sprite.body); } else if (sprite.body.type === Phaser.Physics.BOX2D) { this.game.physics.box2d.renderBodyInfo(this, sprite.body); } this.stop(); } }, box2dWorld: function () { this.start(); this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0); this.game.physics.box2d.renderDebugDraw(this.context); this.stop(); }, box2dBody: function (body, color) { this.start(); Phaser.Physics.Box2D.renderBody(this.context, body, color); this.stop(); }, displayList: function (displayObject) { if (displayObject === undefined) { displayObject = this.game.world; } if (displayObject.hasOwnProperty('renderOrderID')) { console.log('[' + displayObject.renderOrderID + ']', displayObject); } else { console.log('[]', displayObject); } if (displayObject.children && displayObject.children.length > 0) { for (var i = 0; i < displayObject.children.length; i++) { this.game.debug.displayList(displayObject.children[i]); } } }, destroy: function () { PIXI.CanvasPool.remove(this); } }; Phaser.Utils.Debug.prototype.constructor = Phaser.Utils.Debug; Phaser.DOM = { getOffset: function (element, point) { point = point || new Phaser.Point(); var box = element.getBoundingClientRect(); var scrollTop = Phaser.DOM.scrollY || 0; var scrollLeft = Phaser.DOM.scrollX || 0; var clientTop = document.documentElement.clientTop || 0; var clientLeft = document.documentElement.clientLeft || 0; point.x = box.left + scrollLeft - clientLeft; point.y = box.top + scrollTop - clientTop; return point; }, getBounds: function (element, cushion) { if (cushion === undefined) { cushion = 0; } element = element && !element.nodeType ? element[0] : element; if (!element || element.nodeType !== 1) { return false; } else { return this.calibrate(element.getBoundingClientRect(), cushion); } }, calibrate: function (coords, cushion) { cushion = +cushion || 0; var output = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0 }; output.width = (output.right = coords.right + cushion) - (output.left = coords.left - cushion); output.height = (output.bottom = coords.bottom + cushion) - (output.top = coords.top - cushion); return output; }, getAspectRatio: function (object) { object = null == object ? this.visualBounds : 1 === object.nodeType ? this.getBounds(object) : object; var w = object['width']; var h = object['height']; if (typeof w === 'function') { w = w.call(object); } if (typeof h === 'function') { h = h.call(object); } return w / h; }, inLayoutViewport: function (element, cushion) { var r = this.getBounds(element, cushion); return !!r && r.bottom >= 0 && r.right >= 0 && r.top <= this.layoutBounds.width && r.left <= this.layoutBounds.height; }, getScreenOrientation: function (primaryFallback) { var screen = window.screen; var orientation = screen.orientation || screen.mozOrientation || screen.msOrientation; if (orientation && typeof orientation.type === 'string') { return orientation.type; } else if (typeof orientation === 'string') { return orientation; } var PORTRAIT = 'portrait-primary'; var LANDSCAPE = 'landscape-primary'; if (primaryFallback === 'screen') { return (screen.height > screen.width) ? PORTRAIT : LANDSCAPE; } else if (primaryFallback === 'viewport') { return (this.visualBounds.height > this.visualBounds.width) ? PORTRAIT : LANDSCAPE; } else if (primaryFallback === 'window.orientation' && typeof window.orientation === 'number') { return (window.orientation === 0 || window.orientation === 180) ? PORTRAIT : LANDSCAPE; } else if (window.matchMedia) { if (window.matchMedia("(orientation: portrait)").matches) { return PORTRAIT; } else if (window.matchMedia("(orientation: landscape)").matches) { return LANDSCAPE; } } return (this.visualBounds.height > this.visualBounds.width) ? PORTRAIT : LANDSCAPE; }, visualBounds: new Phaser.Rectangle(), layoutBounds: new Phaser.Rectangle(), documentBounds: new Phaser.Rectangle() }; Phaser.Device.whenReady(function (device) { var scrollX = window && ('pageXOffset' in window) ? function () { return window.pageXOffset; } : function () { return document.documentElement.scrollLeft; }; var scrollY = window && ('pageYOffset' in window) ? function () { return window.pageYOffset; } : function () { return document.documentElement.scrollTop; }; Object.defineProperty(Phaser.DOM, "scrollX", { get: scrollX }); Object.defineProperty(Phaser.DOM, "scrollY", { get: scrollY }); Object.defineProperty(Phaser.DOM.visualBounds, "x", { get: scrollX }); Object.defineProperty(Phaser.DOM.visualBounds, "y", { get: scrollY }); Object.defineProperty(Phaser.DOM.layoutBounds, "x", { value: 0 }); Object.defineProperty(Phaser.DOM.layoutBounds, "y", { value: 0 }); var treatAsDesktop = device.desktop && (document.documentElement.clientWidth <= window.innerWidth) && (document.documentElement.clientHeight <= window.innerHeight); if (treatAsDesktop) { var clientWidth = function () { return Math.max(window.innerWidth, document.documentElement.clientWidth); }; var clientHeight = function () { return Math.max(window.innerHeight, document.documentElement.clientHeight); }; Object.defineProperty(Phaser.DOM.visualBounds, "width", { get: clientWidth }); Object.defineProperty(Phaser.DOM.visualBounds, "height", { get: clientHeight }); Object.defineProperty(Phaser.DOM.layoutBounds, "width", { get: clientWidth }); Object.defineProperty(Phaser.DOM.layoutBounds, "height", { get: clientHeight }); } else { Object.defineProperty(Phaser.DOM.visualBounds, "width", { get: function () { return window.innerWidth; } }); Object.defineProperty(Phaser.DOM.visualBounds, "height", { get: function () { return window.innerHeight; } }); Object.defineProperty(Phaser.DOM.layoutBounds, "width", { get: function () { var a = document.documentElement.clientWidth; var b = window.innerWidth; return a < b ? b : a; } }); Object.defineProperty(Phaser.DOM.layoutBounds, "height", { get: function () { var a = document.documentElement.clientHeight; var b = window.innerHeight; return a < b ? b : a; } }); } Object.defineProperty(Phaser.DOM.documentBounds, "x", { value: 0 }); Object.defineProperty(Phaser.DOM.documentBounds, "y", { value: 0 }); Object.defineProperty(Phaser.DOM.documentBounds, "width", { get: function () { var d = document.documentElement; return Math.max(d.clientWidth, d.offsetWidth, d.scrollWidth); } }); Object.defineProperty(Phaser.DOM.documentBounds, "height", { get: function () { var d = document.documentElement; return Math.max(d.clientHeight, d.offsetHeight, d.scrollHeight); } }); }, null, true); Phaser.ArraySet = function (list) { this.position = 0; this.list = list || []; }; Phaser.ArraySet.prototype = { add: function (item) { if (!this.exists(item)) { this.list.push(item); } return item; }, getIndex: function (item) { return this.list.indexOf(item); }, getByKey: function (property, value) { var i = this.list.length; while (i--) { if (this.list[i][property] === value) { return this.list[i]; } } return null; }, exists: function (item) { return (this.list.indexOf(item) > -1); }, reset: function () { this.list.length = 0; }, remove: function (item) { var idx = this.list.indexOf(item); if (idx > -1) { this.list.splice(idx, 1); return item; } }, setAll: function (key, value) { var i = this.list.length; while (i--) { if (this.list[i]) { this.list[i][key] = value; } } }, callAll: function (key) { var args = Array.prototype.slice.call(arguments, 1); var i = this.list.length; while (i--) { if (this.list[i] && this.list[i][key]) { this.list[i][key].apply(this.list[i], args); } } }, removeAll: function (destroy) { if (destroy === undefined) { destroy = false; } var i = this.list.length; while (i--) { if (this.list[i]) { var item = this.remove(this.list[i]); if (destroy) { item.destroy(); } } } this.position = 0; this.list = []; } }; Object.defineProperty(Phaser.ArraySet.prototype, "total", { get: function () { return this.list.length; } }); Object.defineProperty(Phaser.ArraySet.prototype, "first", { get: function () { this.position = 0; if (this.list.length > 0) { return this.list[0]; } else { return null; } } }); Object.defineProperty(Phaser.ArraySet.prototype, "next", { get: function () { if (this.position < this.list.length) { this.position++; return this.list[this.position]; } else { return null; } } }); Phaser.ArraySet.prototype.constructor = Phaser.ArraySet; Phaser.ArrayUtils = { getRandomItem: function (objects, startIndex, length) { if (objects === null) { return null; } if (startIndex === undefined) { startIndex = 0; } if (length === undefined) { length = objects.length; } var randomIndex = startIndex + Math.floor(Math.random() * length); return objects[randomIndex] === undefined ? null : objects[randomIndex]; }, removeRandomItem: function (objects, startIndex, length) { if (objects == null) { return null; } if (startIndex === undefined) { startIndex = 0; } if (length === undefined) { length = objects.length; } var randomIndex = startIndex + Math.floor(Math.random() * length); if (randomIndex < objects.length) { var removed = objects.splice(randomIndex, 1); return removed[0] === undefined ? null : removed[0]; } else { return null; } }, shuffle: function (array) { for (var i = array.length - 1; i > 0; i--) { var j = Math.floor(Math.random() * (i + 1)); var temp = array[i]; array[i] = array[j]; array[j] = temp; } return array; }, transposeMatrix: function (array) { var sourceRowCount = array.length; var sourceColCount = array[0].length; var result = new Array(sourceColCount); for (var i = 0; i < sourceColCount; i++) { result[i] = new Array(sourceRowCount); for (var j = sourceRowCount - 1; j > -1; j--) { result[i][j] = array[j][i]; } } return result; }, rotateMatrix: function (matrix, direction) { if (typeof direction !== 'string') { direction = ((direction % 360) + 360) % 360; } if (direction === 90 || direction === -270 || direction === 'rotateLeft') { matrix = Phaser.ArrayUtils.transposeMatrix(matrix); matrix = matrix.reverse(); } else if (direction === -90 || direction === 270 || direction === 'rotateRight') { matrix = matrix.reverse(); matrix = Phaser.ArrayUtils.transposeMatrix(matrix); } else if (Math.abs(direction) === 180 || direction === 'rotate180') { for (var i = 0; i < matrix.length; i++) { matrix[i].reverse(); } matrix = matrix.reverse(); } return matrix; }, findClosest: function (value, arr) { if (!arr.length) { return NaN; } else if (arr.length === 1 || value < arr[0]) { return arr[0]; } var i = 1; while (arr[i] < value) { i++; } var low = arr[i - 1]; var high = (i < arr.length) ? arr[i] : Number.POSITIVE_INFINITY; return ((high - value) <= (value - low)) ? high : low; }, rotateRight: function (array) { var s = array.pop(); array.unshift(s); return s; }, rotateLeft: function (array) { var s = array.shift(); array.push(s); return s; }, rotate: function (array) { var s = array.shift(); array.push(s); return s; }, numberArray: function (start, end) { var result = []; for (var i = start; i <= end; i++) { result.push(i); } return result; }, numberArrayStep: function (start, end, step) { if (start === undefined || start === null) { start = 0; } if (end === undefined || end === null) { end = start; start = 0; } if (step === undefined) { step = 1; } var result = []; var total = Math.max(Phaser.Math.roundAwayFromZero((end - start) / (step || 1)), 0); for (var i = 0; i < total; i++) { result.push(start); start += step; } return result; } }; Phaser.LinkedList = function () { this.next = null; this.prev = null; this.first = null; this.last = null; this.total = 0; }; Phaser.LinkedList.prototype = { add: function (item) { if (this.total === 0 && this.first === null && this.last === null) { this.first = item; this.last = item; this.next = item; item.prev = this; this.total++; return item; } this.last.next = item; item.prev = this.last; this.last = item; this.total++; return item; }, reset: function () { this.first = null; this.last = null; this.next = null; this.prev = null; this.total = 0; }, remove: function (item) { if (this.total === 1) { this.reset(); item.next = item.prev = null; return; } if (item === this.first) { this.first = this.first.next; } else if (item === this.last) { this.last = this.last.prev; } if (item.prev) { item.prev.next = item.next; } if (item.next) { item.next.prev = item.prev; } item.next = item.prev = null; if (this.first === null ) { this.last = null; } this.total--; }, callAll: function (callback) { if (!this.first || !this.last) { return; } var entity = this.first; do { if (entity && entity[callback]) { entity[callback].call(entity); } entity = entity.next; } while (entity !== this.last.next); } }; Phaser.LinkedList.prototype.constructor = Phaser.LinkedList; Phaser.Create = function (game) { this.game = game; this.bmd = null; this.canvas = null; this.ctx = null; this.palettes = [ { 0: '#000', 1: '#9D9D9D', 2: '#FFF', 3: '#BE2633', 4: '#E06F8B', 5: '#493C2B', 6: '#A46422', 7: '#EB8931', 8: '#F7E26B', 9: '#2F484E', A: '#44891A', B: '#A3CE27', C: '#1B2632', D: '#005784', E: '#31A2F2', F: '#B2DCEF' }, { 0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#f5f4eb' }, { 0: '#000', 1: '#2234d1', 2: '#0c7e45', 3: '#44aacc', 4: '#8a3622', 5: '#5c2e78', 6: '#aa5c3d', 7: '#b5b5b5', 8: '#5e606e', 9: '#4c81fb', A: '#6cd947', B: '#7be2f9', C: '#eb8a60', D: '#e23d69', E: '#ffd93f', F: '#fff' }, { 0: '#000', 1: '#fff', 2: '#8b4131', 3: '#7bbdc5', 4: '#8b41ac', 5: '#6aac41', 6: '#3931a4', 7: '#d5de73', 8: '#945a20', 9: '#5a4100', A: '#bd736a', B: '#525252', C: '#838383', D: '#acee8b', E: '#7b73de', F: '#acacac' }, { 0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#fff' } ]; }; Phaser.Create.PALETTE_ARNE = 0; Phaser.Create.PALETTE_JMP = 1; Phaser.Create.PALETTE_CGA = 2; Phaser.Create.PALETTE_C64 = 3; Phaser.Create.PALETTE_JAPANESE_MACHINE = 4; Phaser.Create.prototype = { texture: function (key, data, pixelWidth, pixelHeight, palette) { if (pixelWidth === undefined) { pixelWidth = 8; } if (pixelHeight === undefined) { pixelHeight = pixelWidth; } if (palette === undefined) { palette = 0; } var w = data[0].length * pixelWidth; var h = data.length * pixelHeight; if (this.bmd === null) { this.bmd = this.game.make.bitmapData(); this.canvas = this.bmd.canvas; this.ctx = this.bmd.context; } this.bmd.resize(w, h); this.bmd.clear(); for (var y = 0; y < data.length; y++) { var row = data[y]; for (var x = 0; x < row.length; x++) { var d = row[x]; if (d !== '.' && d !== ' ') { this.ctx.fillStyle = this.palettes[palette][d]; this.ctx.fillRect(x * pixelWidth, y * pixelHeight, pixelWidth, pixelHeight); } } } return this.bmd.generateTexture(key); }, grid: function (key, width, height, cellWidth, cellHeight, color) { if (this.bmd === null) { this.bmd = this.game.make.bitmapData(); this.canvas = this.bmd.canvas; this.ctx = this.bmd.context; } this.bmd.resize(width, height); this.ctx.fillStyle = color; for (var y = 0; y < height; y += cellHeight) { this.ctx.fillRect(0, y, width, 1); } for (var x = 0; x < width; x += cellWidth) { this.ctx.fillRect(x, 0, 1, height); } return this.bmd.generateTexture(key); } }; Phaser.Create.prototype.constructor = Phaser.Create; Phaser.FlexGrid = function (manager, width, height) { this.game = manager.game; this.manager = manager; this.width = width; this.height = height; this.boundsCustom = new Phaser.Rectangle(0, 0, width, height); this.boundsFluid = new Phaser.Rectangle(0, 0, width, height); this.boundsFull = new Phaser.Rectangle(0, 0, width, height); this.boundsNone = new Phaser.Rectangle(0, 0, width, height); this.positionCustom = new Phaser.Point(0, 0); this.positionFluid = new Phaser.Point(0, 0); this.positionFull = new Phaser.Point(0, 0); this.positionNone = new Phaser.Point(0, 0); this.scaleCustom = new Phaser.Point(1, 1); this.scaleFluid = new Phaser.Point(1, 1); this.scaleFluidInversed = new Phaser.Point(1, 1); this.scaleFull = new Phaser.Point(1, 1); this.scaleNone = new Phaser.Point(1, 1); this.customWidth = 0; this.customHeight = 0; this.customOffsetX = 0; this.customOffsetY = 0; this.ratioH = width / height; this.ratioV = height / width; this.multiplier = 0; this.layers = []; }; Phaser.FlexGrid.prototype = { setSize: function (width, height) { this.width = width; this.height = height; this.ratioH = width / height; this.ratioV = height / width; this.scaleNone = new Phaser.Point(1, 1); this.boundsNone.width = this.width; this.boundsNone.height = this.height; this.refresh(); }, createCustomLayer: function (width, height, children, addToWorld) { if (addToWorld === undefined) { addToWorld = true; } this.customWidth = width; this.customHeight = height; this.boundsCustom.width = width; this.boundsCustom.height = height; var layer = new Phaser.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom); if (addToWorld) { this.game.world.add(layer); } this.layers.push(layer); if (typeof children !== 'undefined' && typeof children !== null) { layer.addMultiple(children); } return layer; }, createFluidLayer: function (children, addToWorld) { if (addToWorld === undefined) { addToWorld = true; } var layer = new Phaser.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid); if (addToWorld) { this.game.world.add(layer); } this.layers.push(layer); if (typeof children !== 'undefined' && typeof children !== null) { layer.addMultiple(children); } return layer; }, createFullLayer: function (children) { var layer = new Phaser.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid); this.game.world.add(layer); this.layers.push(layer); if (typeof children !== 'undefined') { layer.addMultiple(children); } return layer; }, createFixedLayer: function (children) { var layer = new Phaser.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone); this.game.world.add(layer); this.layers.push(layer); if (typeof children !== 'undefined') { layer.addMultiple(children); } return layer; }, reset: function () { var i = this.layers.length; while (i--) { if (!this.layers[i].persist) { this.layers[i].position = null; this.layers[i].scale = null; this.layers.slice(i, 1); } } }, onResize: function (width, height) { this.ratioH = width / height; this.ratioV = height / width; this.refresh(width, height); }, refresh: function () { this.multiplier = Math.min((this.manager.height / this.height), (this.manager.width / this.width)); this.boundsFluid.width = Math.round(this.width * this.multiplier); this.boundsFluid.height = Math.round(this.height * this.multiplier); this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height); this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height); this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height); this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x); this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y); this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY); this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY); this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y); this.positionNone.set(this.boundsNone.x, this.boundsNone.y); }, fitSprite: function (sprite) { this.manager.scaleSprite(sprite); sprite.x = this.manager.bounds.centerX; sprite.y = this.manager.bounds.centerY; }, debug: function () { this.game.debug.text(this.boundsFluid.width + ' x ' + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16); this.game.debug.geom(this.boundsFluid, 'rgba(255,0,0,0.9', false); } }; Phaser.FlexGrid.prototype.constructor = Phaser.FlexGrid; Phaser.FlexLayer = function (manager, position, bounds, scale) { Phaser.Group.call(this, manager.game, null, '__flexLayer' + manager.game.rnd.uuid(), false); this.manager = manager.manager; this.grid = manager; this.persist = false; this.position = position; this.bounds = bounds; this.scale = scale; this.topLeft = bounds.topLeft; this.topMiddle = new Phaser.Point(bounds.halfWidth, 0); this.topRight = bounds.topRight; this.bottomLeft = bounds.bottomLeft; this.bottomMiddle = new Phaser.Point(bounds.halfWidth, bounds.bottom); this.bottomRight = bounds.bottomRight; }; Phaser.FlexLayer.prototype = Object.create(Phaser.Group.prototype); Phaser.FlexLayer.prototype.constructor = Phaser.FlexLayer; Phaser.FlexLayer.prototype.resize = function () { }; Phaser.FlexLayer.prototype.debug = function () { this.game.debug.text(this.bounds.width + ' x ' + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16); this.game.debug.geom(this.bounds, 'rgba(0,0,255,0.9', false); this.game.debug.geom(this.topLeft, 'rgba(255,255,255,0.9'); this.game.debug.geom(this.topMiddle, 'rgba(255,255,255,0.9'); this.game.debug.geom(this.topRight, 'rgba(255,255,255,0.9'); }; Phaser.Color = { packPixel: function (r, g, b, a) { if (Phaser.Device.LITTLE_ENDIAN) { return ( (a << 24) | (b << 16) | (g <<  8) | r ) >>> 0; } else { return ( (r << 24) | (g << 16) | (b <<  8) | a ) >>> 0; } }, unpackPixel: function (rgba, out, hsl, hsv) { if (out === undefined || out === null) { out = Phaser.Color.createColor(); } if (hsl === undefined || hsl === null) { hsl = false; } if (hsv === undefined || hsv === null) { hsv = false; } if (Phaser.Device.LITTLE_ENDIAN) { out.a = ((rgba & 0xff000000) >>> 24); out.b = ((rgba & 0x00ff0000) >>> 16); out.g = ((rgba & 0x0000ff00) >>> 8); out.r = ((rgba & 0x000000ff)); } else { out.r = ((rgba & 0xff000000) >>> 24); out.g = ((rgba & 0x00ff0000) >>> 16); out.b = ((rgba & 0x0000ff00) >>> 8); out.a = ((rgba & 0x000000ff)); } out.color = rgba; out.rgba = 'rgba(' + out.r + ',' + out.g + ',' + out.b + ',' + (out.a / 255) + ')'; if (hsl) { Phaser.Color.RGBtoHSL(out.r, out.g, out.b, out); } if (hsv) { Phaser.Color.RGBtoHSV(out.r, out.g, out.b, out); } return out; }, fromRGBA: function (rgba, out) { if (!out) { out = Phaser.Color.createColor(); } out.r = ((rgba & 0xff000000) >>> 24); out.g = ((rgba & 0x00ff0000) >>> 16); out.b = ((rgba & 0x0000ff00) >>> 8); out.a = ((rgba & 0x000000ff)); out.rgba = 'rgba(' + out.r + ',' + out.g + ',' + out.b + ',' + out.a + ')'; return out; }, toRGBA: function (r, g, b, a) { return (r << 24) | (g << 16) | (b <<  8) | a; }, toABGR: function (r, g, b, a) { return ((a << 24) | (b << 16) | (g << 8) | r) >>> 0; }, RGBtoHSL: function (r, g, b, out) { if (!out) { out = Phaser.Color.createColor(r, g, b, 1); } r /= 255; g /= 255; b /= 255; var min = Math.min(r, g, b); var max = Math.max(r, g, b); out.h = 0; out.s = 0; out.l = (max + min) / 2; if (max !== min) { var d = max - min; out.s = out.l > 0.5 ? d / (2 - max - min) : d / (max + min); if (max === r) { out.h = (g - b) / d + (g < b ? 6 : 0); } else if (max === g) { out.h = (b - r) / d + 2; } else if (max === b) { out.h = (r - g) / d + 4; } out.h /= 6; } return out; }, HSLtoRGB: function (h, s, l, out) { if (!out) { out = Phaser.Color.createColor(l, l, l); } else { out.r = l; out.g = l; out.b = l; } if (s !== 0) { var q = l < 0.5 ? l * (1 + s) : l + s - l * s; var p = 2 * l - q; out.r = Phaser.Color.hueToColor(p, q, h + 1 / 3); out.g = Phaser.Color.hueToColor(p, q, h); out.b = Phaser.Color.hueToColor(p, q, h - 1 / 3); } out.r = Math.floor((out.r * 255 | 0)); out.g = Math.floor((out.g * 255 | 0)); out.b = Math.floor((out.b * 255 | 0)); Phaser.Color.updateColor(out); return out; }, RGBtoHSV: function (r, g, b, out) { if (!out) { out = Phaser.Color.createColor(r, g, b, 255); } r /= 255; g /= 255; b /= 255; var min = Math.min(r, g, b); var max = Math.max(r, g, b); var d = max - min; out.h = 0; out.s = max === 0 ? 0 : d / max; out.v = max; if (max !== min) { if (max === r) { out.h = (g - b) / d + (g < b ? 6 : 0); } else if (max === g) { out.h = (b - r) / d + 2; } else if (max === b) { out.h = (r - g) / d + 4; } out.h /= 6; } return out; }, HSVtoRGB: function (h, s, v, out) { if (out === undefined) { out = Phaser.Color.createColor(0, 0, 0, 1, h, s, 0, v); } var r, g, b; var i = Math.floor(h * 6); var f = h * 6 - i; var p = v * (1 - s); var q = v * (1 - f * s); var t = v * (1 - (1 - f) * s); switch (i % 6) { case 0: r = v; g = t; b = p; break; case 1: r = q; g = v; b = p; break; case 2: r = p; g = v; b = t; break; case 3: r = p; g = q; b = v; break; case 4: r = t; g = p; b = v; break; case 5: r = v; g = p; b = q; break; } out.r = Math.floor(r * 255); out.g = Math.floor(g * 255); out.b = Math.floor(b * 255); Phaser.Color.updateColor(out); return out; }, hueToColor: function (p, q, t) { if (t < 0) { t += 1; } if (t > 1) { t -= 1; } if (t < 1 / 6) { return p + (q - p) * 6 * t; } if (t < 1 / 2) { return q; } if (t < 2 / 3) { return p + (q - p) * (2 / 3 - t) * 6; } return p; }, createColor: function (r, g, b, a, h, s, l, v) { var out = { r: r || 0, g: g || 0, b: b || 0, a: a || 1, h: h || 0, s: s || 0, l: l || 0, v: v || 0, color: 0, color32: 0, rgba: '' }; return Phaser.Color.updateColor(out); }, updateColor: function (out) { out.rgba = 'rgba(' + out.r.toString() + ',' + out.g.toString() + ',' + out.b.toString() + ',' + out.a.toString() + ')'; out.color = Phaser.Color.getColor(out.r, out.g, out.b); out.color32 = Phaser.Color.getColor32(out.a * 255, out.r, out.g, out.b); return out; }, getColor32: function (a, r, g, b) { return a << 24 | r << 16 | g << 8 | b; }, getColor: function (r, g, b) { return r << 16 | g << 8 | b; }, RGBtoString: function (r, g, b, a, prefix) { if (a === undefined) { a = 255; } if (prefix === undefined) { prefix = '#'; } if (prefix === '#') { return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1); } else { return '0x' + Phaser.Color.componentToHex(a) + Phaser.Color.componentToHex(r) + Phaser.Color.componentToHex(g) + Phaser.Color.componentToHex(b); } }, hexToRGB: function (hex) { var rgb = Phaser.Color.hexToColor(hex); if (rgb) { return Phaser.Color.getColor32(rgb.a, rgb.r, rgb.g, rgb.b); } }, hexToColor: function (hex, out) { hex = hex.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r, g, b) { return r + r + g + g + b + b; }); var result = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); if (result) { var r = parseInt(result[1], 16); var g = parseInt(result[2], 16); var b = parseInt(result[3], 16); if (!out) { out = Phaser.Color.createColor(r, g, b); } else { out.r = r; out.g = g; out.b = b; } } return out; }, webToColor: function (web, out) { if (!out) { out = Phaser.Color.createColor(); } var result = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(web); if (result) { out.r = parseInt(result[1], 10); out.g = parseInt(result[2], 10); out.b = parseInt(result[3], 10); out.a = result[4] !== undefined ? parseFloat(result[4]) : 1; Phaser.Color.updateColor(out); } return out; }, valueToColor: function (value, out) { if (!out) { out = Phaser.Color.createColor(); } if (typeof value === 'string') { if (value.indexOf('rgb') === 0) { return Phaser.Color.webToColor(value, out); } else { out.a = 1; return Phaser.Color.hexToColor(value, out); } } else if (typeof value === 'number') { var tempColor = Phaser.Color.getRGB(value); out.r = tempColor.r; out.g = tempColor.g; out.b = tempColor.b; out.a = tempColor.a / 255; return out; } else { return out; } }, componentToHex: function (color) { var hex = color.toString(16); return (hex.length === 1) ? '0' + hex : hex; }, HSVColorWheel: function (s, v) { if (s === undefined) { s = 1.0; } if (v === undefined) { v = 1.0; } var colors = []; for (var c = 0; c <= 359; c++) { colors.push(Phaser.Color.HSVtoRGB(c / 359, s, v)); } return colors; }, HSLColorWheel: function (s, l) { if (s === undefined) { s = 0.5; } if (l === undefined) { l = 0.5; } var colors = []; for (var c = 0; c <= 359; c++) { colors.push(Phaser.Color.HSLtoRGB(c / 359, s, l)); } return colors; }, interpolateColor: function (color1, color2, steps, currentStep, alpha) { if (alpha === undefined) { alpha = 255; } var src1 = Phaser.Color.getRGB(color1); var src2 = Phaser.Color.getRGB(color2); var r = (((src2.red - src1.red) * currentStep) / steps) + src1.red; var g = (((src2.green - src1.green) * currentStep) / steps) + src1.green; var b = (((src2.blue - src1.blue) * currentStep) / steps) + src1.blue; return Phaser.Color.getColor32(alpha, r, g, b); }, interpolateColorWithRGB: function (color, r, g, b, steps, currentStep) { var src = Phaser.Color.getRGB(color); var or = (((r - src.red) * currentStep) / steps) + src.red; var og = (((g - src.green) * currentStep) / steps) + src.green; var ob = (((b - src.blue) * currentStep) / steps) + src.blue; return Phaser.Color.getColor(or, og, ob); }, interpolateRGB: function (r1, g1, b1, r2, g2, b2, steps, currentStep) { var r = (((r2 - r1) * currentStep) / steps) + r1; var g = (((g2 - g1) * currentStep) / steps) + g1; var b = (((b2 - b1) * currentStep) / steps) + b1; return Phaser.Color.getColor(r, g, b); }, getRandomColor: function (min, max, alpha) { if (min === undefined) { min = 0; } if (max === undefined) { max = 255; } if (alpha === undefined) { alpha = 255; } if (max > 255 || min > max) { return Phaser.Color.getColor(255, 255, 255); } var red = min + Math.round(Math.random() * (max - min)); var green = min + Math.round(Math.random() * (max - min)); var blue = min + Math.round(Math.random() * (max - min)); return Phaser.Color.getColor32(alpha, red, green, blue); }, getRGB: function (color) { if (color > 16777215) { return { alpha: color >>> 24, red: color >> 16 & 0xFF, green: color >> 8 & 0xFF, blue: color & 0xFF, a: color >>> 24, r: color >> 16 & 0xFF, g: color >> 8 & 0xFF, b: color & 0xFF }; } else { return { alpha: 255, red: color >> 16 & 0xFF, green: color >> 8 & 0xFF, blue: color & 0xFF, a: 255, r: color >> 16 & 0xFF, g: color >> 8 & 0xFF, b: color & 0xFF }; } }, getWebRGB: function (color) { if (typeof color === 'object') { return 'rgba(' + color.r.toString() + ',' + color.g.toString() + ',' + color.b.toString() + ',' + (color.a / 255).toString() + ')'; } else { var rgb = Phaser.Color.getRGB(color); return 'rgba(' + rgb.r.toString() + ',' + rgb.g.toString() + ',' + rgb.b.toString() + ',' + (rgb.a / 255).toString() + ')'; } }, getAlpha: function (color) { return color >>> 24; }, getAlphaFloat: function (color) { return (color >>> 24) / 255; }, getRed: function (color) { return color >> 16 & 0xFF; }, getGreen: function (color) { return color >> 8 & 0xFF; }, getBlue: function (color) { return color & 0xFF; }, blendNormal: function (a) { return a; }, blendLighten: function (a, b) { return (b > a) ? b : a; }, blendDarken: function (a, b) { return (b > a) ? a : b; }, blendMultiply: function (a, b) { return (a * b) / 255; }, blendAverage: function (a, b) { return (a + b) / 2; }, blendAdd: function (a, b) { return Math.min(255, a + b); }, blendSubtract: function (a, b) { return Math.max(0, a + b - 255); }, blendDifference: function (a, b) { return Math.abs(a - b); }, blendNegation: function (a, b) { return 255 - Math.abs(255 - a - b); }, blendScreen: function (a, b) { return 255 - (((255 - a) * (255 - b)) >> 8); }, blendExclusion: function (a, b) { return a + b - 2 * a * b / 255; }, blendOverlay: function (a, b) { return b < 128 ? (2 * a * b / 255) : (255 - 2 * (255 - a) * (255 - b) / 255); }, blendSoftLight: function (a, b) { return b < 128 ? (2 * ((a >> 1) + 64)) * (b / 255) : 255 - (2 * (255 - ((a >> 1) + 64)) * (255 - b) / 255); }, blendHardLight: function (a, b) { return Phaser.Color.blendOverlay(b, a); }, blendColorDodge: function (a, b) { return b === 255 ? b : Math.min(255, ((a << 8) / (255 - b))); }, blendColorBurn: function (a, b) { return b === 0 ? b : Math.max(0, (255 - ((255 - a) << 8) / b)); }, blendLinearDodge: function (a, b) { return Phaser.Color.blendAdd(a, b); }, blendLinearBurn: function (a, b) { return Phaser.Color.blendSubtract(a, b); }, blendLinearLight: function (a, b) { return b < 128 ? Phaser.Color.blendLinearBurn(a, 2 * b) : Phaser.Color.blendLinearDodge(a, (2 * (b - 128))); }, blendVividLight: function (a, b) { return b < 128 ? Phaser.Color.blendColorBurn(a, 2 * b) : Phaser.Color.blendColorDodge(a, (2 * (b - 128))); }, blendPinLight: function (a, b) { return b < 128 ? Phaser.Color.blendDarken(a, 2 * b) : Phaser.Color.blendLighten(a, (2 * (b - 128))); }, blendHardMix: function (a, b) { return Phaser.Color.blendVividLight(a, b) < 128 ? 0 : 255; }, blendReflect: function (a, b) { return b === 255 ? b : Math.min(255, (a * a / (255 - b))); }, blendGlow: function (a, b) { return Phaser.Color.blendReflect(b, a); }, blendPhoenix: function (a, b) { return Math.min(a, b) - Math.max(a, b) + 255; } }; Phaser.Physics = function (game, config) { config = config || {}; this.game = game; this.config = config; this.arcade = null; this.p2 = null; this.ninja = null; this.box2d = null; this.chipmunk = null; this.matter = null; this.parseConfig(); }; Phaser.Physics.ARCADE = 0; Phaser.Physics.P2JS = 1; Phaser.Physics.NINJA = 2; Phaser.Physics.BOX2D = 3; Phaser.Physics.CHIPMUNK = 4; Phaser.Physics.MATTERJS = 5; Phaser.Physics.prototype = { parseConfig: function () { if ((!this.config.hasOwnProperty('arcade') || this.config['arcade'] === true) && Phaser.Physics.hasOwnProperty('Arcade')) { this.arcade = new Phaser.Physics.Arcade(this.game); } if (this.config.hasOwnProperty('ninja') && this.config['ninja'] === true && Phaser.Physics.hasOwnProperty('Ninja')) { this.ninja = new Phaser.Physics.Ninja(this.game); } if (this.config.hasOwnProperty('p2') && this.config['p2'] === true && Phaser.Physics.hasOwnProperty('P2')) { this.p2 = new Phaser.Physics.P2(this.game, this.config); } if (this.config.hasOwnProperty('box2d') && this.config['box2d'] === true && Phaser.Physics.hasOwnProperty('BOX2D')) { this.box2d = new Phaser.Physics.BOX2D(this.game, this.config); } if (this.config.hasOwnProperty('matter') && this.config['matter'] === true && Phaser.Physics.hasOwnProperty('Matter')) { this.matter = new Phaser.Physics.Matter(this.game, this.config); } }, startSystem: function (system) { if (system === Phaser.Physics.ARCADE) { this.arcade = new Phaser.Physics.Arcade(this.game); } else if (system === Phaser.Physics.P2JS) { if (this.p2 === null) { this.p2 = new Phaser.Physics.P2(this.game, this.config); } else { this.p2.reset(); } } else if (system === Phaser.Physics.NINJA) { this.ninja = new Phaser.Physics.Ninja(this.game); } else if (system === Phaser.Physics.BOX2D) { if (this.box2d === null) { this.box2d = new Phaser.Physics.Box2D(this.game, this.config); } else { this.box2d.reset(); } } else if (system === Phaser.Physics.MATTERJS) { if (this.matter === null) { this.matter = new Phaser.Physics.Matter(this.game, this.config); } else { this.matter.reset(); } } }, enable: function (object, system, debug) { if (system === undefined) { system = Phaser.Physics.ARCADE; } if (debug === undefined) { debug = false; } if (system === Phaser.Physics.ARCADE) { this.arcade.enable(object); } else if (system === Phaser.Physics.P2JS && this.p2) { this.p2.enable(object, debug); } else if (system === Phaser.Physics.NINJA && this.ninja) { this.ninja.enableAABB(object); } else if (system === Phaser.Physics.BOX2D && this.box2d) { this.box2d.enable(object); } else if (system === Phaser.Physics.MATTERJS && this.matter) { this.matter.enable(object); } else { console.warn(object.key + ' is attempting to enable a physics body using an unknown physics system.'); } }, preUpdate: function () { if (this.p2) { this.p2.preUpdate(); } if (this.box2d) { this.box2d.preUpdate(); } if (this.matter) { this.matter.preUpdate(); } }, update: function () { if (this.p2) { this.p2.update(); } if (this.box2d) { this.box2d.update(); } if (this.matter) { this.matter.update(); } }, setBoundsToWorld: function () { if (this.arcade) { this.arcade.setBoundsToWorld(); } if (this.ninja) { this.ninja.setBoundsToWorld(); } if (this.p2) { this.p2.setBoundsToWorld(); } if (this.box2d) { this.box2d.setBoundsToWorld(); } if (this.matter) { this.matter.setBoundsToWorld(); } }, clear: function () { if (this.p2) { this.p2.clear(); } if (this.box2d) { this.box2d.clear(); } if (this.matter) { this.matter.clear(); } }, reset: function () { if (this.p2) { this.p2.reset(); } if (this.box2d) { this.box2d.reset(); } if (this.matter) { this.matter.reset(); } }, destroy: function () { if (this.p2) { this.p2.destroy(); } if (this.box2d) { this.box2d.destroy(); } if (this.matter) { this.matter.destroy(); } this.arcade = null; this.ninja = null; this.p2 = null; this.box2d = null; this.matter = null; } }; Phaser.Physics.prototype.constructor = Phaser.Physics; Phaser.Physics.Arcade = function (game) { this.game = game; this.gravity = new Phaser.Point(); this.bounds = new Phaser.Rectangle(0, 0, game.world.width, game.world.height); this.checkCollision = { up: true, down: true, left: true, right: true }; this.maxObjects = 10; this.maxLevels = 4; this.OVERLAP_BIAS = 4; this.forceX = false; this.sortDirection = Phaser.Physics.Arcade.LEFT_RIGHT; this.skipQuadTree = true; this.isPaused = false; this.quadTree = new Phaser.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels); this._total = 0; this.setBoundsToWorld(); }; Phaser.Physics.Arcade.prototype.constructor = Phaser.Physics.Arcade; Phaser.Physics.Arcade.SORT_NONE = 0; Phaser.Physics.Arcade.LEFT_RIGHT = 1; Phaser.Physics.Arcade.RIGHT_LEFT = 2; Phaser.Physics.Arcade.TOP_BOTTOM = 3; Phaser.Physics.Arcade.BOTTOM_TOP = 4; Phaser.Physics.Arcade.prototype = { setBounds: function (x, y, width, height) { this.bounds.setTo(x, y, width, height); }, setBoundsToWorld: function () { this.bounds.copyFrom(this.game.world.bounds); }, enable: function (object, children) { if (children === undefined) { children = true; } var i = 1; if (Array.isArray(object)) { i = object.length; while (i--) { if (object[i] instanceof Phaser.Group) { this.enable(object[i].children, children); } else { this.enableBody(object[i]); if (children && object[i].hasOwnProperty('children') && object[i].children.length > 0) { this.enable(object[i], true); } } } } else { if (object instanceof Phaser.Group) { this.enable(object.children, children); } else { this.enableBody(object); if (children && object.hasOwnProperty('children') && object.children.length > 0) { this.enable(object.children, true); } } } }, enableBody: function (object) { if (object.hasOwnProperty('body') && object.body === null) { object.body = new Phaser.Physics.Arcade.Body(object); if (object.parent && object.parent instanceof Phaser.Group) { object.parent.addToHash(object); } } }, updateMotion: function (body) { var velocityDelta = this.computeVelocity(0, body, body.angularVelocity, body.angularAcceleration, body.angularDrag, body.maxAngular) - body.angularVelocity; body.angularVelocity += velocityDelta; body.rotation += (body.angularVelocity * this.game.time.physicsElapsed); body.velocity.x = this.computeVelocity(1, body, body.velocity.x, body.acceleration.x, body.drag.x, body.maxVelocity.x); body.velocity.y = this.computeVelocity(2, body, body.velocity.y, body.acceleration.y, body.drag.y, body.maxVelocity.y); }, computeVelocity: function (axis, body, velocity, acceleration, drag, max) { if (max === undefined) { max = 10000; } if (axis === 1 && body.allowGravity) { velocity += (this.gravity.x + body.gravity.x) * this.game.time.physicsElapsed; } else if (axis === 2 && body.allowGravity) { velocity += (this.gravity.y + body.gravity.y) * this.game.time.physicsElapsed; } if (acceleration) { velocity += acceleration * this.game.time.physicsElapsed; } else if (drag) { drag *= this.game.time.physicsElapsed; if (velocity - drag > 0) { velocity -= drag; } else if (velocity + drag < 0) { velocity += drag; } else { velocity = 0; } } if (velocity > max) { velocity = max; } else if (velocity < -max) { velocity = -max; } return velocity; }, overlap: function (object1, object2, overlapCallback, processCallback, callbackContext) { overlapCallback = overlapCallback || null; processCallback = processCallback || null; callbackContext = callbackContext || overlapCallback; this._total = 0; if (!Array.isArray(object1) && Array.isArray(object2)) { for (var i = 0; i < object2.length; i++) { this.collideHandler(object1, object2[i], overlapCallback, processCallback, callbackContext, true); } } else if (Array.isArray(object1) && !Array.isArray(object2)) { for (var i = 0; i < object1.length; i++) { this.collideHandler(object1[i], object2, overlapCallback, processCallback, callbackContext, true); } } else if (Array.isArray(object1) && Array.isArray(object2)) { for (var i = 0; i < object1.length; i++) { for (var j = 0; j < object2.length; j++) { this.collideHandler(object1[i], object2[j], overlapCallback, processCallback, callbackContext, true); } } } else { this.collideHandler(object1, object2, overlapCallback, processCallback, callbackContext, true); } return (this._total > 0); }, collide: function (object1, object2, collideCallback, processCallback, callbackContext) { collideCallback = collideCallback || null; processCallback = processCallback || null; callbackContext = callbackContext || collideCallback; this._total = 0; if (!Array.isArray(object1) && Array.isArray(object2)) { for (var i = 0; i < object2.length; i++) { this.collideHandler(object1, object2[i], collideCallback, processCallback, callbackContext, false); } } else if (Array.isArray(object1) && !Array.isArray(object2)) { for (var i = 0; i < object1.length; i++) { this.collideHandler(object1[i], object2, collideCallback, processCallback, callbackContext, false); } } else if (Array.isArray(object1) && Array.isArray(object2)) { for (var i = 0; i < object1.length; i++) { for (var j = 0; j < object2.length; j++) { this.collideHandler(object1[i], object2[j], collideCallback, processCallback, callbackContext, false); } } } else { this.collideHandler(object1, object2, collideCallback, processCallback, callbackContext, false); } return (this._total > 0); }, sortLeftRight: function (a, b) { if (!a.body || !b.body) { return 0; } return a.body.x - b.body.x; }, sortRightLeft: function (a, b) { if (!a.body || !b.body) { return 0; } return b.body.x - a.body.x; }, sortTopBottom: function (a, b) { if (!a.body || !b.body) { return 0; } return a.body.y - b.body.y; }, sortBottomTop: function (a, b) { if (!a.body || !b.body) { return 0; } return b.body.y - a.body.y; }, sort: function (group, sortDirection) { if (group.physicsSortDirection !== null) { sortDirection = group.physicsSortDirection; } else { if (sortDirection === undefined) { sortDirection = this.sortDirection; } } if (sortDirection === Phaser.Physics.Arcade.LEFT_RIGHT) { group.hash.sort(this.sortLeftRight); } else if (sortDirection === Phaser.Physics.Arcade.RIGHT_LEFT) { group.hash.sort(this.sortRightLeft); } else if (sortDirection === Phaser.Physics.Arcade.TOP_BOTTOM) { group.hash.sort(this.sortTopBottom); } else if (sortDirection === Phaser.Physics.Arcade.BOTTOM_TOP) { group.hash.sort(this.sortBottomTop); } }, collideHandler: function (object1, object2, collideCallback, processCallback, callbackContext, overlapOnly) { if (object2 === undefined && object1.physicsType === Phaser.GROUP) { this.sort(object1); this.collideGroupVsSelf(object1, collideCallback, processCallback, callbackContext, overlapOnly); return; } if (!object1 || !object2 || !object1.exists || !object2.exists) { return; } if (this.sortDirection !== Phaser.Physics.Arcade.SORT_NONE) { if (object1.physicsType === Phaser.GROUP) { this.sort(object1); } if (object2.physicsType === Phaser.GROUP) { this.sort(object2); } } if (object1.physicsType === Phaser.SPRITE) { if (object2.physicsType === Phaser.SPRITE) { this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly); } else if (object2.physicsType === Phaser.GROUP) { this.collideSpriteVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly); } else if (object2.physicsType === Phaser.TILEMAPLAYER) { this.collideSpriteVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly); } } else if (object1.physicsType === Phaser.GROUP) { if (object2.physicsType === Phaser.SPRITE) { this.collideSpriteVsGroup(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly); } else if (object2.physicsType === Phaser.GROUP) { this.collideGroupVsGroup(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly); } else if (object2.physicsType === Phaser.TILEMAPLAYER) { this.collideGroupVsTilemapLayer(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly); } } else if (object1.physicsType === Phaser.TILEMAPLAYER) { if (object2.physicsType === Phaser.SPRITE) { this.collideSpriteVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly); } else if (object2.physicsType === Phaser.GROUP) { this.collideGroupVsTilemapLayer(object2, object1, collideCallback, processCallback, callbackContext, overlapOnly); } } }, collideSpriteVsSprite: function (sprite1, sprite2, collideCallback, processCallback, callbackContext, overlapOnly) { if (!sprite1.body || !sprite2.body) { return false; } if (this.separate(sprite1.body, sprite2.body, processCallback, callbackContext, overlapOnly)) { if (collideCallback) { collideCallback.call(callbackContext, sprite1, sprite2); } this._total++; } return true; }, collideSpriteVsGroup: function (sprite, group, collideCallback, processCallback, callbackContext, overlapOnly) { if (group.length === 0 || !sprite.body) { return; } if (this.skipQuadTree || sprite.body.skipQuadTree) { var bounds = {}; for (var i = 0; i < group.hash.length; i++) { var object1 = group.hash[i]; if (!object1 || !object1.exists || !object1.body) { continue; } bounds = object1.body.getBounds(bounds); if (this.sortDirection === Phaser.Physics.Arcade.LEFT_RIGHT) { if (sprite.body.right < bounds.x) { break; } else if (bounds.right < sprite.body.x) { continue; } } else if (this.sortDirection === Phaser.Physics.Arcade.RIGHT_LEFT) { if (sprite.body.x > bounds.right) { break; } else if (bounds.x > sprite.body.right) { continue; } } else if (this.sortDirection === Phaser.Physics.Arcade.TOP_BOTTOM) { if (sprite.body.bottom < bounds.y) { break; } else if (bounds.bottom < sprite.body.y) { continue; } } else if (this.sortDirection === Phaser.Physics.Arcade.BOTTOM_TOP) { if (sprite.body.y > bounds.bottom) { break; } else if (bounds.y > sprite.body.bottom) { continue; } } this.collideSpriteVsSprite(sprite, object1, collideCallback, processCallback, callbackContext, overlapOnly); } } else { this.quadTree.clear(); this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels); this.quadTree.populate(group); var items = this.quadTree.retrieve(sprite); for (var i = 0; i < items.length; i++) { if (this.separate(sprite.body, items[i], processCallback, callbackContext, overlapOnly)) { if (collideCallback) { collideCallback.call(callbackContext, sprite, items[i].sprite); } this._total++; } } } }, collideGroupVsSelf: function (group, collideCallback, processCallback, callbackContext, overlapOnly) { if (group.length === 0) { return; } for (var i = 0; i < group.hash.length; i++) { var bounds1 = {}; var object1 = group.hash[i]; if (!object1 || !object1.exists || !object1.body) { continue; } bounds1 = object1.body.getBounds(bounds1); for (var j = i + 1; j < group.hash.length; j++) { var bounds2 = {}; var object2 = group.hash[j]; if (!object2 || !object2.exists || !object2.body) { continue; } bounds2 = object2.body.getBounds(bounds2); if (this.sortDirection === Phaser.Physics.Arcade.LEFT_RIGHT) { if (bounds1.right < bounds2.x) { break; } else if (bounds2.right < bounds1.x) { continue; } } else if (this.sortDirection === Phaser.Physics.Arcade.RIGHT_LEFT) { if (bounds1.x > bounds2.right) { continue; } else if (bounds2.x > bounds1.right) { break; } } else if (this.sortDirection === Phaser.Physics.Arcade.TOP_BOTTOM) { if (bounds1.bottom < bounds2.y) { continue; } else if (bounds2.bottom < bounds1.y) { break; } } else if (this.sortDirection === Phaser.Physics.Arcade.BOTTOM_TOP) { if (bounds1.y > bounds2.bottom) { continue; } else if (bounds2.y > object1.body.bottom) { break; } } this.collideSpriteVsSprite(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly); } } }, collideGroupVsGroup: function (group1, group2, collideCallback, processCallback, callbackContext, overlapOnly) { if (group1.length === 0 || group2.length === 0) { return; } for (var i = 0; i < group1.children.length; i++) { if (group1.children[i].exists) { if (group1.children[i].physicsType === Phaser.GROUP) { this.collideGroupVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly); } else { this.collideSpriteVsGroup(group1.children[i], group2, collideCallback, processCallback, callbackContext, overlapOnly); } } } }, separate: function (body1, body2, processCallback, callbackContext, overlapOnly) { if ( !body1.enable || !body2.enable || body1.checkCollision.none || body2.checkCollision.none || !this.intersects(body1, body2)) { return false; } if (processCallback && processCallback.call(callbackContext, body1.sprite, body2.sprite) === false) { return false; } if (body1.isCircle && body2.isCircle) { return this.separateCircle(body1, body2, overlapOnly); } if (body1.isCircle !== body2.isCircle) { var bodyRect = (body1.isCircle) ? body2 : body1; var bodyCircle = (body1.isCircle) ? body1 : body2; var rect = { x: bodyRect.x, y: bodyRect.y, right: bodyRect.right, bottom: bodyRect.bottom }; var circle = { x: bodyCircle.x + bodyCircle.radius, y: bodyCircle.y + bodyCircle.radius }; if (circle.y < rect.y || circle.y > rect.bottom) { if (circle.x < rect.x || circle.x > rect.right) { return this.separateCircle(body1, body2, overlapOnly); } } } var resultX = false; var resultY = false; if (this.forceX || Math.abs(this.gravity.y + body1.gravity.y) < Math.abs(this.gravity.x + body1.gravity.x)) { resultX = this.separateX(body1, body2, overlapOnly); if (this.intersects(body1, body2)) { resultY = this.separateY(body1, body2, overlapOnly); } } else { resultY = this.separateY(body1, body2, overlapOnly); if (this.intersects(body1, body2)) { resultX = this.separateX(body1, body2, overlapOnly); } } var result = (resultX || resultY); if (result) { if (overlapOnly) { if (body1.onOverlap) { body1.onOverlap.dispatch(body1.sprite, body2.sprite); } if (body2.onOverlap) { body2.onOverlap.dispatch(body2.sprite, body1.sprite); } } else { if (body1.onCollide) { body1.onCollide.dispatch(body1.sprite, body2.sprite); } if (body2.onCollide) { body2.onCollide.dispatch(body2.sprite, body1.sprite); } } } return result; }, intersects: function (body1, body2) { if (body1 === body2) { return false; } if (body1.isCircle) { if (body2.isCircle) { return Phaser.Math.distance(body1.center.x, body1.center.y, body2.center.x, body2.center.y) <= (body1.radius + body2.radius); } else { return this.circleBodyIntersects(body1, body2); } } else { if (body2.isCircle) { return this.circleBodyIntersects(body2, body1); } else { if (body1.right <= body2.position.x) { return false; } if (body1.bottom <= body2.position.y) { return false; } if (body1.position.x >= body2.right) { return false; } if (body1.position.y >= body2.bottom) { return false; } return true; } } }, circleBodyIntersects: function (circle, body) { var x = Phaser.Math.clamp(circle.center.x, body.left, body.right); var y = Phaser.Math.clamp(circle.center.y, body.top, body.bottom); var dx = (circle.center.x - x) * (circle.center.x - x); var dy = (circle.center.y - y) * (circle.center.y - y); return (dx + dy) <= (circle.radius * circle.radius); }, separateCircle: function (body1, body2, overlapOnly) { this.getOverlapX(body1, body2); this.getOverlapY(body1, body2); var dx = body2.center.x - body1.center.x; var dy = body2.center.y - body1.center.y; var angleCollision = Math.atan2(dy, dx); var overlap = 0; if (body1.isCircle !== body2.isCircle) { var rect = { x: (body2.isCircle) ? body1.position.x : body2.position.x, y: (body2.isCircle) ? body1.position.y : body2.position.y, right: (body2.isCircle) ? body1.right : body2.right, bottom: (body2.isCircle) ? body1.bottom : body2.bottom }; var circle = { x: (body1.isCircle) ? (body1.position.x + body1.radius) : (body2.position.x + body2.radius), y: (body1.isCircle) ? (body1.position.y + body1.radius) : (body2.position.y + body2.radius), radius: (body1.isCircle) ? body1.radius : body2.radius }; if (circle.y < rect.y) { if (circle.x < rect.x) { overlap = Phaser.Math.distance(circle.x, circle.y, rect.x, rect.y) - circle.radius; } else if (circle.x > rect.right) { overlap = Phaser.Math.distance(circle.x, circle.y, rect.right, rect.y) - circle.radius; } } else if (circle.y > rect.bottom) { if (circle.x < rect.x) { overlap = Phaser.Math.distance(circle.x, circle.y, rect.x, rect.bottom) - circle.radius; } else if (circle.x > rect.right) { overlap = Phaser.Math.distance(circle.x, circle.y, rect.right, rect.bottom) - circle.radius; } } overlap *= -1; } else { overlap = (body1.radius + body2.radius) - Phaser.Math.distance(body1.center.x, body1.center.y, body2.center.x, body2.center.y); } if (overlapOnly || overlap === 0 || (body1.immovable && body2.immovable) || body1.customSeparateX || body2.customSeparateX) { if (overlap !== 0) { if (body1.onOverlap) { body1.onOverlap.dispatch(body1.sprite, body2.sprite); } if (body2.onOverlap) { body2.onOverlap.dispatch(body2.sprite, body1.sprite); } } return (overlap !== 0); } var v1 = { x: body1.velocity.x * Math.cos(angleCollision) + body1.velocity.y * Math.sin(angleCollision), y: body1.velocity.x * Math.sin(angleCollision) - body1.velocity.y * Math.cos(angleCollision) }; var v2 = { x: body2.velocity.x * Math.cos(angleCollision) + body2.velocity.y * Math.sin(angleCollision), y: body2.velocity.x * Math.sin(angleCollision) - body2.velocity.y * Math.cos(angleCollision) }; var tempVel1 = ((body1.mass - body2.mass) * v1.x + 2 * body2.mass * v2.x) / (body1.mass + body2.mass); var tempVel2 = (2 * body1.mass * v1.x + (body2.mass - body1.mass) * v2.x) / (body1.mass + body2.mass); if (!body1.immovable) { body1.velocity.x = (tempVel1 * Math.cos(angleCollision) - v1.y * Math.sin(angleCollision)) * body1.bounce.x; body1.velocity.y = (v1.y * Math.cos(angleCollision) + tempVel1 * Math.sin(angleCollision)) * body1.bounce.y; } if (!body2.immovable) { body2.velocity.x = (tempVel2 * Math.cos(angleCollision) - v2.y * Math.sin(angleCollision)) * body2.bounce.x; body2.velocity.y = (v2.y * Math.cos(angleCollision) + tempVel2 * Math.sin(angleCollision)) * body2.bounce.y; } if (Math.abs(angleCollision) < Math.PI / 2) { if ((body1.velocity.x > 0) && !body1.immovable && (body2.velocity.x > body1.velocity.x)) { body1.velocity.x *= -1; } else if ((body2.velocity.x < 0) && !body2.immovable && (body1.velocity.x < body2.velocity.x)) { body2.velocity.x *= -1; } else if ((body1.velocity.y > 0) && !body1.immovable && (body2.velocity.y > body1.velocity.y)) { body1.velocity.y *= -1; } else if ((body2.velocity.y < 0) && !body2.immovable && (body1.velocity.y < body2.velocity.y)) { body2.velocity.y *= -1; } } else if (Math.abs(angleCollision) > Math.PI / 2) { if ((body1.velocity.x < 0) && !body1.immovable && (body2.velocity.x < body1.velocity.x)) { body1.velocity.x *= -1; } else if ((body2.velocity.x > 0) && !body2.immovable && (body1.velocity.x > body2.velocity.x)) { body2.velocity.x *= -1; } else if ((body1.velocity.y < 0) && !body1.immovable && (body2.velocity.y < body1.velocity.y)) { body1.velocity.y *= -1; } else if ((body2.velocity.y > 0) && !body2.immovable && (body1.velocity.x > body2.velocity.y)) { body2.velocity.y *= -1; } } if (!body1.immovable) { body1.x += (body1.velocity.x * this.game.time.physicsElapsed) - overlap * Math.cos(angleCollision); body1.y += (body1.velocity.y * this.game.time.physicsElapsed) - overlap * Math.sin(angleCollision); } if (!body2.immovable) { body2.x += (body2.velocity.x * this.game.time.physicsElapsed) + overlap * Math.cos(angleCollision); body2.y += (body2.velocity.y * this.game.time.physicsElapsed) + overlap * Math.sin(angleCollision); } if (body1.onCollide) { body1.onCollide.dispatch(body1.sprite, body2.sprite); } if (body2.onCollide) { body2.onCollide.dispatch(body2.sprite, body1.sprite); } return true; }, getOverlapX: function (body1, body2, overlapOnly) { var overlap = 0; var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + this.OVERLAP_BIAS; if (body1.deltaX() === 0 && body2.deltaX() === 0) { body1.embedded = true; body2.embedded = true; } else if (body1.deltaX() > body2.deltaX()) { overlap = body1.right - body2.x; if ((overlap > maxOverlap && !overlapOnly) || body1.checkCollision.right === false || body2.checkCollision.left === false) { overlap = 0; } else { body1.touching.none = false; body1.touching.right = true; body2.touching.none = false; body2.touching.left = true; } } else if (body1.deltaX() < body2.deltaX()) { overlap = body1.x - body2.width - body2.x; if ((-overlap > maxOverlap && !overlapOnly) || body1.checkCollision.left === false || body2.checkCollision.right === false) { overlap = 0; } else { body1.touching.none = false; body1.touching.left = true; body2.touching.none = false; body2.touching.right = true; } } body1.overlapX = overlap; body2.overlapX = overlap; return overlap; }, getOverlapY: function (body1, body2, overlapOnly) { var overlap = 0; var maxOverlap = body1.deltaAbsY() + body2.deltaAbsY() + this.OVERLAP_BIAS; if (body1.deltaY() === 0 && body2.deltaY() === 0) { body1.embedded = true; body2.embedded = true; } else if (body1.deltaY() > body2.deltaY()) { overlap = body1.bottom - body2.y; if ((overlap > maxOverlap && !overlapOnly) || body1.checkCollision.down === false || body2.checkCollision.up === false) { overlap = 0; } else { body1.touching.none = false; body1.touching.down = true; body2.touching.none = false; body2.touching.up = true; } } else if (body1.deltaY() < body2.deltaY()) { overlap = body1.y - body2.bottom; if ((-overlap > maxOverlap && !overlapOnly) || body1.checkCollision.up === false || body2.checkCollision.down === false) { overlap = 0; } else { body1.touching.none = false; body1.touching.up = true; body2.touching.none = false; body2.touching.down = true; } } body1.overlapY = overlap; body2.overlapY = overlap; return overlap; }, separateX: function (body1, body2, overlapOnly) { var overlap = this.getOverlapX(body1, body2, overlapOnly); if (overlapOnly || overlap === 0 || (body1.immovable && body2.immovable) || body1.customSeparateX || body2.customSeparateX) { return (overlap !== 0) || (body1.embedded && body2.embedded); } var v1 = body1.velocity.x; var v2 = body2.velocity.x; if (!body1.immovable && !body2.immovable) { overlap *= 0.5; body1.x -= overlap; body2.x += overlap; var nv1 = Math.sqrt((v2 * v2 * body2.mass) / body1.mass) * ((v2 > 0) ? 1 : -1); var nv2 = Math.sqrt((v1 * v1 * body1.mass) / body2.mass) * ((v1 > 0) ? 1 : -1); var avg = (nv1 + nv2) * 0.5; nv1 -= avg; nv2 -= avg; body1.velocity.x = avg + nv1 * body1.bounce.x; body2.velocity.x = avg + nv2 * body2.bounce.x; } else if (!body1.immovable) { body1.x -= overlap; body1.velocity.x = v2 - v1 * body1.bounce.x; if (body2.moves) { body1.y += (body2.y - body2.prev.y) * body2.friction.y; } } else { body2.x += overlap; body2.velocity.x = v1 - v2 * body2.bounce.x; if (body1.moves) { body2.y += (body1.y - body1.prev.y) * body1.friction.y; } } return true; }, separateY: function (body1, body2, overlapOnly) { var overlap = this.getOverlapY(body1, body2, overlapOnly); if (overlapOnly || overlap === 0 || (body1.immovable && body2.immovable) || body1.customSeparateY || body2.customSeparateY) { return (overlap !== 0) || (body1.embedded && body2.embedded); } var v1 = body1.velocity.y; var v2 = body2.velocity.y; if (!body1.immovable && !body2.immovable) { overlap *= 0.5; body1.y -= overlap; body2.y += overlap; var nv1 = Math.sqrt((v2 * v2 * body2.mass) / body1.mass) * ((v2 > 0) ? 1 : -1); var nv2 = Math.sqrt((v1 * v1 * body1.mass) / body2.mass) * ((v1 > 0) ? 1 : -1); var avg = (nv1 + nv2) * 0.5; nv1 -= avg; nv2 -= avg; body1.velocity.y = avg + nv1 * body1.bounce.y; body2.velocity.y = avg + nv2 * body2.bounce.y; } else if (!body1.immovable) { body1.y -= overlap; body1.velocity.y = v2 - v1 * body1.bounce.y; if (body2.moves) { body1.x += (body2.x - body2.prev.x) * body2.friction.x; } } else { body2.y += overlap; body2.velocity.y = v1 - v2 * body2.bounce.y; if (body1.moves) { body2.x += (body1.x - body1.prev.x) * body1.friction.x; } } return true; }, getObjectsUnderPointer: function (pointer, group, callback, callbackContext) { if (group.length === 0 || !pointer.exists) { return; } return this.getObjectsAtLocation(pointer.x, pointer.y, group, callback, callbackContext, pointer); }, getObjectsAtLocation: function (x, y, group, callback, callbackContext, callbackArg) { this.quadTree.clear(); this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels); this.quadTree.populate(group); var rect = new Phaser.Rectangle(x, y, 1, 1); var output = []; var items = this.quadTree.retrieve(rect); for (var i = 0; i < items.length; i++) { if (items[i].hitTest(x, y)) { if (callback) { callback.call(callbackContext, callbackArg, items[i].sprite); } output.push(items[i].sprite); } } return output; }, moveToObject: function (displayObject, destination, speed, maxTime) { if (speed === undefined) { speed = 60; } if (maxTime === undefined) { maxTime = 0; } var angle = Math.atan2(destination.y - displayObject.y, destination.x - displayObject.x); if (maxTime > 0) { speed = this.distanceBetween(displayObject, destination) / (maxTime / 1000); } displayObject.body.velocity.x = Math.cos(angle) * speed; displayObject.body.velocity.y = Math.sin(angle) * speed; return angle; }, moveToPointer: function (displayObject, speed, pointer, maxTime) { if (speed === undefined) { speed = 60; } pointer = pointer || this.game.input.activePointer; if (maxTime === undefined) { maxTime = 0; } var angle = this.angleToPointer(displayObject, pointer); if (maxTime > 0) { speed = this.distanceToPointer(displayObject, pointer) / (maxTime / 1000); } displayObject.body.velocity.x = Math.cos(angle) * speed; displayObject.body.velocity.y = Math.sin(angle) * speed; return angle; }, moveToXY: function (displayObject, x, y, speed, maxTime) { if (speed === undefined) { speed = 60; } if (maxTime === undefined) { maxTime = 0; } var angle = Math.atan2(y - displayObject.y, x - displayObject.x); if (maxTime > 0) { speed = this.distanceToXY(displayObject, x, y) / (maxTime / 1000); } displayObject.body.velocity.x = Math.cos(angle) * speed; displayObject.body.velocity.y = Math.sin(angle) * speed; return angle; }, velocityFromAngle: function (angle, speed, point) { if (speed === undefined) { speed = 60; } point = point || new Phaser.Point(); return point.setTo((Math.cos(this.game.math.degToRad(angle)) * speed), (Math.sin(this.game.math.degToRad(angle)) * speed)); }, velocityFromRotation: function (rotation, speed, point) { if (speed === undefined) { speed = 60; } point = point || new Phaser.Point(); return point.setTo((Math.cos(rotation) * speed), (Math.sin(rotation) * speed)); }, accelerationFromRotation: function (rotation, speed, point) { if (speed === undefined) { speed = 60; } point = point || new Phaser.Point(); return point.setTo((Math.cos(rotation) * speed), (Math.sin(rotation) * speed)); }, accelerateToObject: function (displayObject, destination, speed, xSpeedMax, ySpeedMax) { if (speed === undefined) { speed = 60; } if (xSpeedMax === undefined) { xSpeedMax = 1000; } if (ySpeedMax === undefined) { ySpeedMax = 1000; } var angle = this.angleBetween(displayObject, destination); displayObject.body.acceleration.setTo(Math.cos(angle) * speed, Math.sin(angle) * speed); displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax); return angle; }, accelerateToPointer: function (displayObject, pointer, speed, xSpeedMax, ySpeedMax) { if (speed === undefined) { speed = 60; } if (pointer === undefined) { pointer = this.game.input.activePointer; } if (xSpeedMax === undefined) { xSpeedMax = 1000; } if (ySpeedMax === undefined) { ySpeedMax = 1000; } var angle = this.angleToPointer(displayObject, pointer); displayObject.body.acceleration.setTo(Math.cos(angle) * speed, Math.sin(angle) * speed); displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax); return angle; }, accelerateToXY: function (displayObject, x, y, speed, xSpeedMax, ySpeedMax) { if (speed === undefined) { speed = 60; } if (xSpeedMax === undefined) { xSpeedMax = 1000; } if (ySpeedMax === undefined) { ySpeedMax = 1000; } var angle = this.angleToXY(displayObject, x, y); displayObject.body.acceleration.setTo(Math.cos(angle) * speed, Math.sin(angle) * speed); displayObject.body.maxVelocity.setTo(xSpeedMax, ySpeedMax); return angle; }, distanceBetween: function (source, target, world) { if (world === undefined) { world = false; } var dx = (world) ? source.world.x - target.world.x : source.x - target.x; var dy = (world) ? source.world.y - target.world.y : source.y - target.y; return Math.sqrt(dx * dx + dy * dy); }, distanceToXY: function (displayObject, x, y, world) { if (world === undefined) { world = false; } var dx = (world) ? displayObject.world.x - x : displayObject.x - x; var dy = (world) ? displayObject.world.y - y : displayObject.y - y; return Math.sqrt(dx * dx + dy * dy); }, distanceToPointer: function (displayObject, pointer, world) { if (pointer === undefined) { pointer = this.game.input.activePointer; } if (world === undefined) { world = false; } var dx = (world) ? displayObject.world.x - pointer.worldX : displayObject.x - pointer.worldX; var dy = (world) ? displayObject.world.y - pointer.worldY : displayObject.y - pointer.worldY; return Math.sqrt(dx * dx + dy * dy); }, angleBetween: function (source, target, world) { if (world === undefined) { world = false; } if (world) { return Math.atan2(target.world.y - source.world.y, target.world.x - source.world.x); } else { return Math.atan2(target.y - source.y, target.x - source.x); } }, angleBetweenCenters: function (source, target) { var dx = target.centerX - source.centerX; var dy = target.centerY - source.centerY; return Math.atan2(dy, dx); }, angleToXY: function (displayObject, x, y, world) { if (world === undefined) { world = false; } if (world) { return Math.atan2(y - displayObject.world.y, x - displayObject.world.x); } else { return Math.atan2(y - displayObject.y, x - displayObject.x); } }, angleToPointer: function (displayObject, pointer, world) { if (pointer === undefined) { pointer = this.game.input.activePointer; } if (world === undefined) { world = false; } if (world) { return Math.atan2(pointer.worldY - displayObject.world.y, pointer.worldX - displayObject.world.x); } else { return Math.atan2(pointer.worldY - displayObject.y, pointer.worldX - displayObject.x); } }, worldAngleToPointer: function (displayObject, pointer) { return this.angleToPointer(displayObject, pointer, true); } }; Phaser.Physics.Arcade.Body = function (sprite) { this.sprite = sprite; this.game = sprite.game; this.type = Phaser.Physics.ARCADE; this.enable = true; this.isCircle = false; this.radius = 0; this.offset = new Phaser.Point(); this.position = new Phaser.Point(sprite.x, sprite.y); this.prev = new Phaser.Point(this.position.x, this.position.y); this.allowRotation = true; this.rotation = sprite.angle; this.preRotation = sprite.angle; this.width = sprite.width; this.height = sprite.height; this.sourceWidth = sprite.width; this.sourceHeight = sprite.height; if (sprite.texture) { this.sourceWidth = sprite.texture.frame.width; this.sourceHeight = sprite.texture.frame.height; } this.halfWidth = Math.abs(sprite.width / 2); this.halfHeight = Math.abs(sprite.height / 2); this.center = new Phaser.Point(sprite.x + this.halfWidth, sprite.y + this.halfHeight); this.velocity = new Phaser.Point(); this.newVelocity = new Phaser.Point(); this.deltaMax = new Phaser.Point(); this.acceleration = new Phaser.Point(); this.drag = new Phaser.Point(); this.allowGravity = true; this.gravity = new Phaser.Point(); this.bounce = new Phaser.Point(); this.worldBounce = null; this.onWorldBounds = null; this.onCollide = null; this.onOverlap = null; this.maxVelocity = new Phaser.Point(10000, 10000); this.friction = new Phaser.Point(1, 0); this.angularVelocity = 0; this.angularAcceleration = 0; this.angularDrag = 0; this.maxAngular = 1000; this.mass = 1; this.angle = 0; this.speed = 0; this.facing = Phaser.NONE; this.immovable = false; this.moves = true; this.customSeparateX = false; this.customSeparateY = false; this.overlapX = 0; this.overlapY = 0; this.overlapR = 0; this.embedded = false; this.collideWorldBounds = false; this.checkCollision = { none: false, any: true, up: true, down: true, left: true, right: true }; this.touching = { none: true, up: false, down: false, left: false, right: false }; this.wasTouching = { none: true, up: false, down: false, left: false, right: false }; this.blocked = { up: false, down: false, left: false, right: false }; this.tilePadding = new Phaser.Point(); this.dirty = false; this.skipQuadTree = false; this.syncBounds = false; this.isMoving = false; this.stopVelocityOnCollide = true; this.moveTimer = 0; this.moveDistance = 0; this.moveDuration = 0; this.moveTarget = null; this.moveEnd = null; this.onMoveComplete = new Phaser.Signal(); this.movementCallback = null; this.movementCallbackContext = null; this._reset = true; this._sx = sprite.scale.x; this._sy = sprite.scale.y; this._dx = 0; this._dy = 0; }; Phaser.Physics.Arcade.Body.prototype = { updateBounds: function () { if (this.syncBounds) { var b = this.sprite.getBounds(); b.ceilAll(); if (b.width !== this.width || b.height !== this.height) { this.width = b.width; this.height = b.height; this._reset = true; } } else { var asx = Math.abs(this.sprite.scale.x); var asy = Math.abs(this.sprite.scale.y); if (asx !== this._sx || asy !== this._sy) { this.width = this.sourceWidth * asx; this.height = this.sourceHeight * asy; this._sx = asx; this._sy = asy; this._reset = true; } } if (this._reset) { this.halfWidth = Math.floor(this.width / 2); this.halfHeight = Math.floor(this.height / 2); this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight); } }, preUpdate: function () { if (!this.enable || this.game.physics.arcade.isPaused) { return; } this.dirty = true; this.wasTouching.none = this.touching.none; this.wasTouching.up = this.touching.up; this.wasTouching.down = this.touching.down; this.wasTouching.left = this.touching.left; this.wasTouching.right = this.touching.right; this.touching.none = true; this.touching.up = false; this.touching.down = false; this.touching.left = false; this.touching.right = false; this.blocked.up = false; this.blocked.down = false; this.blocked.left = false; this.blocked.right = false; this.embedded = false; this.updateBounds(); this.position.x = (this.sprite.world.x - (this.sprite.anchor.x * this.sprite.width)) + this.sprite.scale.x * this.offset.x; this.position.x -= this.sprite.scale.x < 0 ? this.width : 0; this.position.y = (this.sprite.world.y - (this.sprite.anchor.y * this.sprite.height)) + this.sprite.scale.y * this.offset.y; this.position.y -= this.sprite.scale.y < 0 ? this.height : 0; this.rotation = this.sprite.angle; this.preRotation = this.rotation; if (this._reset || this.sprite.fresh) { this.prev.x = this.position.x; this.prev.y = this.position.y; } if (this.moves) { this.game.physics.arcade.updateMotion(this); this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed); this.position.x += this.newVelocity.x; this.position.y += this.newVelocity.y; if (this.position.x !== this.prev.x || this.position.y !== this.prev.y) { this.angle = Math.atan2(this.velocity.y, this.velocity.x); } this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y); if (this.collideWorldBounds) { if (this.checkWorldBounds() && this.onWorldBounds) { this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right); } } } this._dx = this.deltaX(); this._dy = this.deltaY(); this._reset = false; }, updateMovement: function () { var percent = 0; var collided = (this.overlapX !== 0 || this.overlapY !== 0); if (this.moveDuration > 0) { this.moveTimer += this.game.time.elapsedMS; percent = this.moveTimer / this.moveDuration; } else { this.moveTarget.end.set(this.position.x, this.position.y); percent = this.moveTarget.length / this.moveDistance; } if (this.movementCallback) { var result = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, percent); } if (collided || percent >= 1 || (result !== undefined && result !== true)) { this.stopMovement((percent >= 1) || (this.stopVelocityOnCollide && collided)); return false; } return true; }, stopMovement: function (stopVelocity) { if (this.isMoving) { this.isMoving = false; if (stopVelocity) { this.velocity.set(0); } this.onMoveComplete.dispatch(this.sprite, (this.overlapX !== 0 || this.overlapY !== 0)); } }, postUpdate: function () { if (!this.enable || !this.dirty) { return; } if (this.isMoving) { this.updateMovement(); } this.dirty = false; if (this.deltaX() < 0) { this.facing = Phaser.LEFT; } else if (this.deltaX() > 0) { this.facing = Phaser.RIGHT; } if (this.deltaY() < 0) { this.facing = Phaser.UP; } else if (this.deltaY() > 0) { this.facing = Phaser.DOWN; } if (this.moves) { this._dx = this.deltaX(); this._dy = this.deltaY(); if (this.deltaMax.x !== 0 && this._dx !== 0) { if (this._dx < 0 && this._dx < -this.deltaMax.x) { this._dx = -this.deltaMax.x; } else if (this._dx > 0 && this._dx > this.deltaMax.x) { this._dx = this.deltaMax.x; } } if (this.deltaMax.y !== 0 && this._dy !== 0) { if (this._dy < 0 && this._dy < -this.deltaMax.y) { this._dy = -this.deltaMax.y; } else if (this._dy > 0 && this._dy > this.deltaMax.y) { this._dy = this.deltaMax.y; } } this.sprite.position.x += this._dx; this.sprite.position.y += this._dy; this._reset = true; } this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight); if (this.allowRotation) { this.sprite.angle += this.deltaZ(); } this.prev.x = this.position.x; this.prev.y = this.position.y; }, checkWorldBounds: function () { var pos = this.position; var bounds = this.game.physics.arcade.bounds; var check = this.game.physics.arcade.checkCollision; var bx = (this.worldBounce) ? -this.worldBounce.x : -this.bounce.x; var by = (this.worldBounce) ? -this.worldBounce.y : -this.bounce.y; if (this.isCircle) { var bodyBounds = { x: this.center.x - this.radius, y: this.center.y - this.radius, right: this.center.x + this.radius, bottom: this.center.y + this.radius }; if (bodyBounds.x < bounds.x && check.left) { pos.x = bounds.x - this.halfWidth + this.radius; this.velocity.x *= bx; this.blocked.left = true; } else if (bodyBounds.right > bounds.right && check.right) { pos.x = bounds.right - this.halfWidth - this.radius; this.velocity.x *= bx; this.blocked.right = true; } if (bodyBounds.y < bounds.y && check.up) { pos.y = bounds.y - this.halfHeight + this.radius; this.velocity.y *= by; this.blocked.up = true; } else if (bodyBounds.bottom > bounds.bottom && check.down) { pos.y = bounds.bottom  - this.halfHeight - this.radius; this.velocity.y *= by; this.blocked.down = true; } } else { if (pos.x < bounds.x && check.left) { pos.x = bounds.x; this.velocity.x *= bx; this.blocked.left = true; } else if (this.right > bounds.right && check.right) { pos.x = bounds.right - this.width; this.velocity.x *= bx; this.blocked.right = true; } if (pos.y < bounds.y && check.up) { pos.y = bounds.y; this.velocity.y *= by; this.blocked.up = true; } else if (this.bottom > bounds.bottom && check.down) { pos.y = bounds.bottom - this.height; this.velocity.y *= by; this.blocked.down = true; } } return (this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right); }, moveFrom: function (duration, speed, direction) { if (speed === undefined) { speed = this.speed; } if (speed === 0) { return false; } var angle; if (direction === undefined) { angle = this.angle; direction = this.game.math.radToDeg(angle); } else { angle = this.game.math.degToRad(direction); } this.moveTimer = 0; this.moveDuration = duration; if (direction === 0 || direction === 180) { this.velocity.set(Math.cos(angle) * speed, 0); } else if (direction === 90 || direction === 270) { this.velocity.set(0, Math.sin(angle) * speed); } else { this.velocity.set(Math.cos(angle) * speed, Math.sin(angle) * speed); } this.isMoving = true; return true; }, moveTo: function (duration, distance, direction) { var speed = distance / (duration / 1000); if (speed === 0) { return false; } var angle; if (direction === undefined) { angle = this.angle; direction = this.game.math.radToDeg(angle); } else { angle = this.game.math.degToRad(direction); } distance = Math.abs(distance); this.moveDuration = 0; this.moveDistance = distance; if (this.moveTarget === null) { this.moveTarget = new Phaser.Line(); this.moveEnd = new Phaser.Point(); } this.moveTarget.fromAngle(this.x, this.y, angle, distance); this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y); this.moveTarget.setTo(this.x, this.y, this.x, this.y); if (direction === 0 || direction === 180) { this.velocity.set(Math.cos(angle) * speed, 0); } else if (direction === 90 || direction === 270) { this.velocity.set(0, Math.sin(angle) * speed); } else { this.velocity.set(Math.cos(angle) * speed, Math.sin(angle) * speed); } this.isMoving = true; return true; }, setSize: function (width, height, offsetX, offsetY) { if (offsetX === undefined) { offsetX = this.offset.x; } if (offsetY === undefined) { offsetY = this.offset.y; } this.sourceWidth = width; this.sourceHeight = height; this.width = this.sourceWidth * this._sx; this.height = this.sourceHeight * this._sy; this.halfWidth = Math.floor(this.width / 2); this.halfHeight = Math.floor(this.height / 2); this.offset.setTo(offsetX, offsetY); this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight); this.isCircle = false; this.radius = 0; }, setCircle: function (radius, offsetX, offsetY) { if (offsetX === undefined) { offsetX = this.offset.x; } if (offsetY === undefined) { offsetY = this.offset.y; } if (radius > 0) { this.isCircle = true; this.radius = radius; this.sourceWidth = radius * 2; this.sourceHeight = radius * 2; this.width = this.sourceWidth * this._sx; this.height = this.sourceHeight * this._sy; this.halfWidth = Math.floor(this.width / 2); this.halfHeight = Math.floor(this.height / 2); this.offset.setTo(offsetX, offsetY); this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight); } else { this.isCircle = false; } }, reset: function (x, y) { this.velocity.set(0); this.acceleration.set(0); this.speed = 0; this.angularVelocity = 0; this.angularAcceleration = 0; this.position.x = (x - (this.sprite.anchor.x * this.sprite.width)) + this.sprite.scale.x * this.offset.x; this.position.x -= this.sprite.scale.x < 0 ? this.width : 0; this.position.y = (y - (this.sprite.anchor.y * this.sprite.height)) + this.sprite.scale.y * this.offset.y; this.position.y -= this.sprite.scale.y < 0 ? this.height : 0; this.prev.x = this.position.x; this.prev.y = this.position.y; this.rotation = this.sprite.angle; this.preRotation = this.rotation; this._sx = this.sprite.scale.x; this._sy = this.sprite.scale.y; this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight); }, getBounds: function (obj) { if (this.isCircle) { obj.x = this.center.x - this.radius; obj.y = this.center.y - this.radius; obj.right = this.center.x + this.radius; obj.bottom = this.center.y + this.radius; } else { obj.x = this.x; obj.y = this.y; obj.right = this.right; obj.bottom = this.bottom; } return obj; }, hitTest: function (x, y) { return (this.isCircle) ? Phaser.Circle.contains(this, x, y) : Phaser.Rectangle.contains(this, x, y); }, onFloor: function () { return this.blocked.down; }, onCeiling: function(){ return this.blocked.up; }, onWall: function () { return (this.blocked.left || this.blocked.right); }, deltaAbsX: function () { return (this.deltaX() > 0 ? this.deltaX() : -this.deltaX()); }, deltaAbsY: function () { return (this.deltaY() > 0 ? this.deltaY() : -this.deltaY()); }, deltaX: function () { return this.position.x - this.prev.x; }, deltaY: function () { return this.position.y - this.prev.y; }, deltaZ: function () { return this.rotation - this.preRotation; }, destroy: function () { if (this.sprite.parent && this.sprite.parent instanceof Phaser.Group) { this.sprite.parent.removeFromHash(this.sprite); } this.sprite.body = null; this.sprite = null; } }; Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "left", { get: function () { return this.position.x; } }); Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "right", { get: function () { return this.position.x + this.width; } }); Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "top", { get: function () { return this.position.y; } }); Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "bottom", { get: function () { return this.position.y + this.height; } }); Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "x", { get: function () { return this.position.x; }, set: function (value) { this.position.x = value; } }); Object.defineProperty(Phaser.Physics.Arcade.Body.prototype, "y", { get: function () { return this.position.y; }, set: function (value) { this.position.y = value; } }); Phaser.Physics.Arcade.Body.render = function (context, body, color, filled) { if (filled === undefined) { filled = true; } color = color || 'rgba(0,255,0,0.4)'; context.fillStyle = color; context.strokeStyle = color; if (body.isCircle) { context.beginPath(); context.arc(body.center.x - body.game.camera.x, body.center.y - body.game.camera.y, body.radius, 0, 2 * Math.PI); if (filled) { context.fill(); } else { context.stroke(); } } else { if (filled) { context.fillRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height); } else { context.strokeRect(body.position.x - body.game.camera.x, body.position.y - body.game.camera.y, body.width, body.height); } } }; Phaser.Physics.Arcade.Body.renderBodyInfo = function (debug, body) { debug.line('x: ' + body.x.toFixed(2), 'y: ' + body.y.toFixed(2), 'width: ' + body.width, 'height: ' + body.height); debug.line('velocity x: ' + body.velocity.x.toFixed(2), 'y: ' + body.velocity.y.toFixed(2), 'deltaX: ' + body._dx.toFixed(2), 'deltaY: ' + body._dy.toFixed(2)); debug.line('acceleration x: ' + body.acceleration.x.toFixed(2), 'y: ' + body.acceleration.y.toFixed(2), 'speed: ' + body.speed.toFixed(2), 'angle: ' + body.angle.toFixed(2)); debug.line('gravity x: ' + body.gravity.x, 'y: ' + body.gravity.y, 'bounce x: ' + body.bounce.x.toFixed(2), 'y: ' + body.bounce.y.toFixed(2)); debug.line('touching left: ' + body.touching.left, 'right: ' + body.touching.right, 'up: ' + body.touching.up, 'down: ' + body.touching.down); debug.line('blocked left: ' + body.blocked.left, 'right: ' + body.blocked.right, 'up: ' + body.blocked.up, 'down: ' + body.blocked.down); }; Phaser.Physics.Arcade.Body.prototype.constructor = Phaser.Physics.Arcade.Body; Phaser.Physics.Arcade.TilemapCollision = function () {}; Phaser.Physics.Arcade.TilemapCollision.prototype = { TILE_BIAS: 16, collideSpriteVsTilemapLayer: function (sprite, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) { if (!sprite.body) { return; } var mapData = tilemapLayer.getTiles( sprite.body.position.x - sprite.body.tilePadding.x, sprite.body.position.y - sprite.body.tilePadding.y, sprite.body.width + sprite.body.tilePadding.x, sprite.body.height + sprite.body.tilePadding.y, false, false); if (mapData.length === 0) { return; } for (var i = 0; i < mapData.length; i++) { if (processCallback) { if (processCallback.call(callbackContext, sprite, mapData[i])) { if (this.separateTile(i, sprite.body, mapData[i], tilemapLayer, overlapOnly)) { this._total++; if (collideCallback) { collideCallback.call(callbackContext, sprite, mapData[i]); } } } } else { if (this.separateTile(i, sprite.body, mapData[i], tilemapLayer, overlapOnly)) { this._total++; if (collideCallback) { collideCallback.call(callbackContext, sprite, mapData[i]); } } } } }, collideGroupVsTilemapLayer: function (group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly) { if (group.length === 0) { return; } for (var i = 0; i < group.children.length; i++) { if (group.children[i].exists) { this.collideSpriteVsTilemapLayer(group.children[i], tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly); } } }, separateTile: function (i, body, tile, tilemapLayer, overlapOnly) { if (!body.enable) { return false; } var tilemapLayerOffsetX = (!tilemapLayer.fixedToCamera) ? tilemapLayer.position.x : 0; var tilemapLayerOffsetY = (!tilemapLayer.fixedToCamera) ? tilemapLayer.position.y : 0; if (!tile.intersects((body.position.x - tilemapLayerOffsetX), (body.position.y - tilemapLayerOffsetY), (body.right - tilemapLayerOffsetX), (body.bottom - tilemapLayerOffsetY))) { return false; } else if (overlapOnly) { return true; } if (tile.collisionCallback && !tile.collisionCallback.call(tile.collisionCallbackContext, body.sprite, tile)) { return false; } else if (typeof tile.layer.callbacks !== 'undefined' && tile.layer.callbacks[tile.index] && !tile.layer.callbacks[tile.index].callback.call(tile.layer.callbacks[tile.index].callbackContext, body.sprite, tile)) { return false; } if (!tile.faceLeft && !tile.faceRight && !tile.faceTop && !tile.faceBottom) { return false; } var ox = 0; var oy = 0; var minX = 0; var minY = 1; if (body.deltaAbsX() > body.deltaAbsY()) { minX = -1; } else if (body.deltaAbsX() < body.deltaAbsY()) { minY = -1; } if (body.deltaX() !== 0 && body.deltaY() !== 0 && (tile.faceLeft || tile.faceRight) && (tile.faceTop || tile.faceBottom)) { minX = Math.min(Math.abs((body.position.x - tilemapLayerOffsetX) - tile.right), Math.abs((body.right - tilemapLayerOffsetX) - tile.left)); minY = Math.min(Math.abs((body.position.y - tilemapLayerOffsetY) - tile.bottom), Math.abs((body.bottom - tilemapLayerOffsetY) - tile.top)); } if (minX < minY) { if (tile.faceLeft || tile.faceRight) { ox = this.tileCheckX(body, tile, tilemapLayer); if (ox !== 0 && !tile.intersects((body.position.x - tilemapLayerOffsetX), (body.position.y - tilemapLayerOffsetY), (body.right - tilemapLayerOffsetX), (body.bottom - tilemapLayerOffsetY))) { return true; } } if (tile.faceTop || tile.faceBottom) { oy = this.tileCheckY(body, tile, tilemapLayer); } } else { if (tile.faceTop || tile.faceBottom) { oy = this.tileCheckY(body, tile, tilemapLayer); if (oy !== 0 && !tile.intersects((body.position.x - tilemapLayerOffsetX), (body.position.y - tilemapLayerOffsetY), (body.right - tilemapLayerOffsetX), (body.bottom - tilemapLayerOffsetY))) { return true; } } if (tile.faceLeft || tile.faceRight) { ox = this.tileCheckX(body, tile, tilemapLayer); } } return (ox !== 0 || oy !== 0); }, tileCheckX: function (body, tile, tilemapLayer) { var ox = 0; var tilemapLayerOffsetX = (!tilemapLayer.fixedToCamera) ? tilemapLayer.position.x : 0; if (body.deltaX() < 0 && !body.blocked.left && tile.collideRight && body.checkCollision.left) { if (tile.faceRight && (body.x - tilemapLayerOffsetX) < tile.right) { ox = (body.x - tilemapLayerOffsetX) - tile.right; if (ox < -this.TILE_BIAS) { ox = 0; } } } else if (body.deltaX() > 0 && !body.blocked.right && tile.collideLeft && body.checkCollision.right) { if (tile.faceLeft && (body.right - tilemapLayerOffsetX) > tile.left) { ox = (body.right - tilemapLayerOffsetX) - tile.left; if (ox > this.TILE_BIAS) { ox = 0; } } } if (ox !== 0) { if (body.customSeparateX) { body.overlapX = ox; } else { this.processTileSeparationX(body, ox); } } return ox; }, tileCheckY: function (body, tile, tilemapLayer) { var oy = 0; var tilemapLayerOffsetY = (!tilemapLayer.fixedToCamera) ? tilemapLayer.position.y : 0; if (body.deltaY() < 0 && !body.blocked.up && tile.collideDown && body.checkCollision.up) { if (tile.faceBottom && (body.y - tilemapLayerOffsetY) < tile.bottom) { oy = (body.y - tilemapLayerOffsetY) - tile.bottom; if (oy < -this.TILE_BIAS) { oy = 0; } } } else if (body.deltaY() > 0 && !body.blocked.down && tile.collideUp && body.checkCollision.down) { if (tile.faceTop && (body.bottom - tilemapLayerOffsetY) > tile.top) { oy = (body.bottom - tilemapLayerOffsetY) - tile.top; if (oy > this.TILE_BIAS) { oy = 0; } } } if (oy !== 0) { if (body.customSeparateY) { body.overlapY = oy; } else { this.processTileSeparationY(body, oy); } } return oy; }, processTileSeparationX: function (body, x) { if (x < 0) { body.blocked.left = true; } else if (x > 0) { body.blocked.right = true; } body.position.x -= x; if (body.bounce.x === 0) { body.velocity.x = 0; } else { body.velocity.x = -body.velocity.x * body.bounce.x; } }, processTileSeparationY: function (body, y) { if (y < 0) { body.blocked.up = true; } else if (y > 0) { body.blocked.down = true; } body.position.y -= y; if (body.bounce.y === 0) { body.velocity.y = 0; } else { body.velocity.y = -body.velocity.y * body.bounce.y; } } }; Phaser.Utils.mixinPrototype(Phaser.Physics.Arcade.prototype, Phaser.Physics.Arcade.TilemapCollision.prototype); Phaser.ImageCollection = function (name, firstgid, width, height, margin, spacing, properties) { if (width === undefined || width <= 0) { width = 32; } if (height === undefined || height <= 0) { height = 32; } if (margin === undefined) { margin = 0; } if (spacing === undefined) { spacing = 0; } this.name = name; this.firstgid = firstgid | 0; this.imageWidth = width | 0; this.imageHeight = height | 0; this.imageMargin = margin | 0; this.imageSpacing = spacing | 0; this.properties = properties || {}; this.images = []; this.total = 0; }; Phaser.ImageCollection.prototype = { containsImageIndex: function (imageIndex) { return ( imageIndex >= this.firstgid && imageIndex < (this.firstgid + this.total) ); }, addImage: function (gid, image) { this.images.push({ gid: gid, image: image }); this.total++; } }; Phaser.ImageCollection.prototype.constructor = Phaser.ImageCollection; Phaser.Tile = function (layer, index, x, y, width, height) { this.layer = layer; this.index = index; this.x = x; this.y = y; this.rotation = 0; this.flipped = false; this.worldX = x * width; this.worldY = y * height; this.width = width; this.height = height; this.centerX = Math.abs(width / 2); this.centerY = Math.abs(height / 2); this.alpha = 1; this.properties = {}; this.scanned = false; this.faceTop = false; this.faceBottom = false; this.faceLeft = false; this.faceRight = false; this.collideLeft = false; this.collideRight = false; this.collideUp = false; this.collideDown = false; this.collisionCallback = null; this.collisionCallbackContext = this; }; Phaser.Tile.prototype = { containsPoint: function (x, y) { return !(x < this.worldX || y < this.worldY || x > this.right || y > this.bottom); }, intersects: function (x, y, right, bottom) { if (right <= this.worldX) { return false; } if (bottom <= this.worldY) { return false; } if (x >= this.worldX + this.width) { return false; } if (y >= this.worldY + this.height) { return false; } return true; }, setCollisionCallback: function (callback, context) { this.collisionCallback = callback; this.collisionCallbackContext = context; }, destroy: function () { this.collisionCallback = null; this.collisionCallbackContext = null; this.properties = null; }, setCollision: function (left, right, up, down) { this.collideLeft = left; this.collideRight = right; this.collideUp = up; this.collideDown = down; this.faceLeft = left; this.faceRight = right; this.faceTop = up; this.faceBottom = down; }, resetCollision: function () { this.collideLeft = false; this.collideRight = false; this.collideUp = false; this.collideDown = false; this.faceTop = false; this.faceBottom = false; this.faceLeft = false; this.faceRight = false; }, isInteresting: function (collides, faces) { if (collides && faces) { return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback); } else if (collides) { return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown); } else if (faces) { return (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight); } return false; }, copy: function (tile) { this.index = tile.index; this.alpha = tile.alpha; this.properties = tile.properties; this.collideUp = tile.collideUp; this.collideDown = tile.collideDown; this.collideLeft = tile.collideLeft; this.collideRight = tile.collideRight; this.collisionCallback = tile.collisionCallback; this.collisionCallbackContext = tile.collisionCallbackContext; } }; Phaser.Tile.prototype.constructor = Phaser.Tile; Object.defineProperty(Phaser.Tile.prototype, "collides", { get: function () { return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown); } }); Object.defineProperty(Phaser.Tile.prototype, "canCollide", { get: function () { return (this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback); } }); Object.defineProperty(Phaser.Tile.prototype, "left", { get: function () { return this.worldX; } }); Object.defineProperty(Phaser.Tile.prototype, "right", { get: function () { return this.worldX + this.width; } }); Object.defineProperty(Phaser.Tile.prototype, "top", { get: function () { return this.worldY; } }); Object.defineProperty(Phaser.Tile.prototype, "bottom", { get: function () { return this.worldY + this.height; } }); Phaser.Tilemap = function (game, key, tileWidth, tileHeight, width, height) { this.game = game; this.key = key; var data = Phaser.TilemapParser.parse(this.game, key, tileWidth, tileHeight, width, height); if (data === null) { return; } this.width = data.width; this.height = data.height; this.tileWidth = data.tileWidth; this.tileHeight = data.tileHeight; this.orientation = data.orientation; this.format = data.format; this.version = data.version; this.properties = data.properties; this.widthInPixels = data.widthInPixels; this.heightInPixels = data.heightInPixels; this.layers = data.layers; this.tilesets = data.tilesets; this.imagecollections = data.imagecollections; this.tiles = data.tiles; this.objects = data.objects; this.collideIndexes = []; this.collision = data.collision; this.images = data.images; this.enableDebug = false; this.currentLayer = 0; this.debugMap = []; this._results = []; this._tempA = 0; this._tempB = 0; }; Phaser.Tilemap.CSV = 0; Phaser.Tilemap.TILED_JSON = 1; Phaser.Tilemap.NORTH = 0; Phaser.Tilemap.EAST = 1; Phaser.Tilemap.SOUTH = 2; Phaser.Tilemap.WEST = 3; Phaser.Tilemap.prototype = { create: function (name, width, height, tileWidth, tileHeight, group) { if (group === undefined) { group = this.game.world; } this.width = width; this.height = height; this.setTileSize(tileWidth, tileHeight); this.layers.length = 0; return this.createBlankLayer(name, width, height, tileWidth, tileHeight, group); }, setTileSize: function (tileWidth, tileHeight) { this.tileWidth = tileWidth; this.tileHeight = tileHeight; this.widthInPixels = this.width * tileWidth; this.heightInPixels = this.height * tileHeight; }, addTilesetImage: function (tileset, key, tileWidth, tileHeight, tileMargin, tileSpacing, gid) { if (tileset === undefined) { return null; } if (tileWidth === undefined) { tileWidth = this.tileWidth; } if (tileHeight === undefined) { tileHeight = this.tileHeight; } if (tileMargin === undefined) { tileMargin = 0; } if (tileSpacing === undefined) { tileSpacing = 0; } if (gid === undefined) { gid = 0; } if (tileWidth === 0) { tileWidth = 32; } if (tileHeight === 0) { tileHeight = 32; } var img = null; if (key === undefined || key === null) { key = tileset; } if (key instanceof Phaser.BitmapData) { img = key.canvas; } else { if (!this.game.cache.checkImageKey(key)) { console.warn('Phaser.Tilemap.addTilesetImage: Invalid image key given: "' + key + '"'); return null; } img = this.game.cache.getImage(key); } var idx = this.getTilesetIndex(tileset); if (idx === null && this.format === Phaser.Tilemap.TILED_JSON) { console.warn('Phaser.Tilemap.addTilesetImage: No data found in the JSON matching the tileset name: "' + tileset + '"'); return null; } if (this.tilesets[idx]) { this.tilesets[idx].setImage(img); return this.tilesets[idx]; } else { var newSet = new Phaser.Tileset(tileset, gid, tileWidth, tileHeight, tileMargin, tileSpacing, {}); newSet.setImage(img); this.tilesets.push(newSet); var i = this.tilesets.length - 1; var x = tileMargin; var y = tileMargin; var count = 0; var countX = 0; var countY = 0; for (var t = gid; t < gid + newSet.total; t++) { this.tiles[t] = [x, y, i]; x += tileWidth + tileSpacing; count++; if (count === newSet.total) { break; } countX++; if (countX === newSet.columns) { x = tileMargin; y += tileHeight + tileSpacing; countX = 0; countY++; if (countY === newSet.rows) { break; } } } return newSet; } return null; }, createFromObjects: function (name, gid, key, frame, exists, autoCull, group, CustomClass, adjustY) { if (exists === undefined) { exists = true; } if (autoCull === undefined) { autoCull = false; } if (group === undefined) { group = this.game.world; } if (CustomClass === undefined) { CustomClass = Phaser.Sprite; } if (adjustY === undefined) { adjustY = true; } if (!this.objects[name]) { console.warn('Tilemap.createFromObjects: Invalid objectgroup name given: ' + name); return; } for (var i = 0; i < this.objects[name].length; i++) { var found = false; var obj = this.objects[name][i]; if (obj.gid !== undefined && typeof gid === 'number' && obj.gid === gid) { found = true; } else if (obj.id !== undefined && typeof gid === 'number' && obj.id === gid) { found = true; } else if (obj.name !== undefined && typeof gid === 'string' && obj.name === gid) { found = true; } if (found) { var sprite = new CustomClass(this.game, parseFloat(obj.x, 10), parseFloat(obj.y, 10), key, frame); sprite.name = obj.name; sprite.visible = obj.visible; sprite.autoCull = autoCull; sprite.exists = exists; if (obj.width) { sprite.width = obj.width; } if (obj.height) { sprite.height = obj.height; } if (obj.rotation) { sprite.angle = obj.rotation; } if (adjustY) { sprite.y -= sprite.height; } group.add(sprite); for (var property in obj.properties) { group.set(sprite, property, obj.properties[property], false, false, 0, true); } } } }, createFromTiles: function (tiles, replacements, key, layer, group, properties) { if (typeof tiles === 'number') { tiles = [tiles]; } if (replacements === undefined || replacements === null) { replacements = []; } else if (typeof replacements === 'number') { replacements = [replacements]; } layer = this.getLayer(layer); if (group === undefined) { group = this.game.world; } if (properties === undefined) { properties = {}; } if (properties.customClass === undefined) { properties.customClass = Phaser.Sprite; } if (properties.adjustY === undefined) { properties.adjustY = true; } var lw = this.layers[layer].width; var lh = this.layers[layer].height; this.copy(0, 0, lw, lh, layer); if (this._results.length < 2) { return 0; } var total = 0; var sprite; for (var i = 1, len = this._results.length; i < len; i++) { if (tiles.indexOf(this._results[i].index) !== -1) { sprite = new properties.customClass(this.game, this._results[i].worldX, this._results[i].worldY, key); for (var property in properties) { sprite[property] = properties[property]; } group.add(sprite); total++; } } if (replacements.length === 1) { for (i = 0; i < tiles.length; i++) { this.replace(tiles[i], replacements[0], 0, 0, lw, lh, layer); } } else if (replacements.length > 1) { for (i = 0; i < tiles.length; i++) { this.replace(tiles[i], replacements[i], 0, 0, lw, lh, layer); } } return total; }, createLayer: function (layer, width, height, group) { if (width === undefined) { width = this.game.width; } if (height === undefined) { height = this.game.height; } if (group === undefined) { group = this.game.world; } var index = layer; if (typeof layer === 'string') { index = this.getLayerIndex(layer); } if (index === null || index > this.layers.length) { console.warn('Tilemap.createLayer: Invalid layer ID given: ' + index); return; } if (width === undefined || width <= 0) { width = Math.min(this.game.width, this.layers[index].widthInPixels); } else if (width > this.game.width) { width = this.game.width; } if (height === undefined || height <= 0) { height = Math.min(this.game.height, this.layers[index].heightInPixels); } else if (height > this.game.height) { height = this.game.height; } if (this.enableDebug) { console.group('Tilemap.createLayer'); console.log('Name:', this.layers[index].name); console.log('Size:', width, 'x', height); console.log('Tileset:', this.tilesets[0].name, 'index:', index); } var rootLayer = group.add(new Phaser.TilemapLayer(this.game, this, index, width, height)); if (this.enableDebug) { console.groupEnd(); } return rootLayer; }, createBlankLayer: function (name, width, height, tileWidth, tileHeight, group) { if (group === undefined) { group = this.game.world; } if (this.getLayerIndex(name) !== null) { console.warn('Tilemap.createBlankLayer: Layer with matching name already exists: ' + name); return; } var layer = { name: name, x: 0, y: 0, width: width, height: height, widthInPixels: width * tileWidth, heightInPixels: height * tileHeight, alpha: 1, visible: true, properties: {}, indexes: [], callbacks: [], bodies: [], data: null }; var row; var output = []; for (var y = 0; y < height; y++) { row = []; for (var x = 0; x < width; x++) { row.push(new Phaser.Tile(layer, -1, x, y, tileWidth, tileHeight)); } output.push(row); } layer.data = output; this.layers.push(layer); this.currentLayer = this.layers.length - 1; var w = layer.widthInPixels; var h = layer.heightInPixels; if (w > this.game.width) { w = this.game.width; } if (h > this.game.height) { h = this.game.height; } var output = new Phaser.TilemapLayer(this.game, this, this.layers.length - 1, w, h); output.name = name; return group.add(output); }, getIndex: function (location, name) { for (var i = 0; i < location.length; i++) { if (location[i].name === name) { return i; } } return null; }, getLayerIndex: function (name) { return this.getIndex(this.layers, name); }, getTilesetIndex: function (name) { return this.getIndex(this.tilesets, name); }, getImageIndex: function (name) { return this.getIndex(this.images, name); }, setTileIndexCallback: function (indexes, callback, callbackContext, layer) { layer = this.getLayer(layer); if (typeof indexes === 'number') { this.layers[layer].callbacks[indexes] = { callback: callback, callbackContext: callbackContext }; } else { for (var i = 0, len = indexes.length; i < len; i++) { this.layers[layer].callbacks[indexes[i]] = { callback: callback, callbackContext: callbackContext }; } } }, setTileLocationCallback: function (x, y, width, height, callback, callbackContext, layer) { layer = this.getLayer(layer); this.copy(x, y, width, height, layer); if (this._results.length < 2) { return; } for (var i = 1; i < this._results.length; i++) { this._results[i].setCollisionCallback(callback, callbackContext); } }, setCollision: function (indexes, collides, layer, recalculate) { if (collides === undefined) { collides = true; } if (recalculate === undefined) { recalculate = true; } layer = this.getLayer(layer); if (typeof indexes === 'number') { return this.setCollisionByIndex(indexes, collides, layer, true); } else if (Array.isArray(indexes)) { for (var i = 0; i < indexes.length; i++) { this.setCollisionByIndex(indexes[i], collides, layer, false); } if (recalculate) { this.calculateFaces(layer); } } }, setCollisionBetween: function (start, stop, collides, layer, recalculate) { if (collides === undefined) { collides = true; } if (recalculate === undefined) { recalculate = true; } layer = this.getLayer(layer); if (start > stop) { return; } for (var index = start; index <= stop; index++) { this.setCollisionByIndex(index, collides, layer, false); } if (recalculate) { this.calculateFaces(layer); } }, setCollisionByExclusion: function (indexes, collides, layer, recalculate) { if (collides === undefined) { collides = true; } if (recalculate === undefined) { recalculate = true; } layer = this.getLayer(layer); for (var i = 0, len = this.tiles.length; i < len; i++) { if (indexes.indexOf(i) === -1) { this.setCollisionByIndex(i, collides, layer, false); } } if (recalculate) { this.calculateFaces(layer); } }, setCollisionByIndex: function (index, collides, layer, recalculate) { if (collides === undefined) { collides = true; } if (layer === undefined) { layer = this.currentLayer; } if (recalculate === undefined) { recalculate = true; } if (collides) { this.collideIndexes.push(index); } else { var i = this.collideIndexes.indexOf(index); if (i > -1) { this.collideIndexes.splice(i, 1); } } for (var y = 0; y < this.layers[layer].height; y++) { for (var x = 0; x < this.layers[layer].width; x++) { var tile = this.layers[layer].data[y][x]; if (tile && tile.index === index) { if (collides) { tile.setCollision(true, true, true, true); } else { tile.resetCollision(); } tile.faceTop = collides; tile.faceBottom = collides; tile.faceLeft = collides; tile.faceRight = collides; } } } if (recalculate) { this.calculateFaces(layer); } return layer; }, getLayer: function (layer) { if (layer === undefined) { layer = this.currentLayer; } else if (typeof layer === 'string') { layer = this.getLayerIndex(layer); } else if (layer instanceof Phaser.TilemapLayer) { layer = layer.index; } return layer; }, setPreventRecalculate: function (value) { if (value === true && this.preventingRecalculate !== true) { this.preventingRecalculate = true; this.needToRecalculate = {}; } if (value === false && this.preventingRecalculate === true) { this.preventingRecalculate = false; for (var i in this.needToRecalculate) { this.calculateFaces(i); } this.needToRecalculate = false; } }, calculateFaces: function (layer) { if (this.preventingRecalculate) { this.needToRecalculate[layer] = true; return; } var above = null; var below = null; var left = null; var right = null; for (var y = 0, h = this.layers[layer].height; y < h; y++) { for (var x = 0, w = this.layers[layer].width; x < w; x++) { var tile = this.layers[layer].data[y][x]; if (tile) { above = this.getTileAbove(layer, x, y); below = this.getTileBelow(layer, x, y); left = this.getTileLeft(layer, x, y); right = this.getTileRight(layer, x, y); if (tile.collides) { tile.faceTop = true; tile.faceBottom = true; tile.faceLeft = true; tile.faceRight = true; } if (above && above.collides) { tile.faceTop = false; } if (below && below.collides) { tile.faceBottom = false; } if (left && left.collides) { tile.faceLeft = false; } if (right && right.collides) { tile.faceRight = false; } } } } }, getTileAbove: function (layer, x, y) { if (y > 0) { return this.layers[layer].data[y - 1][x]; } return null; }, getTileBelow: function (layer, x, y) { if (y < this.layers[layer].height - 1) { return this.layers[layer].data[y + 1][x]; } return null; }, getTileLeft: function (layer, x, y) { if (x > 0) { return this.layers[layer].data[y][x - 1]; } return null; }, getTileRight: function (layer, x, y) { if (x < this.layers[layer].width - 1) { return this.layers[layer].data[y][x + 1]; } return null; }, setLayer: function (layer) { layer = this.getLayer(layer); if (this.layers[layer]) { this.currentLayer = layer; } }, hasTile: function (x, y, layer) { layer = this.getLayer(layer); if (this.layers[layer].data[y] === undefined || this.layers[layer].data[y][x] === undefined) { return false; } return (this.layers[layer].data[y][x].index > -1); }, removeTile: function (x, y, layer) { layer = this.getLayer(layer); if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) { if (this.hasTile(x, y, layer)) { var tile = this.layers[layer].data[y][x]; this.layers[layer].data[y][x] = new Phaser.Tile(this.layers[layer], -1, x, y, this.tileWidth, this.tileHeight); this.layers[layer].dirty = true; this.calculateFaces(layer); return tile; } } }, removeTileWorldXY: function (x, y, tileWidth, tileHeight, layer) { layer = this.getLayer(layer); x = this.game.math.snapToFloor(x, tileWidth) / tileWidth; y = this.game.math.snapToFloor(y, tileHeight) / tileHeight; return this.removeTile(x, y, layer); }, putTile: function (tile, x, y, layer) { if (tile === null) { return this.removeTile(x, y, layer); } layer = this.getLayer(layer); if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) { var index; if (tile instanceof Phaser.Tile) { index = tile.index; if (this.hasTile(x, y, layer)) { this.layers[layer].data[y][x].copy(tile); } else { this.layers[layer].data[y][x] = new Phaser.Tile(layer, index, x, y, tile.width, tile.height); } } else { index = tile; if (this.hasTile(x, y, layer)) { this.layers[layer].data[y][x].index = index; } else { this.layers[layer].data[y][x] = new Phaser.Tile(this.layers[layer], index, x, y, this.tileWidth, this.tileHeight); } } if (this.collideIndexes.indexOf(index) > -1) { this.layers[layer].data[y][x].setCollision(true, true, true, true); } else { this.layers[layer].data[y][x].resetCollision(); } this.layers[layer].dirty = true; this.calculateFaces(layer); return this.layers[layer].data[y][x]; } return null; }, putTileWorldXY: function (tile, x, y, tileWidth, tileHeight, layer) { layer = this.getLayer(layer); x = this.game.math.snapToFloor(x, tileWidth) / tileWidth; y = this.game.math.snapToFloor(y, tileHeight) / tileHeight; return this.putTile(tile, x, y, layer); }, searchTileIndex: function (index, skip, reverse, layer) { if (skip === undefined) { skip = 0; } if (reverse === undefined) { reverse = false; } layer = this.getLayer(layer); var c = 0; if (reverse) { for (var y = this.layers[layer].height - 1; y >= 0; y--) { for (var x = this.layers[layer].width - 1; x >= 0; x--) { if (this.layers[layer].data[y][x].index === index) { if (c === skip) { return this.layers[layer].data[y][x]; } else { c++; } } } } } else { for (var y = 0; y < this.layers[layer].height; y++) { for (var x = 0; x < this.layers[layer].width; x++) { if (this.layers[layer].data[y][x].index === index) { if (c === skip) { return this.layers[layer].data[y][x]; } else { c++; } } } } } return null; }, getTile: function (x, y, layer, nonNull) { if (nonNull === undefined) { nonNull = false; } layer = this.getLayer(layer); if (x >= 0 && x < this.layers[layer].width && y >= 0 && y < this.layers[layer].height) { if (this.layers[layer].data[y][x].index === -1) { if (nonNull) { return this.layers[layer].data[y][x]; } else { return null; } } else { return this.layers[layer].data[y][x]; } } else { return null; } }, getTileWorldXY: function (x, y, tileWidth, tileHeight, layer, nonNull) { if (tileWidth === undefined) { tileWidth = this.tileWidth; } if (tileHeight === undefined) { tileHeight = this.tileHeight; } layer = this.getLayer(layer); x = this.game.math.snapToFloor(x, tileWidth) / tileWidth; y = this.game.math.snapToFloor(y, tileHeight) / tileHeight; return this.getTile(x, y, layer, nonNull); }, copy: function (x, y, width, height, layer) { layer = this.getLayer(layer); if (!this.layers[layer]) { this._results.length = 0; return; } if (x === undefined) { x = 0; } if (y === undefined) { y = 0; } if (width === undefined) { width = this.layers[layer].width; } if (height === undefined) { height = this.layers[layer].height; } if (x < 0) { x = 0; } if (y < 0) { y = 0; } if (width > this.layers[layer].width) { width = this.layers[layer].width; } if (height > this.layers[layer].height) { height = this.layers[layer].height; } this._results.length = 0; this._results.push({ x: x, y: y, width: width, height: height, layer: layer }); for (var ty = y; ty < y + height; ty++) { for (var tx = x; tx < x + width; tx++) { this._results.push(this.layers[layer].data[ty][tx]); } } return this._results; }, paste: function (x, y, tileblock, layer) { if (x === undefined) { x = 0; } if (y === undefined) { y = 0; } layer = this.getLayer(layer); if (!tileblock || tileblock.length < 2) { return; } var diffX = x - tileblock[1].x; var diffY = y - tileblock[1].y; for (var i = 1; i < tileblock.length; i++) { this.layers[layer].data[ diffY + tileblock[i].y ][ diffX + tileblock[i].x ].copy(tileblock[i]); } this.layers[layer].dirty = true; this.calculateFaces(layer); }, swap: function (tileA, tileB, x, y, width, height, layer) { layer = this.getLayer(layer); this.copy(x, y, width, height, layer); if (this._results.length < 2) { return; } this._tempA = tileA; this._tempB = tileB; this._results.forEach(this.swapHandler, this); this.paste(x, y, this._results, layer); }, swapHandler: function (value) { if (value.index === this._tempA) { value.index = this._tempB; } else if (value.index === this._tempB) { value.index = this._tempA; } }, forEach: function (callback, context, x, y, width, height, layer) { layer = this.getLayer(layer); this.copy(x, y, width, height, layer); if (this._results.length < 2) { return; } this._results.forEach(callback, context); this.paste(x, y, this._results, layer); }, replace: function (source, dest, x, y, width, height, layer) { layer = this.getLayer(layer); this.copy(x, y, width, height, layer); if (this._results.length < 2) { return; } for (var i = 1; i < this._results.length; i++) { if (this._results[i].index === source) { this._results[i].index = dest; } } this.paste(x, y, this._results, layer); }, random: function (x, y, width, height, layer) { layer = this.getLayer(layer); this.copy(x, y, width, height, layer); if (this._results.length < 2) { return; } var indexes = []; for (var t = 1; t < this._results.length; t++) { if (this._results[t].index) { var idx = this._results[t].index; if (indexes.indexOf(idx) === -1) { indexes.push(idx); } } } for (var i = 1; i < this._results.length; i++) { this._results[i].index = this.game.rnd.pick(indexes); } this.paste(x, y, this._results, layer); }, shuffle: function (x, y, width, height, layer) { layer = this.getLayer(layer); this.copy(x, y, width, height, layer); if (this._results.length < 2) { return; } var indexes = []; for (var t = 1; t < this._results.length; t++) { if (this._results[t].index) { indexes.push(this._results[t].index); } } Phaser.ArrayUtils.shuffle(indexes); for (var i = 1; i < this._results.length; i++) { this._results[i].index = indexes[i - 1]; } this.paste(x, y, this._results, layer); }, fill: function (index, x, y, width, height, layer) { layer = this.getLayer(layer); this.copy(x, y, width, height, layer); if (this._results.length < 2) { return; } for (var i = 1; i < this._results.length; i++) { this._results[i].index = index; } this.paste(x, y, this._results, layer); }, removeAllLayers: function () { this.layers.length = 0; this.currentLayer = 0; }, dump: function () { var txt = ''; var args = ['']; for (var y = 0; y < this.layers[this.currentLayer].height; y++) { for (var x = 0; x < this.layers[this.currentLayer].width; x++) { txt += "%c  "; if (this.layers[this.currentLayer].data[y][x] > 1) { if (this.debugMap[this.layers[this.currentLayer].data[y][x]]) { args.push("background: " + this.debugMap[this.layers[this.currentLayer].data[y][x]]); } else { args.push("background: #ffffff"); } } else { args.push("background: rgb(0, 0, 0)"); } } txt += "\n"; } args[0] = txt; console.log.apply(console, args); }, destroy: function () { this.removeAllLayers(); this.data = []; this.game = null; } }; Phaser.Tilemap.prototype.constructor = Phaser.Tilemap; Object.defineProperty(Phaser.Tilemap.prototype, "layer", { get: function () { return this.layers[this.currentLayer]; }, set: function (value) { if (value !== this.currentLayer) { this.setLayer(value); } } });