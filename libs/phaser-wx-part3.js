import PIXI from './pixi-wx.js'; import Phaser from './phaser-wx-main.js'; Phaser.InputHandler = function (sprite) { this.sprite = sprite; this.game = sprite.game; this.enabled = false; this.checked = false; this.priorityID = 0; this.useHandCursor = false; this._setHandCursor = false; this.isDragged = false; this.allowHorizontalDrag = true; this.allowVerticalDrag = true; this.bringToTop = false; this.snapOffset = null; this.snapOnDrag = false; this.snapOnRelease = false; this.snapX = 0; this.snapY = 0; this.snapOffsetX = 0; this.snapOffsetY = 0; this.pixelPerfectOver = false; this.pixelPerfectClick = false; this.pixelPerfectAlpha = 255; this.draggable = false; this.boundsRect = null; this.boundsSprite = null; this.scaleLayer = false; this.dragOffset = new Phaser.Point(); this.dragFromCenter = false; this.dragStopBlocksInputUp = false; this.dragStartPoint = new Phaser.Point(); this.dragDistanceThreshold = 0; this.dragTimeThreshold = 0; this.downPoint = new Phaser.Point(); this.snapPoint = new Phaser.Point(); this._dragPoint = new Phaser.Point(); this._dragPhase = false; this._pendingDrag = false; this._dragTimePass = false; this._dragDistancePass = false; this._wasEnabled = false; this._tempPoint = new Phaser.Point(); this._pointerData = []; this._pointerData.push({ id: 0, x: 0, y: 0, camX: 0, camY: 0, isDown: false, isUp: false, isOver: false, isOut: false, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: false }); }; Phaser.InputHandler.prototype = { start: function (priority, useHandCursor) { priority = priority || 0; if (useHandCursor === undefined) { useHandCursor = false; } if (this.enabled === false) { this.game.input.interactiveItems.add(this); this.useHandCursor = useHandCursor; this.priorityID = priority; for (var i = 0; i < 10; i++) { this._pointerData[i] = { id: i, x: 0, y: 0, isDown: false, isUp: false, isOver: false, isOut: false, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: false }; } this.snapOffset = new Phaser.Point(); this.enabled = true; this._wasEnabled = true; } this.sprite.events.onAddedToGroup.add(this.addedToGroup, this); this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this); return this.sprite; }, addedToGroup: function () { if (this._dragPhase) { return; } if (this._wasEnabled && !this.enabled) { this.start(); } }, removedFromGroup: function () { if (this._dragPhase) { return; } if (this.enabled) { this._wasEnabled = true; this.stop(); } else { this._wasEnabled = false; } }, reset: function () { this.enabled = false; for (var i = 0; i < 10; i++) { this._pointerData[i] = { id: i, x: 0, y: 0, isDown: false, isUp: false, isOver: false, isOut: false, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: false }; } }, stop: function () { if (this.enabled === false) { return; } else { this.enabled = false; this.game.input.interactiveItems.remove(this); } }, destroy: function () { if (this.sprite) { if (this._setHandCursor) { this.game.canvas.style.cursor = "default"; this._setHandCursor = false; } this.enabled = false; this.game.input.interactiveItems.remove(this); this._pointerData.length = 0; this.boundsRect = null; this.boundsSprite = null; this.sprite = null; } }, validForInput: function (highestID, highestRenderID, includePixelPerfect) { if (includePixelPerfect === undefined) { includePixelPerfect = true; } if (!this.enabled || this.sprite.scale.x === 0 || this.sprite.scale.y === 0 || this.priorityID < this.game.input.minPriorityID || (this.sprite.parent && this.sprite.parent.ignoreChildInput)) { return false; } if (!includePixelPerfect && (this.pixelPerfectClick || this.pixelPerfectOver)) { return false; } if (this.priorityID > highestID || (this.priorityID === highestID && this.sprite.renderOrderID > highestRenderID)) { return true; } return false; }, isPixelPerfect: function () { return (this.pixelPerfectClick || this.pixelPerfectOver); }, pointerX: function (pointerId) { pointerId = pointerId || 0; return this._pointerData[pointerId].x; }, pointerY: function (pointerId) { pointerId = pointerId || 0; return this._pointerData[pointerId].y; }, pointerDown: function (pointerId) { pointerId = pointerId || 0; return this._pointerData[pointerId].isDown; }, pointerUp: function (pointerId) { pointerId = pointerId || 0; return this._pointerData[pointerId].isUp; }, pointerTimeDown: function (pointerId) { pointerId = pointerId || 0; return this._pointerData[pointerId].timeDown; }, pointerTimeUp: function (pointerId) { pointerId = pointerId || 0; return this._pointerData[pointerId].timeUp; }, pointerOver: function (pointerId) { if (!this.enabled) { return false; } if (pointerId === undefined) { for (var i = 0; i < 10; i++) { if (this._pointerData[i].isOver) { return true; } } return false; } else { return this._pointerData[pointerId].isOver; } }, pointerOut: function (pointerId) { if (!this.enabled) { return false; } if (pointerId === undefined) { for (var i = 0; i < 10; i++) { if (this._pointerData[i].isOut) { return true; } } } else { return this._pointerData[pointerId].isOut; } }, pointerTimeOver: function (pointerId) { pointerId = pointerId || 0; return this._pointerData[pointerId].timeOver; }, pointerTimeOut: function (pointerId) { pointerId = pointerId || 0; return this._pointerData[pointerId].timeOut; }, pointerDragged: function (pointerId) { pointerId = pointerId || 0; return this._pointerData[pointerId].isDragged; }, checkPointerDown: function (pointer, fastTest) { if (!pointer.isDown || !this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible || this.sprite.worldScale.x === 0 || this.sprite.worldScale.y === 0) { return false; } if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint)) { if (fastTest === undefined) { fastTest = false; } if (!fastTest && this.pixelPerfectClick) { return this.checkPixel(this._tempPoint.x, this._tempPoint.y); } else { return true; } } return false; }, checkPointerOver: function (pointer, fastTest) { if (!this.enabled || !this.sprite || !this.sprite.parent || !this.sprite.visible || !this.sprite.parent.visible || this.sprite.worldScale.x === 0 || this.sprite.worldScale.y === 0) { return false; } if (this.game.input.hitTest(this.sprite, pointer, this._tempPoint)) { if (fastTest === undefined) { fastTest = false; } if (!fastTest && this.pixelPerfectOver) { return this.checkPixel(this._tempPoint.x, this._tempPoint.y); } else { return true; } } return false; }, checkPixel: function (x, y, pointer) { if (this.sprite.texture.baseTexture.source) { if (x === null && y === null) { this.game.input.getLocalPosition(this.sprite, pointer, this._tempPoint); var x = this._tempPoint.x; var y = this._tempPoint.y; } if (this.sprite.anchor.x !== 0) { x -= -this.sprite.texture.frame.width * this.sprite.anchor.x; } if (this.sprite.anchor.y !== 0) { y -= -this.sprite.texture.frame.height * this.sprite.anchor.y; } x += this.sprite.texture.frame.x; y += this.sprite.texture.frame.y; if (this.sprite.texture.trim) { x -= this.sprite.texture.trim.x; y -= this.sprite.texture.trim.y; if (x < this.sprite.texture.crop.x || x > this.sprite.texture.crop.right || y < this.sprite.texture.crop.y || y > this.sprite.texture.crop.bottom) { this._dx = x; this._dy = y; return false; } } this._dx = x; this._dy = y; this.game.input.hitContext.clearRect(0, 0, 1, 1); this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, x, y, 1, 1, 0, 0, 1, 1); var rgb = this.game.input.hitContext.getImageData(0, 0, 1, 1); if (rgb.data[3] >= this.pixelPerfectAlpha) { return true; } } return false; }, update: function (pointer) { if (this.sprite === null || this.sprite.parent === undefined) { return; } if (!this.enabled || !this.sprite.visible || !this.sprite.parent.visible) { this._pointerOutHandler(pointer); return false; } if (this._pendingDrag) { if (!this._dragDistancePass) { this._dragDistancePass = (Phaser.Math.distance(pointer.x, pointer.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold); } if (this._dragDistancePass && this._dragTimePass) { this.startDrag(pointer); } return true; } else if (this.draggable && this._draggedPointerID === pointer.id) { return this.updateDrag(pointer, false); } else if (this._pointerData[pointer.id].isOver) { if (this.checkPointerOver(pointer)) { this._pointerData[pointer.id].x = pointer.x - this.sprite.x; this._pointerData[pointer.id].y = pointer.y - this.sprite.y; return true; } else { this._pointerOutHandler(pointer); return false; } } }, _pointerOverHandler: function (pointer, silent) { if (this.sprite === null) { return; } var data = this._pointerData[pointer.id]; if (data.isOver === false || pointer.dirty) { var sendEvent = (data.isOver === false); data.isOver = true; data.isOut = false; data.timeOver = this.game.time.time; data.x = pointer.x - this.sprite.x; data.y = pointer.y - this.sprite.y; if (this.useHandCursor && data.isDragged === false) { this.game.canvas.style.cursor = "pointer"; this._setHandCursor = true; } if (!silent && sendEvent && this.sprite && this.sprite.events) { this.sprite.events.onInputOver$dispatch(this.sprite, pointer); } if (this.sprite.parent && this.sprite.parent.type === Phaser.GROUP) { this.sprite.parent.onChildInputOver.dispatch(this.sprite, pointer); } } }, _pointerOutHandler: function (pointer, silent) { if (this.sprite === null) { return; } var data = this._pointerData[pointer.id]; data.isOver = false; data.isOut = true; data.timeOut = this.game.time.time; if (this.useHandCursor && data.isDragged === false) { this.game.canvas.style.cursor = "default"; this._setHandCursor = false; } if (!silent && this.sprite && this.sprite.events) { this.sprite.events.onInputOut$dispatch(this.sprite, pointer); if (this.sprite && this.sprite.parent && this.sprite.parent.type === Phaser.GROUP) { this.sprite.parent.onChildInputOut.dispatch(this.sprite, pointer); } } }, _touchedHandler: function (pointer) { if (this.sprite === null) { return; } var data = this._pointerData[pointer.id]; if (!data.isDown && data.isOver) { if (this.pixelPerfectClick && !this.checkPixel(null, null, pointer)) { return; } data.isDown = true; data.isUp = false; data.timeDown = this.game.time.time; this.downPoint.set(pointer.x, pointer.y); pointer.dirty = true; if (this.sprite && this.sprite.events) { this.sprite.events.onInputDown$dispatch(this.sprite, pointer); if (this.sprite && this.sprite.parent && this.sprite.parent.type === Phaser.GROUP) { this.sprite.parent.onChildInputDown.dispatch(this.sprite, pointer); } if (this.sprite === null) { return; } } if (this.draggable && this.isDragged === false) { if (this.dragTimeThreshold === 0 && this.dragDistanceThreshold === 0) { this.startDrag(pointer); } else { this._pendingDrag = true; this._dragDistancePass = (this.dragDistanceThreshold === 0); if (this.dragTimeThreshold > 0) { this._dragTimePass = false; this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, pointer); } else { this._dragTimePass = true; } } } if (this.bringToTop) { this.sprite.bringToTop(); } } }, dragTimeElapsed: function (pointer) { this._dragTimePass = true; if (this._pendingDrag && this.sprite) { if (this._dragDistancePass) { this.startDrag(pointer); } } }, _releasedHandler: function (pointer) { if (this.sprite === null) { return; } var data = this._pointerData[pointer.id]; if (data.isDown && pointer.isUp) { data.isDown = false; data.isUp = true; data.timeUp = this.game.time.time; data.downDuration = data.timeUp - data.timeDown; var isOver = this.checkPointerOver(pointer); if (this.sprite && this.sprite.events) { if (!this.dragStopBlocksInputUp || this.dragStopBlocksInputUp && !(this.draggable && this.isDragged && this._draggedPointerID === pointer.id)) { this.sprite.events.onInputUp$dispatch(this.sprite, pointer, isOver); } if (this.sprite && this.sprite.parent && this.sprite.parent.type === Phaser.GROUP) { this.sprite.parent.onChildInputUp.dispatch(this.sprite, pointer, isOver); } if (isOver) { isOver = this.checkPointerOver(pointer); } } data.isOver = isOver; if (!isOver && this.useHandCursor) { this.game.canvas.style.cursor = "default"; this._setHandCursor = false; } pointer.dirty = true; this._pendingDrag = false; if (this.draggable && this.isDragged && this._draggedPointerID === pointer.id) { this.stopDrag(pointer); } } }, updateDrag: function (pointer, fromStart) { if (fromStart === undefined) { fromStart = false; } if (pointer.isUp) { this.stopDrag(pointer); return false; } var px = this.globalToLocalX(pointer.x) + this._dragPoint.x + this.dragOffset.x; var py = this.globalToLocalY(pointer.y) + this._dragPoint.y + this.dragOffset.y; if (this.sprite.fixedToCamera) { if (this.allowHorizontalDrag) { this.sprite.cameraOffset.x = px; } if (this.allowVerticalDrag) { this.sprite.cameraOffset.y = py; } if (this.boundsRect) { this.checkBoundsRect(); } if (this.boundsSprite) { this.checkBoundsSprite(); } if (this.snapOnDrag) { this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX); this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY); this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y); } } else { var cx = this.game.camera.x - this._pointerData[pointer.id].camX; var cy = this.game.camera.y - this._pointerData[pointer.id].camY; if (this.allowHorizontalDrag) { this.sprite.x = px + cx; } if (this.allowVerticalDrag) { this.sprite.y = py + cy; } if (this.boundsRect) { this.checkBoundsRect(); } if (this.boundsSprite) { this.checkBoundsSprite(); } if (this.snapOnDrag) { this.sprite.x = Math.round((this.sprite.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX); this.sprite.y = Math.round((this.sprite.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY); this.snapPoint.set(this.sprite.x, this.sprite.y); } } this.sprite.events.onDragUpdate.dispatch(this.sprite, pointer, px, py, this.snapPoint, fromStart); return true; }, justOver: function (pointerId, delay) { pointerId = pointerId || 0; delay = delay || 500; return (this._pointerData[pointerId].isOver && this.overDuration(pointerId) < delay); }, justOut: function (pointerId, delay) { pointerId = pointerId || 0; delay = delay || 500; return (this._pointerData[pointerId].isOut && (this.game.time.time - this._pointerData[pointerId].timeOut < delay)); }, justPressed: function (pointerId, delay) { pointerId = pointerId || 0; delay = delay || 500; return (this._pointerData[pointerId].isDown && this.downDuration(pointerId) < delay); }, justReleased: function (pointerId, delay) { pointerId = pointerId || 0; delay = delay || 500; return (this._pointerData[pointerId].isUp && (this.game.time.time - this._pointerData[pointerId].timeUp < delay)); }, overDuration: function (pointerId) { pointerId = pointerId || 0; if (this._pointerData[pointerId].isOver) { return this.game.time.time - this._pointerData[pointerId].timeOver; } return -1; }, downDuration: function (pointerId) { pointerId = pointerId || 0; if (this._pointerData[pointerId].isDown) { return this.game.time.time - this._pointerData[pointerId].timeDown; } return -1; }, enableDrag: function (lockCenter, bringToTop, pixelPerfect, alphaThreshold, boundsRect, boundsSprite) { if (lockCenter === undefined) { lockCenter = false; } if (bringToTop === undefined) { bringToTop = false; } if (pixelPerfect === undefined) { pixelPerfect = false; } if (alphaThreshold === undefined) { alphaThreshold = 255; } if (boundsRect === undefined) { boundsRect = null; } if (boundsSprite === undefined) { boundsSprite = null; } this._dragPoint = new Phaser.Point(); this.draggable = true; this.bringToTop = bringToTop; this.dragOffset = new Phaser.Point(); this.dragFromCenter = lockCenter; this.pixelPerfectClick = pixelPerfect; this.pixelPerfectAlpha = alphaThreshold; if (boundsRect) { this.boundsRect = boundsRect; } if (boundsSprite) { this.boundsSprite = boundsSprite; } }, disableDrag: function () { if (this._pointerData) { for (var i = 0; i < 10; i++) { this._pointerData[i].isDragged = false; } } this.draggable = false; this.isDragged = false; this._draggedPointerID = -1; this._pendingDrag = false; }, startDrag: function (pointer) { var x = this.sprite.x; var y = this.sprite.y; this.isDragged = true; this._draggedPointerID = pointer.id; this._pointerData[pointer.id].camX = this.game.camera.x; this._pointerData[pointer.id].camY = this.game.camera.y; this._pointerData[pointer.id].isDragged = true; if (this.sprite.fixedToCamera) { if (this.dragFromCenter) { var bounds = this.sprite.getBounds(); this.sprite.cameraOffset.x = this.globalToLocalX(pointer.x) + (this.sprite.cameraOffset.x - bounds.centerX); this.sprite.cameraOffset.y = this.globalToLocalY(pointer.y) + (this.sprite.cameraOffset.y - bounds.centerY); } this._dragPoint.setTo(this.sprite.cameraOffset.x - pointer.x, this.sprite.cameraOffset.y - pointer.y); } else { if (this.dragFromCenter) { var bounds = this.sprite.getBounds(); this.sprite.x = this.globalToLocalX(pointer.x) + (this.sprite.x - bounds.centerX); this.sprite.y = this.globalToLocalY(pointer.y) + (this.sprite.y - bounds.centerY); } this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(pointer.x), this.sprite.y - this.globalToLocalY(pointer.y)); } this.updateDrag(pointer, true); if (this.bringToTop) { this._dragPhase = true; this.sprite.bringToTop(); } this.dragStartPoint.set(x, y); this.sprite.events.onDragStart$dispatch(this.sprite, pointer, x, y); this._pendingDrag = false; }, globalToLocalX: function (x) { if (this.scaleLayer) { x -= this.game.scale.grid.boundsFluid.x; x *= this.game.scale.grid.scaleFluidInversed.x; } return x; }, globalToLocalY: function (y) { if (this.scaleLayer) { y -= this.game.scale.grid.boundsFluid.y; y *= this.game.scale.grid.scaleFluidInversed.y; } return y; }, stopDrag: function (pointer) { this.isDragged = false; this._draggedPointerID = -1; this._pointerData[pointer.id].isDragged = false; this._dragPhase = false; this._pendingDrag = false; if (this.snapOnRelease) { if (this.sprite.fixedToCamera) { this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX); this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY); } else { this.sprite.x = Math.round((this.sprite.x - (this.snapOffsetX % this.snapX)) / this.snapX) * this.snapX + (this.snapOffsetX % this.snapX); this.sprite.y = Math.round((this.sprite.y - (this.snapOffsetY % this.snapY)) / this.snapY) * this.snapY + (this.snapOffsetY % this.snapY); } } this.sprite.events.onDragStop$dispatch(this.sprite, pointer); if (this.checkPointerOver(pointer) === false) { this._pointerOutHandler(pointer); } }, setDragLock: function (allowHorizontal, allowVertical) { if (allowHorizontal === undefined) { allowHorizontal = true; } if (allowVertical === undefined) { allowVertical = true; } this.allowHorizontalDrag = allowHorizontal; this.allowVerticalDrag = allowVertical; }, enableSnap: function (snapX, snapY, onDrag, onRelease, snapOffsetX, snapOffsetY) { if (onDrag === undefined) { onDrag = true; } if (onRelease === undefined) { onRelease = false; } if (snapOffsetX === undefined) { snapOffsetX = 0; } if (snapOffsetY === undefined) { snapOffsetY = 0; } this.snapX = snapX; this.snapY = snapY; this.snapOffsetX = snapOffsetX; this.snapOffsetY = snapOffsetY; this.snapOnDrag = onDrag; this.snapOnRelease = onRelease; }, disableSnap: function () { this.snapOnDrag = false; this.snapOnRelease = false; }, checkBoundsRect: function () { if (this.sprite.fixedToCamera) { if (this.sprite.cameraOffset.x < this.boundsRect.left) { this.sprite.cameraOffset.x = this.boundsRect.left; } else if ((this.sprite.cameraOffset.x + this.sprite.width) > this.boundsRect.right) { this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width; } if (this.sprite.cameraOffset.y < this.boundsRect.top) { this.sprite.cameraOffset.y = this.boundsRect.top; } else if ((this.sprite.cameraOffset.y + this.sprite.height) > this.boundsRect.bottom) { this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height; } } else { if (this.sprite.left < this.boundsRect.left) { this.sprite.x = this.boundsRect.x + this.sprite.offsetX; } else if (this.sprite.right > this.boundsRect.right) { this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX); } if (this.sprite.top < this.boundsRect.top) { this.sprite.y = this.boundsRect.top + this.sprite.offsetY; } else if (this.sprite.bottom > this.boundsRect.bottom) { this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY); } } }, checkBoundsSprite: function () { if (this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera) { if (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x) { this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x; } else if ((this.sprite.cameraOffset.x + this.sprite.width) > (this.boundsSprite.cameraOffset.x + this.boundsSprite.width)) { this.sprite.cameraOffset.x = (this.boundsSprite.cameraOffset.x + this.boundsSprite.width) - this.sprite.width; } if (this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y) { this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y; } else if ((this.sprite.cameraOffset.y + this.sprite.height) > (this.boundsSprite.cameraOffset.y + this.boundsSprite.height)) { this.sprite.cameraOffset.y = (this.boundsSprite.cameraOffset.y + this.boundsSprite.height) - this.sprite.height; } } else { if (this.sprite.left < this.boundsSprite.left) { this.sprite.x = this.boundsSprite.left + this.sprite.offsetX; } else if (this.sprite.right > this.boundsSprite.right) { this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX); } if (this.sprite.top < this.boundsSprite.top) { this.sprite.y = this.boundsSprite.top + this.sprite.offsetY; } else if (this.sprite.bottom > this.boundsSprite.bottom) { this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY); } } } }; Phaser.InputHandler.prototype.constructor = Phaser.InputHandler; Phaser.Gamepad = function (game) { this.game = game; this._gamepadIndexMap = {}; this._rawPads = []; this._active = false; this.enabled = true; this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || (navigator.userAgent.indexOf('Firefox/') !== -1) || !!navigator.getGamepads; this._prevRawGamepadTypes = []; this._prevTimestamps = []; this.callbackContext = this; this.onConnectCallback = null; this.onDisconnectCallback = null; this.onDownCallback = null; this.onUpCallback = null; this.onAxisCallback = null; this.onFloatCallback = null; this._ongamepadconnected = null; this._gamepaddisconnected = null; this._gamepads = [ new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this), new Phaser.SinglePad(game, this) ]; }; Phaser.Gamepad.prototype = { addCallbacks: function (context, callbacks) { if (typeof callbacks !== 'undefined') { this.onConnectCallback = (typeof callbacks.onConnect === 'function') ? callbacks.onConnect : this.onConnectCallback; this.onDisconnectCallback = (typeof callbacks.onDisconnect === 'function') ? callbacks.onDisconnect : this.onDisconnectCallback; this.onDownCallback = (typeof callbacks.onDown === 'function') ? callbacks.onDown : this.onDownCallback; this.onUpCallback = (typeof callbacks.onUp === 'function') ? callbacks.onUp : this.onUpCallback; this.onAxisCallback = (typeof callbacks.onAxis === 'function') ? callbacks.onAxis : this.onAxisCallback; this.onFloatCallback = (typeof callbacks.onFloat === 'function') ? callbacks.onFloat : this.onFloatCallback; this.callbackContext = context; } }, start: function () { if (this._active) { return; } this._active = true; var _this = this; this._onGamepadConnected = function (event) { return _this.onGamepadConnected(event); }; this._onGamepadDisconnected = function (event) { return _this.onGamepadDisconnected(event); }; window.addEventListener('gamepadconnected', this._onGamepadConnected, false); window.addEventListener('gamepaddisconnected', this._onGamepadDisconnected, false); }, onGamepadConnected: function (event) { var newPad = event.gamepad; this._rawPads.push(newPad); this._gamepads[newPad.index].connect(newPad); }, onGamepadDisconnected: function (event) { var removedPad = event.gamepad; for (var i in this._rawPads) { if (this._rawPads[i].index === removedPad.index) { this._rawPads.splice(i,1); } } this._gamepads[removedPad.index].disconnect(); }, update: function () { this._pollGamepads(); this.pad1.pollStatus(); this.pad2.pollStatus(); this.pad3.pollStatus(); this.pad4.pollStatus(); }, _pollGamepads: function () { if (!this._active) { return; } if (navigator['getGamepads']) { var rawGamepads = navigator.getGamepads(); } else if (navigator['webkitGetGamepads']) { var rawGamepads = navigator.webkitGetGamepads(); } else if (navigator['webkitGamepads']) { var rawGamepads = navigator.webkitGamepads(); } if (rawGamepads) { this._rawPads = []; var gamepadsChanged = false; for (var i = 0; i < rawGamepads.length; i++) { if (typeof rawGamepads[i] !== this._prevRawGamepadTypes[i]) { gamepadsChanged = true; this._prevRawGamepadTypes[i] = typeof rawGamepads[i]; } if (rawGamepads[i]) { this._rawPads.push(rawGamepads[i]); } if (i === 3) { break; } } for (var g = 0; g < this._gamepads.length; g++) { this._gamepads[g]._rawPad = this._rawPads[g]; } if (gamepadsChanged) { var validConnections = { rawIndices: {}, padIndices: {} }; var singlePad; for (var j = 0; j < this._gamepads.length; j++) { singlePad = this._gamepads[j]; if (singlePad.connected) { for (var k = 0; k < this._rawPads.length; k++) { if (this._rawPads[k].index === singlePad.index) { validConnections.rawIndices[singlePad.index] = true; validConnections.padIndices[j] = true; } } } } for (var l = 0; l < this._gamepads.length; l++) { singlePad = this._gamepads[l]; if (validConnections.padIndices[l]) { continue; } if (this._rawPads.length < 1) { singlePad.disconnect(); } for (var m = 0; m < this._rawPads.length; m++) { if (validConnections.padIndices[l]) { break; } var rawPad = this._rawPads[m]; if (rawPad) { if (validConnections.rawIndices[rawPad.index]) { singlePad.disconnect(); continue; } else { singlePad.connect(rawPad); validConnections.rawIndices[rawPad.index] = true; validConnections.padIndices[l] = true; } } else { singlePad.disconnect(); } } } } } }, setDeadZones: function (value) { for (var i = 0; i < this._gamepads.length; i++) { this._gamepads[i].deadZone = value; } }, stop: function () { this._active = false; window.removeEventListener('gamepadconnected', this._onGamepadConnected); window.removeEventListener('gamepaddisconnected', this._onGamepadDisconnected); }, reset: function () { this.update(); for (var i = 0; i < this._gamepads.length; i++) { this._gamepads[i].reset(); } }, justPressed: function (buttonCode, duration) { for (var i = 0; i < this._gamepads.length; i++) { if (this._gamepads[i].justPressed(buttonCode, duration) === true) { return true; } } return false; }, justReleased: function (buttonCode, duration) { for (var i = 0; i < this._gamepads.length; i++) { if (this._gamepads[i].justReleased(buttonCode, duration) === true) { return true; } } return false; }, isDown: function (buttonCode) { for (var i = 0; i < this._gamepads.length; i++) { if (this._gamepads[i].isDown(buttonCode) === true) { return true; } } return false; }, destroy: function () { this.stop(); for (var i = 0; i < this._gamepads.length; i++) { this._gamepads[i].destroy(); } } }; Phaser.Gamepad.prototype.constructor = Phaser.Gamepad; Object.defineProperty(Phaser.Gamepad.prototype, "active", { get: function () { return this._active; } }); Object.defineProperty(Phaser.Gamepad.prototype, "supported", { get: function () { return this._gamepadSupportAvailable; } }); Object.defineProperty(Phaser.Gamepad.prototype, "padsConnected", { get: function () { return this._rawPads.length; } }); Object.defineProperty(Phaser.Gamepad.prototype, "pad1", { get: function () { return this._gamepads[0]; } }); Object.defineProperty(Phaser.Gamepad.prototype, "pad2", { get: function () { return this._gamepads[1]; } }); Object.defineProperty(Phaser.Gamepad.prototype, "pad3", { get: function () { return this._gamepads[2]; } }); Object.defineProperty(Phaser.Gamepad.prototype, "pad4", { get: function () { return this._gamepads[3]; } }); Phaser.Gamepad.BUTTON_0 = 0; Phaser.Gamepad.BUTTON_1 = 1; Phaser.Gamepad.BUTTON_2 = 2; Phaser.Gamepad.BUTTON_3 = 3; Phaser.Gamepad.BUTTON_4 = 4; Phaser.Gamepad.BUTTON_5 = 5; Phaser.Gamepad.BUTTON_6 = 6; Phaser.Gamepad.BUTTON_7 = 7; Phaser.Gamepad.BUTTON_8 = 8; Phaser.Gamepad.BUTTON_9 = 9; Phaser.Gamepad.BUTTON_10 = 10; Phaser.Gamepad.BUTTON_11 = 11; Phaser.Gamepad.BUTTON_12 = 12; Phaser.Gamepad.BUTTON_13 = 13; Phaser.Gamepad.BUTTON_14 = 14; Phaser.Gamepad.BUTTON_15 = 15; Phaser.Gamepad.AXIS_0 = 0; Phaser.Gamepad.AXIS_1 = 1; Phaser.Gamepad.AXIS_2 = 2; Phaser.Gamepad.AXIS_3 = 3; Phaser.Gamepad.AXIS_4 = 4; Phaser.Gamepad.AXIS_5 = 5; Phaser.Gamepad.AXIS_6 = 6; Phaser.Gamepad.AXIS_7 = 7; Phaser.Gamepad.AXIS_8 = 8; Phaser.Gamepad.AXIS_9 = 9; Phaser.Gamepad.XBOX360_A = 0; Phaser.Gamepad.XBOX360_B = 1; Phaser.Gamepad.XBOX360_X = 2; Phaser.Gamepad.XBOX360_Y = 3; Phaser.Gamepad.XBOX360_LEFT_BUMPER = 4; Phaser.Gamepad.XBOX360_RIGHT_BUMPER = 5; Phaser.Gamepad.XBOX360_LEFT_TRIGGER = 6; Phaser.Gamepad.XBOX360_RIGHT_TRIGGER = 7; Phaser.Gamepad.XBOX360_BACK = 8; Phaser.Gamepad.XBOX360_START = 9; Phaser.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10; Phaser.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11; Phaser.Gamepad.XBOX360_DPAD_LEFT = 14; Phaser.Gamepad.XBOX360_DPAD_RIGHT = 15; Phaser.Gamepad.XBOX360_DPAD_UP = 12; Phaser.Gamepad.XBOX360_DPAD_DOWN = 13; Phaser.Gamepad.XBOX360_STICK_LEFT_X = 0; Phaser.Gamepad.XBOX360_STICK_LEFT_Y = 1; Phaser.Gamepad.XBOX360_STICK_RIGHT_X = 2; Phaser.Gamepad.XBOX360_STICK_RIGHT_Y = 3; Phaser.Gamepad.PS3XC_X = 0; Phaser.Gamepad.PS3XC_CIRCLE = 1; Phaser.Gamepad.PS3XC_SQUARE = 2; Phaser.Gamepad.PS3XC_TRIANGLE = 3; Phaser.Gamepad.PS3XC_L1 = 4; Phaser.Gamepad.PS3XC_R1 = 5; Phaser.Gamepad.PS3XC_L2 = 6; Phaser.Gamepad.PS3XC_R2 = 7; Phaser.Gamepad.PS3XC_SELECT = 8; Phaser.Gamepad.PS3XC_START = 9; Phaser.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10; Phaser.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11; Phaser.Gamepad.PS3XC_DPAD_UP = 12; Phaser.Gamepad.PS3XC_DPAD_DOWN = 13; Phaser.Gamepad.PS3XC_DPAD_LEFT = 14; Phaser.Gamepad.PS3XC_DPAD_RIGHT = 15; Phaser.Gamepad.PS3XC_STICK_LEFT_X = 0; Phaser.Gamepad.PS3XC_STICK_LEFT_Y = 1; Phaser.Gamepad.PS3XC_STICK_RIGHT_X = 2; Phaser.Gamepad.PS3XC_STICK_RIGHT_Y = 3; Phaser.SinglePad = function (game, padParent) { this.game = game; this.index = null; this.connected = false; this.callbackContext = this; this.onConnectCallback = null; this.onDisconnectCallback = null; this.onDownCallback = null; this.onUpCallback = null; this.onAxisCallback = null; this.onFloatCallback = null; this.deadZone = 0.26; this._padParent = padParent; this._rawPad = null; this._prevTimestamp = null; this._buttons = []; this._buttonsLen = 0; this._axes = []; this._axesLen = 0; }; Phaser.SinglePad.prototype = { addCallbacks: function (context, callbacks) { if (typeof callbacks !== 'undefined') { this.onConnectCallback = (typeof callbacks.onConnect === 'function') ? callbacks.onConnect : this.onConnectCallback; this.onDisconnectCallback = (typeof callbacks.onDisconnect === 'function') ? callbacks.onDisconnect : this.onDisconnectCallback; this.onDownCallback = (typeof callbacks.onDown === 'function') ? callbacks.onDown : this.onDownCallback; this.onUpCallback = (typeof callbacks.onUp === 'function') ? callbacks.onUp : this.onUpCallback; this.onAxisCallback = (typeof callbacks.onAxis === 'function') ? callbacks.onAxis : this.onAxisCallback; this.onFloatCallback = (typeof callbacks.onFloat === 'function') ? callbacks.onFloat : this.onFloatCallback; this.callbackContext = context; } }, getButton: function (buttonCode) { if (this._buttons[buttonCode]) { return this._buttons[buttonCode]; } else { return null; } }, pollStatus: function () { if (!this.connected || !this.game.input.enabled || !this.game.input.gamepad.enabled || (this._rawPad.timestamp && (this._rawPad.timestamp === this._prevTimestamp))) { return; } for (var i = 0; i < this._buttonsLen; i++) { var rawButtonVal = isNaN(this._rawPad.buttons[i]) ? this._rawPad.buttons[i].value : this._rawPad.buttons[i]; if (rawButtonVal !== this._buttons[i].value) { if (rawButtonVal === 1) { this.processButtonDown(i, rawButtonVal); } else if (rawButtonVal === 0) { this.processButtonUp(i, rawButtonVal); } else { this.processButtonFloat(i, rawButtonVal); } } } for (var index = 0; index < this._axesLen; index++) { var value = this._rawPad.axes[index]; if ((value > 0 && value > this.deadZone) || (value < 0 && value < -this.deadZone)) { this.processAxisChange(index, value); } else { this.processAxisChange(index, 0); } } this._prevTimestamp = this._rawPad.timestamp; }, connect: function (rawPad) { var triggerCallback = !this.connected; this.connected = true; this.index = rawPad.index; this._rawPad = rawPad; this._buttons = []; this._buttonsLen = rawPad.buttons.length; this._axes = []; this._axesLen = rawPad.axes.length; for (var a = 0; a < this._axesLen; a++) { this._axes[a] = rawPad.axes[a]; } for (var buttonCode in rawPad.buttons) { buttonCode = parseInt(buttonCode, 10); this._buttons[buttonCode] = new Phaser.DeviceButton(this, buttonCode); } if (triggerCallback && this._padParent.onConnectCallback) { this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index); } if (triggerCallback && this.onConnectCallback) { this.onConnectCallback.call(this.callbackContext); } }, disconnect: function () { var triggerCallback = this.connected; var disconnectingIndex = this.index; this.connected = false; this.index = null; this._rawPad = undefined; for (var i = 0; i < this._buttonsLen; i++) { this._buttons[i].destroy(); } this._buttons = []; this._buttonsLen = 0; this._axes = []; this._axesLen = 0; if (triggerCallback && this._padParent.onDisconnectCallback) { this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, disconnectingIndex); } if (triggerCallback && this.onDisconnectCallback) { this.onDisconnectCallback.call(this.callbackContext); } }, destroy: function () { this._rawPad = undefined; for (var i = 0; i < this._buttonsLen; i++) { this._buttons[i].destroy(); } this._buttons = []; this._buttonsLen = 0; this._axes = []; this._axesLen = 0; this.onConnectCallback = null; this.onDisconnectCallback = null; this.onDownCallback = null; this.onUpCallback = null; this.onAxisCallback = null; this.onFloatCallback = null; }, processAxisChange: function (index, value) { if (this._axes[index] === value) { return; } this._axes[index] = value; if (this._padParent.onAxisCallback) { this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, index, value); } if (this.onAxisCallback) { this.onAxisCallback.call(this.callbackContext, this, index, value); } }, processButtonDown: function (buttonCode, value) { if (this._buttons[buttonCode]) { this._buttons[buttonCode].start(null, value); } if (this._padParent.onDownCallback) { this._padParent.onDownCallback.call(this._padParent.callbackContext, buttonCode, value, this.index); } if (this.onDownCallback) { this.onDownCallback.call(this.callbackContext, buttonCode, value); } }, processButtonUp: function (buttonCode, value) { if (this._padParent.onUpCallback) { this._padParent.onUpCallback.call(this._padParent.callbackContext, buttonCode, value, this.index); } if (this.onUpCallback) { this.onUpCallback.call(this.callbackContext, buttonCode, value); } if (this._buttons[buttonCode]) { this._buttons[buttonCode].stop(null, value); } }, processButtonFloat: function (buttonCode, value) { if (this._padParent.onFloatCallback) { this._padParent.onFloatCallback.call(this._padParent.callbackContext, buttonCode, value, this.index); } if (this.onFloatCallback) { this.onFloatCallback.call(this.callbackContext, buttonCode, value); } if (this._buttons[buttonCode]) { this._buttons[buttonCode].padFloat(value); } }, axis: function (axisCode) { if (this._axes[axisCode]) { return this._axes[axisCode]; } return false; }, isDown: function (buttonCode) { if (this._buttons[buttonCode]) { return this._buttons[buttonCode].isDown; } return false; }, isUp: function (buttonCode) { if (this._buttons[buttonCode]) { return this._buttons[buttonCode].isUp; } return false; }, justReleased: function (buttonCode, duration) { if (this._buttons[buttonCode]) { return this._buttons[buttonCode].justReleased(duration); } }, justPressed: function (buttonCode, duration) { if (this._buttons[buttonCode]) { return this._buttons[buttonCode].justPressed(duration); } }, buttonValue: function (buttonCode) { if (this._buttons[buttonCode]) { return this._buttons[buttonCode].value; } return null; }, reset: function () { for (var j = 0; j < this._axes.length; j++) { this._axes[j] = 0; } } }; Phaser.SinglePad.prototype.constructor = Phaser.SinglePad; Phaser.Key = function (game, keycode) { this.game = game; this._enabled = true; this.event = null; this.isDown = false; this.isUp = true; this.altKey = false; this.ctrlKey = false; this.shiftKey = false; this.timeDown = 0; this.duration = 0; this.timeUp = -2500; this.repeats = 0; this.keyCode = keycode; this.onDown = new Phaser.Signal(); this.onHoldCallback = null; this.onHoldContext = null; this.onUp = new Phaser.Signal(); this._justDown = false; this._justUp = false; }; Phaser.Key.prototype = { update: function () { if (!this._enabled) { return; } if (this.isDown) { this.duration = this.game.time.time - this.timeDown; this.repeats++; if (this.onHoldCallback) { this.onHoldCallback.call(this.onHoldContext, this); } } }, processKeyDown: function (event) { if (!this._enabled) { return; } this.event = event; if (this.isDown) { return; } this.altKey = event.altKey; this.ctrlKey = event.ctrlKey; this.shiftKey = event.shiftKey; this.isDown = true; this.isUp = false; this.timeDown = this.game.time.time; this.duration = 0; this.repeats = 0; this._justDown = true; this.onDown.dispatch(this); }, processKeyUp: function (event) { if (!this._enabled) { return; } this.event = event; if (this.isUp) { return; } this.isDown = false; this.isUp = true; this.timeUp = this.game.time.time; this.duration = this.game.time.time - this.timeDown; this._justUp = true; this.onUp.dispatch(this); }, reset: function (hard) { if (hard === undefined) { hard = true; } this.isDown = false; this.isUp = true; this.timeUp = this.game.time.time; this.duration = 0; this._enabled = true; this._justDown = false; this._justUp = false; if (hard) { this.onDown.removeAll(); this.onUp.removeAll(); this.onHoldCallback = null; this.onHoldContext = null; } }, downDuration: function (duration) { if (duration === undefined) { duration = 50; } return (this.isDown && this.duration < duration); }, upDuration: function (duration) { if (duration === undefined) { duration = 50; } return (!this.isDown && ((this.game.time.time - this.timeUp) < duration)); } }; Object.defineProperty(Phaser.Key.prototype, "justDown", { get: function () { var current = this._justDown; this._justDown = false; return current; } }); Object.defineProperty(Phaser.Key.prototype, "justUp", { get: function () { var current = this._justUp; this._justUp = false; return current; } }); Object.defineProperty(Phaser.Key.prototype, "enabled", { get: function () { return this._enabled; }, set: function (value) { value = !!value; if (value !== this._enabled) { if (!value) { this.reset(false); } this._enabled = value; } } }); Phaser.Key.prototype.constructor = Phaser.Key; Phaser.Keyboard = function (game) { this.game = game; this.enabled = true; this.event = null; this.pressEvent = null; this.callbackContext = this; this.onDownCallback = null; this.onPressCallback = null; this.onUpCallback = null; this._keys = []; this._capture = []; this._onKeyDown = null; this._onKeyPress = null; this._onKeyUp = null; this._i = 0; this._k = 0; }; Phaser.Keyboard.prototype = { addCallbacks: function (context, onDown, onUp, onPress) { this.callbackContext = context; if (onDown !== undefined && onDown !== null) { this.onDownCallback = onDown; } if (onUp !== undefined && onUp !== null) { this.onUpCallback = onUp; } if (onPress !== undefined && onPress !== null) { this.onPressCallback = onPress; } }, addKey: function (keycode) { if (!this._keys[keycode]) { this._keys[keycode] = new Phaser.Key(this.game, keycode); this.addKeyCapture(keycode); } return this._keys[keycode]; }, addKeys: function (keys) { var output = {}; for (var key in keys) { output[key] = this.addKey(keys[key]); } return output; }, removeKey: function (keycode) { if (this._keys[keycode]) { this._keys[keycode] = null; this.removeKeyCapture(keycode); } }, createCursorKeys: function () { return this.addKeys({ 'up': Phaser.KeyCode.UP, 'down': Phaser.KeyCode.DOWN, 'left': Phaser.KeyCode.LEFT, 'right': Phaser.KeyCode.RIGHT }); }, start: function () { if (this.game.device.cocoonJS) { return; } if (this._onKeyDown !== null) { return; } var _this = this; this._onKeyDown = function (event) { return _this.processKeyDown(event); }; this._onKeyUp = function (event) { return _this.processKeyUp(event); }; this._onKeyPress = function (event) { return _this.processKeyPress(event); }; window.addEventListener('keydown', this._onKeyDown, false); window.addEventListener('keyup', this._onKeyUp, false); window.addEventListener('keypress', this._onKeyPress, false); }, stop: function () { window.removeEventListener('keydown', this._onKeyDown); window.removeEventListener('keyup', this._onKeyUp); window.removeEventListener('keypress', this._onKeyPress); this._onKeyDown = null; this._onKeyUp = null; this._onKeyPress = null; }, destroy: function () { this.stop(); this.clearCaptures(); this._keys.length = 0; this._i = 0; }, addKeyCapture: function (keycode) { if (typeof keycode === 'object') { for (var key in keycode) { this._capture[keycode[key]] = true; } } else { this._capture[keycode] = true; } }, removeKeyCapture: function (keycode) { delete this._capture[keycode]; }, clearCaptures: function () { this._capture = {}; }, update: function () { this._i = this._keys.length; while (this._i--) { if (this._keys[this._i]) { this._keys[this._i].update(); } } }, processKeyDown: function (event) { this.event = event; if (!this.game.input.enabled || !this.enabled) { return; } var key = event.keyCode; if (this._capture[key]) { event.preventDefault(); } if (!this._keys[key]) { this._keys[key] = new Phaser.Key(this.game, key); } this._keys[key].processKeyDown(event); this._k = key; if (this.onDownCallback) { this.onDownCallback.call(this.callbackContext, event); } }, processKeyPress: function (event) { this.pressEvent = event; if (!this.game.input.enabled || !this.enabled) { return; } if (this.onPressCallback) { this.onPressCallback.call(this.callbackContext, String.fromCharCode(event.charCode), event); } }, processKeyUp: function (event) { this.event = event; if (!this.game.input.enabled || !this.enabled) { return; } var key = event.keyCode; if (this._capture[key]) { event.preventDefault(); } if (!this._keys[key]) { this._keys[key] = new Phaser.Key(this.game, key); } this._keys[key].processKeyUp(event); if (this.onUpCallback) { this.onUpCallback.call(this.callbackContext, event); } }, reset: function (hard) { if (hard === undefined) { hard = true; } this.event = null; var i = this._keys.length; while (i--) { if (this._keys[i]) { this._keys[i].reset(hard); } } }, downDuration: function (keycode, duration) { if (this._keys[keycode]) { return this._keys[keycode].downDuration(duration); } else { return null; } }, upDuration: function (keycode, duration) { if (this._keys[keycode]) { return this._keys[keycode].upDuration(duration); } else { return null; } }, isDown: function (keycode) { if (this._keys[keycode]) { return this._keys[keycode].isDown; } else { return null; } } }; Object.defineProperty(Phaser.Keyboard.prototype, "lastChar", { get: function () { if (this.event.charCode === 32) { return ''; } else { return String.fromCharCode(this.pressEvent.charCode); } } }); Object.defineProperty(Phaser.Keyboard.prototype, "lastKey", { get: function () { return this._keys[this._k]; } }); Phaser.Keyboard.prototype.constructor = Phaser.Keyboard; Phaser.KeyCode = { A: "A".charCodeAt(0), B: "B".charCodeAt(0), C: "C".charCodeAt(0), D: "D".charCodeAt(0), E: "E".charCodeAt(0), F: "F".charCodeAt(0), G: "G".charCodeAt(0), H: "H".charCodeAt(0), I: "I".charCodeAt(0), J: "J".charCodeAt(0), K: "K".charCodeAt(0), L: "L".charCodeAt(0), M: "M".charCodeAt(0), N: "N".charCodeAt(0), O: "O".charCodeAt(0), P: "P".charCodeAt(0), Q: "Q".charCodeAt(0), R: "R".charCodeAt(0), S: "S".charCodeAt(0), T: "T".charCodeAt(0), U: "U".charCodeAt(0), V: "V".charCodeAt(0), W: "W".charCodeAt(0), X: "X".charCodeAt(0), Y: "Y".charCodeAt(0), Z: "Z".charCodeAt(0), ZERO: "0".charCodeAt(0), ONE: "1".charCodeAt(0), TWO: "2".charCodeAt(0), THREE: "3".charCodeAt(0), FOUR: "4".charCodeAt(0), FIVE: "5".charCodeAt(0), SIX: "6".charCodeAt(0), SEVEN: "7".charCodeAt(0), EIGHT: "8".charCodeAt(0), NINE: "9".charCodeAt(0), NUMPAD_0: 96, NUMPAD_1: 97, NUMPAD_2: 98, NUMPAD_3: 99, NUMPAD_4: 100, NUMPAD_5: 101, NUMPAD_6: 102, NUMPAD_7: 103, NUMPAD_8: 104, NUMPAD_9: 105, NUMPAD_MULTIPLY: 106, NUMPAD_ADD: 107, NUMPAD_ENTER: 108, NUMPAD_SUBTRACT: 109, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, F13: 124, F14: 125, F15: 126, COLON: 186, EQUALS: 187, COMMA: 188, UNDERSCORE: 189, PERIOD: 190, QUESTION_MARK: 191, TILDE: 192, OPEN_BRACKET: 219, BACKWARD_SLASH: 220, CLOSED_BRACKET: 221, QUOTES: 222, BACKSPACE: 8, TAB: 9, CLEAR: 12, ENTER: 13, SHIFT: 16, CONTROL: 17, ALT: 18, CAPS_LOCK: 20, ESC: 27, SPACEBAR: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PLUS: 43, MINUS: 44, INSERT: 45, DELETE: 46, HELP: 47, NUM_LOCK: 144 }; for (var key in Phaser.KeyCode) { if (Phaser.KeyCode.hasOwnProperty(key) && !key.match(/[a-z]/)) { Phaser.Keyboard[key] = Phaser.KeyCode[key]; } } Phaser.Component = function () {}; Phaser.Component.Angle = function () {}; Phaser.Component.Angle.prototype = { angle: { get: function() { return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.rotation)); }, set: function(value) { this.rotation = Phaser.Math.degToRad(Phaser.Math.wrapAngle(value)); } } }; Phaser.Component.Animation = function () {}; Phaser.Component.Animation.prototype = { play: function (name, frameRate, loop, killOnComplete) { if (this.animations) { return this.animations.play(name, frameRate, loop, killOnComplete); } } }; Phaser.Component.AutoCull = function () {}; Phaser.Component.AutoCull.prototype = { autoCull: false, inCamera: { get: function() { if (!this.autoCull && !this.checkWorldBounds) { this._bounds.copyFrom(this.getBounds()); this._bounds.x += this.game.camera.view.x; this._bounds.y += this.game.camera.view.y; } return this.game.world.camera.view.intersects(this._bounds); } } }; Phaser.Component.Bounds = function () {}; Phaser.Component.Bounds.prototype = { offsetX: { get: function () { return this.anchor.x * this.width; } }, offsetY: { get: function () { return this.anchor.y * this.height; } }, centerX: { get: function () { return (this.x - this.offsetX) + (this.width * 0.5); }, set: function (value) { this.x = (value + this.offsetX) - (this.width * 0.5); } }, centerY: { get: function () { return (this.y - this.offsetY) + (this.height * 0.5); }, set: function (value) { this.y = (value + this.offsetY) - (this.height * 0.5); } }, left: { get: function () { return this.x - this.offsetX; }, set: function (value) { this.x = value + this.offsetX; } }, right: { get: function () { return (this.x + this.width) - this.offsetX; }, set: function (value) { this.x = value - (this.width) + this.offsetX; } }, top: { get: function () { return this.y - this.offsetY; }, set: function (value) { this.y = value + this.offsetY; } }, bottom: { get: function () { return (this.y + this.height) - this.offsetY; }, set: function (value) { this.y = value - (this.height) + this.offsetY; } }, alignIn: function (container, position, offsetX, offsetY) { if (offsetX === undefined) { offsetX = 0; } if (offsetY === undefined) { offsetY = 0; } switch (position) { default: case Phaser.TOP_LEFT: this.left = container.left - offsetX; this.top = container.top - offsetY; break; case Phaser.TOP_CENTER: this.centerX = container.centerX + offsetX; this.top = container.top - offsetY; break; case Phaser.TOP_RIGHT: this.right = container.right + offsetX; this.top = container.top - offsetY; break; case Phaser.LEFT_CENTER: this.left = container.left - offsetX; this.centerY = container.centerY + offsetY; break; case Phaser.CENTER: this.centerX = container.centerX + offsetX; this.centerY = container.centerY + offsetY; break; case Phaser.RIGHT_CENTER: this.right = container.right + offsetX; this.centerY = container.centerY + offsetY; break; case Phaser.BOTTOM_LEFT: this.left = container.left - offsetX; this.bottom = container.bottom + offsetY; break; case Phaser.BOTTOM_CENTER: this.centerX = container.centerX + offsetX; this.bottom = container.bottom + offsetY; break; case Phaser.BOTTOM_RIGHT: this.right = container.right + offsetX; this.bottom = container.bottom + offsetY; break; } return this; }, alignTo: function (parent, position, offsetX, offsetY) { if (offsetX === undefined) { offsetX = 0; } if (offsetY === undefined) { offsetY = 0; } switch (position) { default: case Phaser.TOP_LEFT: this.left = parent.left - offsetX; this.bottom = parent.top - offsetY; break; case Phaser.TOP_CENTER: this.centerX = parent.centerX + offsetX; this.bottom = parent.top - offsetY; break; case Phaser.TOP_RIGHT: this.right = parent.right + offsetX; this.bottom = parent.top - offsetY; break; case Phaser.LEFT_TOP: this.right = parent.left - offsetX; this.top = parent.top - offsetY; break; case Phaser.LEFT_CENTER: this.right = parent.left - offsetX; this.centerY = parent.centerY + offsetY; break; case Phaser.LEFT_BOTTOM: this.right = parent.left - offsetX; this.bottom = parent.bottom + offsetY; break; case Phaser.RIGHT_TOP: this.left = parent.right + offsetX; this.top = parent.top - offsetY; break; case Phaser.RIGHT_CENTER: this.left = parent.right + offsetX; this.centerY = parent.centerY + offsetY; break; case Phaser.RIGHT_BOTTOM: this.left = parent.right + offsetX; this.bottom = parent.bottom + offsetY; break; case Phaser.BOTTOM_LEFT: this.left = parent.left - offsetX; this.top = parent.bottom + offsetY; break; case Phaser.BOTTOM_CENTER: this.centerX = parent.centerX + offsetX; this.top = parent.bottom + offsetY; break; case Phaser.BOTTOM_RIGHT: this.right = parent.right + offsetX; this.top = parent.bottom + offsetY; break; } return this; } }; Phaser.Group.prototype.alignIn = Phaser.Component.Bounds.prototype.alignIn; Phaser.Group.prototype.alignTo = Phaser.Component.Bounds.prototype.alignTo; Phaser.Component.BringToTop = function () {}; Phaser.Component.BringToTop.prototype.bringToTop = function() { if (this.parent) { this.parent.bringToTop(this); } return this; }; Phaser.Component.BringToTop.prototype.sendToBack = function() { if (this.parent) { this.parent.sendToBack(this); } return this; }; Phaser.Component.BringToTop.prototype.moveUp = function () { if (this.parent) { this.parent.moveUp(this); } return this; }; Phaser.Component.BringToTop.prototype.moveDown = function () { if (this.parent) { this.parent.moveDown(this); } return this; }; Phaser.Component.Core = function () {}; Phaser.Component.Core.install = function (components) { Phaser.Utils.mixinPrototype(this, Phaser.Component.Core.prototype); this.components = {}; for (var i = 0; i < components.length; i++) { var id = components[i]; var replace = false; if (id === 'Destroy') { replace = true; } Phaser.Utils.mixinPrototype(this, Phaser.Component[id].prototype, replace); this.components[id] = true; } }; Phaser.Component.Core.init = function (game, x, y, key, frame) { this.game = game; this.key = key; this.data = {}; this.position.set(x, y); this.world = new Phaser.Point(x, y); this.previousPosition = new Phaser.Point(x, y); this.events = new Phaser.Events(this); this._bounds = new Phaser.Rectangle(); if (this.components.PhysicsBody) { this.body = this.body; } if (this.components.Animation) { this.animations = new Phaser.AnimationManager(this); } if (this.components.LoadTexture && key !== null) { this.loadTexture(key, frame); } if (this.components.FixedToCamera) { this.cameraOffset = new Phaser.Point(x, y); } }; Phaser.Component.Core.preUpdate = function () { if (this.pendingDestroy) { this.destroy(); return; } this.previousPosition.set(this.world.x, this.world.y); this.previousRotation = this.rotation; if (!this.exists || !this.parent.exists) { this.renderOrderID = -1; return false; } this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty); if (this.visible) { this.renderOrderID = this.game.stage.currentRenderOrderID++; } if (this.animations) { this.animations.update(); } if (this.body) { this.body.preUpdate(); } for (var i = 0; i < this.children.length; i++) { this.children[i].preUpdate(); } return true; }; Phaser.Component.Core.prototype = { game: null, name: '', data: {}, components: {}, z: 0, events: undefined, animations: undefined, key: '', world: null, debug: false, previousPosition: null, previousRotation: 0, renderOrderID: 0, fresh: true, pendingDestroy: false, _bounds: null, _exists: true, exists: { get: function () { return this._exists; }, set: function (value) { if (value) { this._exists = true; if (this.body && this.body.type === Phaser.Physics.P2JS) { this.body.addToWorld(); } this.visible = true; } else { this._exists = false; if (this.body && this.body.type === Phaser.Physics.P2JS) { this.body.removeFromWorld(); } this.visible = false; } } }, update: function() { }, postUpdate: function() { if (this.customRender) { this.key.render(); } if (this.components.PhysicsBody) { Phaser.Component.PhysicsBody.postUpdate.call(this); } if (this.components.FixedToCamera) { Phaser.Component.FixedToCamera.postUpdate.call(this); } for (var i = 0; i < this.children.length; i++) { this.children[i].postUpdate(); } } }; Phaser.Component.Crop = function () {}; Phaser.Component.Crop.prototype = { cropRect: null, _crop: null, crop: function (rect, copy) { if (copy === undefined) { copy = false; } if (rect) { if (copy && this.cropRect !== null) { this.cropRect.setTo(rect.x, rect.y, rect.width, rect.height); } else if (copy && this.cropRect === null) { this.cropRect = new Phaser.Rectangle(rect.x, rect.y, rect.width, rect.height); } else { this.cropRect = rect; } this.updateCrop(); } else { this._crop = null; this.cropRect = null; this.resetFrame(); } }, updateCrop: function () { if (!this.cropRect) { return; } var oldX = this.texture.crop.x; var oldY = this.texture.crop.y; var oldW = this.texture.crop.width; var oldH = this.texture.crop.height; this._crop = Phaser.Rectangle.clone(this.cropRect, this._crop); this._crop.x += this._frame.x; this._crop.y += this._frame.y; var cx = Math.max(this._frame.x, this._crop.x); var cy = Math.max(this._frame.y, this._crop.y); var cw = Math.min(this._frame.right, this._crop.right) - cx; var ch = Math.min(this._frame.bottom, this._crop.bottom) - cy; this.texture.crop.x = cx; this.texture.crop.y = cy; this.texture.crop.width = cw; this.texture.crop.height = ch; this.texture.frame.width = Math.min(cw, this.cropRect.width); this.texture.frame.height = Math.min(ch, this.cropRect.height); this.texture.width = this.texture.frame.width; this.texture.height = this.texture.frame.height; this.texture._updateUvs(); if (this.tint !== 0xffffff && (oldX !== cx || oldY !== cy || oldW !== cw || oldH !== ch)) { this.texture.requiresReTint = true; } } }; Phaser.Component.Delta = function () {}; Phaser.Component.Delta.prototype = { deltaX: { get: function() { return this.world.x - this.previousPosition.x; } }, deltaY: { get: function() { return this.world.y - this.previousPosition.y; } }, deltaZ: { get: function() { return this.rotation - this.previousRotation; } } }; Phaser.Component.Destroy = function () {}; Phaser.Component.Destroy.prototype = { destroyPhase: false, destroy: function (destroyChildren, destroyTexture) { if (this.game === null || this.destroyPhase) { return; } if (destroyChildren === undefined) { destroyChildren = true; } if (destroyTexture === undefined) { destroyTexture = false; } this.destroyPhase = true; if (this.events) { this.events.onDestroy$dispatch(this); } if (this.parent) { if (this.parent instanceof Phaser.Group) { this.parent.remove(this); } else { this.parent.removeChild(this); } } if (this.input) { this.input.destroy(); } if (this.animations) { this.animations.destroy(); } if (this.body) { this.body.destroy(); } if (this.events) { this.events.destroy(); } this.game.tweens.removeFrom(this); var i = this.children.length; if (destroyChildren) { while (i--) { this.children[i].destroy(destroyChildren); } } else { while (i--) { this.removeChild(this.children[i]); } } if (this._crop) { this._crop = null; this.cropRect = null; } if (this._frame) { this._frame = null; } if (Phaser.Video && this.key instanceof Phaser.Video) { this.key.onChangeSource.remove(this.resizeFrame, this); } if (Phaser.BitmapText && this._glyphs) { this._glyphs = []; } this.alive = false; this.exists = false; this.visible = false; this.filters = null; this.mask = null; this.game = null; this.data = {}; this.renderable = false; if (this.transformCallback) { this.transformCallback = null; this.transformCallbackContext = null; } this.hitArea = null; this.parent = null; this.stage = null; this.worldTransform = null; this.filterArea = null; this._bounds = null; this._currentBounds = null; this._mask = null; this._destroyCachedSprite(); if (destroyTexture) { this.texture.destroy(true); } this.destroyPhase = false; this.pendingDestroy = false; } }; Phaser.Events = function (sprite) { this.parent = sprite; }; Phaser.Events.prototype = { destroy: function () { this._parent = null; if (this._onDestroy)           { this._onDestroy.dispose(); } if (this._onAddedToGroup)      { this._onAddedToGroup.dispose(); } if (this._onRemovedFromGroup)  { this._onRemovedFromGroup.dispose(); } if (this._onRemovedFromWorld)  { this._onRemovedFromWorld.dispose(); } if (this._onKilled)            { this._onKilled.dispose(); } if (this._onRevived)           { this._onRevived.dispose(); } if (this._onEnterBounds)       { this._onEnterBounds.dispose(); } if (this._onOutOfBounds)       { this._onOutOfBounds.dispose(); } if (this._onInputOver)         { this._onInputOver.dispose(); } if (this._onInputOut)          { this._onInputOut.dispose(); } if (this._onInputDown)         { this._onInputDown.dispose(); } if (this._onInputUp)           { this._onInputUp.dispose(); } if (this._onDragStart)         { this._onDragStart.dispose(); } if (this._onDragUpdate)        { this._onDragUpdate.dispose(); } if (this._onDragStop)          { this._onDragStop.dispose(); } if (this._onAnimationStart)    { this._onAnimationStart.dispose(); } if (this._onAnimationComplete) { this._onAnimationComplete.dispose(); } if (this._onAnimationLoop)     { this._onAnimationLoop.dispose(); } }, onAddedToGroup: null, onRemovedFromGroup: null, onRemovedFromWorld: null, onDestroy: null, onKilled: null, onRevived: null, onOutOfBounds: null, onEnterBounds: null, onInputOver: null, onInputOut: null, onInputDown: null, onInputUp: null, onDragStart: null, onDragUpdate: null, onDragStop: null, onAnimationStart: null, onAnimationComplete: null, onAnimationLoop: null }; Phaser.Events.prototype.constructor = Phaser.Events; for (var prop in Phaser.Events.prototype) { if (!Phaser.Events.prototype.hasOwnProperty(prop) || prop.indexOf('on') !== 0 || Phaser.Events.prototype[prop] !== null) { continue; } (function (prop, backing) { 'use strict'; Object.defineProperty(Phaser.Events.prototype, prop, { get: function () { return this[backing] || (this[backing] = new Phaser.Signal()); } }); Phaser.Events.prototype[prop + '$dispatch'] = function () { return this[backing] ? this[backing].dispatch.apply(this[backing], arguments) : null; }; })(prop, '_' + prop); } Phaser.Component.FixedToCamera = function () {}; Phaser.Component.FixedToCamera.postUpdate = function () { if (this.fixedToCamera) { this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x; this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y; } }; Phaser.Component.FixedToCamera.prototype = { _fixedToCamera: false, fixedToCamera: { get: function () { return this._fixedToCamera; }, set: function (value) { if (value) { this._fixedToCamera = true; this.cameraOffset.set(this.x, this.y); } else { this._fixedToCamera = false; } } }, cameraOffset: new Phaser.Point() }; Phaser.Component.Health = function () {}; Phaser.Component.Health.prototype = { health: 1, maxHealth: 100, damage: function (amount) { if (this.alive) { this.health -= amount; if (this.health <= 0) { this.kill(); } } return this; }, setHealth: function (amount) { this.health = amount; if (this.health > this.maxHealth) { this.health = this.maxHealth; } return this; }, heal: function (amount) { if (this.alive) { this.health += amount; if (this.health > this.maxHealth) { this.health = this.maxHealth; } } return this; } }; Phaser.Component.InCamera = function () {}; Phaser.Component.InCamera.prototype = { inCamera: { get: function() { return this.game.world.camera.view.intersects(this._bounds); } } }; Phaser.Component.InputEnabled = function () {}; Phaser.Component.InputEnabled.prototype = { input: null, inputEnabled: { get: function () { return (this.input && this.input.enabled); }, set: function (value) { if (value) { if (this.input === null) { this.input = new Phaser.InputHandler(this); this.input.start(); } else if (this.input && !this.input.enabled) { this.input.start(); } } else { if (this.input && this.input.enabled) { this.input.stop(); } } } } }; Phaser.Component.InWorld = function () {}; Phaser.Component.InWorld.preUpdate = function () { if (this.autoCull || this.checkWorldBounds) { this._bounds.copyFrom(this.getBounds()); this._bounds.x += this.game.camera.view.x; this._bounds.y += this.game.camera.view.y; if (this.autoCull) { if (this.game.world.camera.view.intersects(this._bounds)) { this.renderable = true; this.game.world.camera.totalInView++; } else { this.renderable = false; if (this.outOfCameraBoundsKill) { this.kill(); return false; } } } if (this.checkWorldBounds) { if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) { this._outOfBoundsFired = false; this.events.onEnterBounds$dispatch(this); } else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds)) { this._outOfBoundsFired = true; this.events.onOutOfBounds$dispatch(this); if (this.outOfBoundsKill) { this.kill(); return false; } } } } return true; }; Phaser.Component.InWorld.prototype = { checkWorldBounds: false, outOfBoundsKill: false, outOfCameraBoundsKill: false, _outOfBoundsFired: false, inWorld: { get: function () { return this.game.world.bounds.intersects(this.getBounds()); } } }; Phaser.Component.LifeSpan = function () {}; Phaser.Component.LifeSpan.preUpdate = function () { if (this.lifespan > 0) { this.lifespan -= this.game.time.physicsElapsedMS; if (this.lifespan <= 0) { this.kill(); return false; } } return true; }; Phaser.Component.LifeSpan.prototype = { alive: true, lifespan: 0, revive: function (health) { if (health === undefined) { health = 100; } this.alive = true; this.exists = true; this.visible = true; if (typeof this.setHealth === 'function') { this.setHealth(health); } if (this.events) { this.events.onRevived$dispatch(this); } return this; }, kill: function () { this.alive = false; this.exists = false; this.visible = false; if (this.events) { this.events.onKilled$dispatch(this); } return this; } }; Phaser.Component.LoadTexture = function () {}; Phaser.Component.LoadTexture.prototype = { customRender: false, _frame: null, loadTexture: function (key, frame, stopAnimation) { if (key === Phaser.PENDING_ATLAS) { key = frame; frame = 0; } else { frame = frame || 0; } if ((stopAnimation || stopAnimation === undefined) && this.animations) { this.animations.stop(); } this.key = key; this.customRender = false; var cache = this.game.cache; var setFrame = true; var smoothed = !this.texture.baseTexture.scaleMode; if (Phaser.RenderTexture && key instanceof Phaser.RenderTexture) { this.key = key.key; this.setTexture(key); } else if (Phaser.BitmapData && key instanceof Phaser.BitmapData) { this.customRender = true; this.setTexture(key.texture); if (cache.hasFrameData(key.key, Phaser.Cache.BITMAPDATA)) { setFrame = !this.animations.loadFrameData(cache.getFrameData(key.key, Phaser.Cache.BITMAPDATA), frame); } else { setFrame = !this.animations.loadFrameData(key.frameData, 0); } } else if (Phaser.Video && key instanceof Phaser.Video) { this.customRender = true; var valid = key.texture.valid; this.setTexture(key.texture); this.setFrame(key.texture.frame.clone()); key.onChangeSource.add(this.resizeFrame, this); this.texture.valid = valid; } else if (Phaser.Tilemap && key instanceof Phaser.TilemapLayer) { this.setTexture(PIXI.Texture.fromCanvas(key.canvas)); } else if (key instanceof PIXI.Texture) { this.setTexture(key); } else { var img = cache.getImage(key, true); this.key = img.key; this.setTexture(new PIXI.Texture(img.base)); if (key === '__default') { this.texture.baseTexture.skipRender = true; } else { this.texture.baseTexture.skipRender = false; } setFrame = !this.animations.loadFrameData(img.frameData, frame); } if (setFrame) { this._frame = Phaser.Rectangle.clone(this.texture.frame); } if (!smoothed) { this.texture.baseTexture.scaleMode = 1; } }, setFrame: function (frame) { this._frame = frame; this.texture.frame.x = frame.x; this.texture.frame.y = frame.y; this.texture.frame.width = frame.width; this.texture.frame.height = frame.height; this.texture.crop.x = frame.x; this.texture.crop.y = frame.y; this.texture.crop.width = frame.width; this.texture.crop.height = frame.height; if (frame.trimmed) { if (this.texture.trim) { this.texture.trim.x = frame.spriteSourceSizeX; this.texture.trim.y = frame.spriteSourceSizeY; this.texture.trim.width = frame.sourceSizeW; this.texture.trim.height = frame.sourceSizeH; } else { this.texture.trim = { x: frame.spriteSourceSizeX, y: frame.spriteSourceSizeY, width: frame.sourceSizeW, height: frame.sourceSizeH }; } this.texture.width = frame.sourceSizeW; this.texture.height = frame.sourceSizeH; this.texture.frame.width = frame.sourceSizeW; this.texture.frame.height = frame.sourceSizeH; } else if (!frame.trimmed && this.texture.trim) { this.texture.trim = null; } if (this.cropRect) { this.updateCrop(); } this.texture.requiresReTint = true; this.texture._updateUvs(); if (this.tilingTexture) { this.refreshTexture = true; } }, resizeFrame: function (parent, width, height) { this.texture.frame.resize(width, height); this.texture.setFrame(this.texture.frame); }, resetFrame: function () { if (this._frame) { this.setFrame(this._frame); } }, frame: { get: function () { return this.animations.frame; }, set: function (value) { this.animations.frame = value; } }, frameName: { get: function () { return this.animations.frameName; }, set: function (value) { this.animations.frameName = value; } } }; Phaser.Component.Overlap = function () {}; Phaser.Component.Overlap.prototype = { overlap: function (displayObject) { return Phaser.Rectangle.intersects(this.getBounds(), displayObject.getBounds()); } }; Phaser.Component.PhysicsBody = function () {}; Phaser.Component.PhysicsBody.preUpdate = function () { if (this.fresh && this.exists) { this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y); this.worldTransform.tx = this.world.x; this.worldTransform.ty = this.world.y; this.previousPosition.set(this.world.x, this.world.y); this.previousRotation = this.rotation; if (this.body) { this.body.preUpdate(); } this.fresh = false; return false; } this.previousPosition.set(this.world.x, this.world.y); this.previousRotation = this.rotation; if (!this._exists || !this.parent.exists) { this.renderOrderID = -1; return false; } return true; }; Phaser.Component.PhysicsBody.postUpdate = function () { if (this.exists && this.body) { this.body.postUpdate(); } }; Phaser.Component.PhysicsBody.prototype = { body: null, x: { get: function () { return this.position.x; }, set: function (value) { this.position.x = value; if (this.body && !this.body.dirty) { this.body._reset = true; } } }, y: { get: function () { return this.position.y; }, set: function (value) { this.position.y = value; if (this.body && !this.body.dirty) { this.body._reset = true; } } } }; Phaser.Component.Reset = function () {}; Phaser.Component.Reset.prototype.reset = function (x, y, health) { if (health === undefined) { health = 1; } this.world.set(x, y); this.position.set(x, y); this.fresh = true; this.exists = true; this.visible = true; this.renderable = true; if (this.components.InWorld) { this._outOfBoundsFired = false; } if (this.components.LifeSpan) { this.alive = true; this.health = health; } if (this.components.PhysicsBody) { if (this.body) { this.body.reset(x, y, false, false); } } return this; }; Phaser.Component.ScaleMinMax = function () {}; Phaser.Component.ScaleMinMax.prototype = { transformCallback: null, transformCallbackContext: this, scaleMin: null, scaleMax: null, checkTransform: function (wt) { if (this.scaleMin) { if (wt.a < this.scaleMin.x) { wt.a = this.scaleMin.x; } if (wt.d < this.scaleMin.y) { wt.d = this.scaleMin.y; } } if (this.scaleMax) { if (wt.a > this.scaleMax.x) { wt.a = this.scaleMax.x; } if (wt.d > this.scaleMax.y) { wt.d = this.scaleMax.y; } } }, setScaleMinMax: function (minX, minY, maxX, maxY) { if (minY === undefined) { minY = maxX = maxY = minX; } else if (maxX === undefined) { maxX = maxY = minY; minY = minX; } if (minX === null) { this.scaleMin = null; } else { if (this.scaleMin) { this.scaleMin.set(minX, minY); } else { this.scaleMin = new Phaser.Point(minX, minY); } } if (maxX === null) { this.scaleMax = null; } else { if (this.scaleMax) { this.scaleMax.set(maxX, maxY); } else { this.scaleMax = new Phaser.Point(maxX, maxY); } } if (this.scaleMin === null) { this.transformCallback = null; } else { this.transformCallback = this.checkTransform; this.transformCallbackContext = this; } } }; Phaser.Component.Smoothed = function () {}; Phaser.Component.Smoothed.prototype = { smoothed: { get: function () { return !this.texture.baseTexture.scaleMode; }, set: function (value) { if (value) { if (this.texture) { this.texture.baseTexture.scaleMode = 0; } } else { if (this.texture) { this.texture.baseTexture.scaleMode = 1; } } } } }; Phaser.GameObjectFactory = function (game) { this.game = game; this.world = this.game.world; }; Phaser.GameObjectFactory.prototype = { existing: function (object) { return this.world.add(object); }, weapon: function (quantity, key, frame, group) { var weapon = this.game.plugins.add(Phaser.Weapon); weapon.createBullets(quantity, key, frame, group); return weapon; }, image: function (x, y, key, frame, group) { if (group === undefined) { group = this.world; } return group.add(new Phaser.Image(this.game, x, y, key, frame)); }, sprite: function (x, y, key, frame, group) { if (group === undefined) { group = this.world; } return group.create(x, y, key, frame); }, creature: function (x, y, key, mesh, group) { if (group === undefined) { group = this.world; } var obj = new Phaser.Creature(this.game, x, y, key, mesh); group.add(obj); return obj; }, tween: function (object) { return this.game.tweens.create(object); }, group: function (parent, name, addToStage, enableBody, physicsBodyType) { return new Phaser.Group(this.game, parent, name, addToStage, enableBody, physicsBodyType); }, physicsGroup: function (physicsBodyType, parent, name, addToStage) { return new Phaser.Group(this.game, parent, name, addToStage, true, physicsBodyType); }, spriteBatch: function (parent, name, addToStage) { if (parent === undefined) { parent = null; } if (name === undefined) { name = 'group'; } if (addToStage === undefined) { addToStage = false; } return new Phaser.SpriteBatch(this.game, parent, name, addToStage); }, audio: function (key, volume, loop, connect) { return this.game.sound.add(key, volume, loop, connect); }, sound: function (key, volume, loop, connect) { return this.game.sound.add(key, volume, loop, connect); }, audioSprite: function (key) { return this.game.sound.addSprite(key); }, tileSprite: function (x, y, width, height, key, frame, group) { if (group === undefined) { group = this.world; } return group.add(new Phaser.TileSprite(this.game, x, y, width, height, key, frame)); }, rope: function (x, y, key, frame, points, group) { if (group === undefined) { group = this.world; } return group.add(new Phaser.Rope(this.game, x, y, key, frame, points)); }, text: function (x, y, text, style, group) { if (group === undefined) { group = this.world; } return group.add(new Phaser.Text(this.game, x, y, text, style)); }, button: function (x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame, group) { if (group === undefined) { group = this.world; } return group.add(new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame)); }, graphics: function (x, y, group) { if (group === undefined) { group = this.world; } return group.add(new Phaser.Graphics(this.game, x, y)); }, emitter: function (x, y, maxParticles) { return this.game.particles.add(new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles)); }, retroFont: function (font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) { return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset); }, bitmapText: function (x, y, font, text, size, group) { if (group === undefined) { group = this.world; } return group.add(new Phaser.BitmapText(this.game, x, y, font, text, size)); }, tilemap: function (key, tileWidth, tileHeight, width, height) { return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height); }, renderTexture: function (width, height, key, addToCache) { if (key === undefined || key === '') { key = this.game.rnd.uuid(); } if (addToCache === undefined) { addToCache = false; } var texture = new Phaser.RenderTexture(this.game, width, height, key); if (addToCache) { this.game.cache.addRenderTexture(key, texture); } return texture; }, video: function (key, url) { return new Phaser.Video(this.game, key, url); }, bitmapData: function (width, height, key, addToCache) { if (addToCache === undefined) { addToCache = false; } if (key === undefined || key === '') { key = this.game.rnd.uuid(); } var texture = new Phaser.BitmapData(this.game, key, width, height); if (addToCache) { this.game.cache.addBitmapData(key, texture); } return texture; }, filter: function (filter) { var args = Array.prototype.slice.call(arguments, 1); var filter = new Phaser.Filter[filter](this.game); filter.init.apply(filter, args); return filter; }, plugin: function (plugin) { return this.game.plugins.add(plugin); } }; Phaser.GameObjectFactory.prototype.constructor = Phaser.GameObjectFactory; Phaser.GameObjectCreator = function (game) { this.game = game; this.world = this.game.world; }; Phaser.GameObjectCreator.prototype = { image: function (x, y, key, frame) { return new Phaser.Image(this.game, x, y, key, frame); }, sprite: function (x, y, key, frame) { return new Phaser.Sprite(this.game, x, y, key, frame); }, tween: function (obj) { return new Phaser.Tween(obj, this.game, this.game.tweens); }, group: function (parent, name, addToStage, enableBody, physicsBodyType) { return new Phaser.Group(this.game, parent, name, addToStage, enableBody, physicsBodyType); }, spriteBatch: function (parent, name, addToStage) { if (name === undefined) { name = 'group'; } if (addToStage === undefined) { addToStage = false; } return new Phaser.SpriteBatch(this.game, parent, name, addToStage); }, audio: function (key, volume, loop, connect) { return this.game.sound.add(key, volume, loop, connect); }, audioSprite: function (key) { return this.game.sound.addSprite(key); }, sound: function (key, volume, loop, connect) { return this.game.sound.add(key, volume, loop, connect); }, tileSprite: function (x, y, width, height, key, frame) { return new Phaser.TileSprite(this.game, x, y, width, height, key, frame); }, rope: function (x, y, key, frame, points) { return new Phaser.Rope(this.game, x, y, key, frame, points); }, text: function (x, y, text, style) { return new Phaser.Text(this.game, x, y, text, style); }, button: function (x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) { return new Phaser.Button(this.game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame); }, graphics: function (x, y) { return new Phaser.Graphics(this.game, x, y); }, emitter: function (x, y, maxParticles) { return new Phaser.Particles.Arcade.Emitter(this.game, x, y, maxParticles); }, retroFont: function (font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) { return new Phaser.RetroFont(this.game, font, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset); }, bitmapText: function (x, y, font, text, size, align) { return new Phaser.BitmapText(this.game, x, y, font, text, size, align); }, tilemap: function (key, tileWidth, tileHeight, width, height) { return new Phaser.Tilemap(this.game, key, tileWidth, tileHeight, width, height); }, renderTexture: function (width, height, key, addToCache) { if (key === undefined || key === '') { key = this.game.rnd.uuid(); } if (addToCache === undefined) { addToCache = false; } var texture = new Phaser.RenderTexture(this.game, width, height, key); if (addToCache) { this.game.cache.addRenderTexture(key, texture); } return texture; }, bitmapData: function (width, height, key, addToCache) { if (addToCache === undefined) { addToCache = false; } if (key === undefined || key === '') { key = this.game.rnd.uuid(); } var texture = new Phaser.BitmapData(this.game, key, width, height); if (addToCache) { this.game.cache.addBitmapData(key, texture); } return texture; }, filter: function (filter) { var args = Array.prototype.slice.call(arguments, 1); var filter = new Phaser.Filter[filter](this.game); filter.init.apply(filter, args); return filter; } }; Phaser.GameObjectCreator.prototype.constructor = Phaser.GameObjectCreator; Phaser.Sprite = function (game, x, y, key, frame) { x = x || 0; y = y || 0; key = key || null; frame = frame || null; this.type = Phaser.SPRITE; this.physicsType = Phaser.SPRITE; PIXI.Sprite.call(this, Phaser.Cache.DEFAULT); Phaser.Component.Core.init.call(this, game, x, y, key, frame); }; Phaser.Sprite.prototype = Object.create(PIXI.Sprite.prototype); Phaser.Sprite.prototype.constructor = Phaser.Sprite; Phaser.Component.Core.install.call(Phaser.Sprite.prototype, [ 'Angle', 'Animation', 'AutoCull', 'Bounds', 'BringToTop', 'Crop', 'Delta', 'Destroy', 'FixedToCamera', 'Health', 'InCamera', 'InputEnabled', 'InWorld', 'LifeSpan', 'LoadTexture', 'Overlap', 'PhysicsBody', 'Reset', 'ScaleMinMax', 'Smoothed' ]); Phaser.Sprite.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate; Phaser.Sprite.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate; Phaser.Sprite.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate; Phaser.Sprite.prototype.preUpdateCore = Phaser.Component.Core.preUpdate; Phaser.Sprite.prototype.preUpdate = function() { if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) { return false; } return this.preUpdateCore(); }; Phaser.Image = function (game, x, y, key, frame) { x = x || 0; y = y || 0; key = key || null; frame = frame || null; this.type = Phaser.IMAGE; PIXI.Sprite.call(this, Phaser.Cache.DEFAULT); Phaser.Component.Core.init.call(this, game, x, y, key, frame); }; Phaser.Image.prototype = Object.create(PIXI.Sprite.prototype); Phaser.Image.prototype.constructor = Phaser.Image; Phaser.Component.Core.install.call(Phaser.Image.prototype, [ 'Angle', 'Animation', 'AutoCull', 'Bounds', 'BringToTop', 'Crop', 'Destroy', 'FixedToCamera', 'InputEnabled', 'LifeSpan', 'LoadTexture', 'Overlap', 'Reset', 'ScaleMinMax', 'Smoothed' ]); Phaser.Image.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate; Phaser.Image.prototype.preUpdateCore = Phaser.Component.Core.preUpdate; Phaser.Image.prototype.preUpdate = function() { if (!this.preUpdateInWorld()) { return false; } return this.preUpdateCore(); }; Phaser.Button = function (game, x, y, key, callback, callbackContext, overFrame, outFrame, downFrame, upFrame) { x = x || 0; y = y || 0; key = key || null; callback = callback || null; callbackContext = callbackContext || this; Phaser.Image.call(this, game, x, y, key, outFrame); this.type = Phaser.BUTTON; this.physicsType = Phaser.SPRITE; this._onOverFrame = null; this._onOutFrame = null; this._onDownFrame = null; this._onUpFrame = null; this.onOverSound = null; this.onOutSound = null; this.onDownSound = null; this.onUpSound = null; this.onOverSoundMarker = ''; this.onOutSoundMarker = ''; this.onDownSoundMarker = ''; this.onUpSoundMarker = ''; this.onInputOver = new Phaser.Signal(); this.onInputOut = new Phaser.Signal(); this.onInputDown = new Phaser.Signal(); this.onInputUp = new Phaser.Signal(); this.onOverMouseOnly = true; this.justReleasedPreventsOver = Phaser.PointerMode.TOUCH; this.freezeFrames = false; this.forceOut = false; this.inputEnabled = true; this.input.start(0, true); this.input.useHandCursor = true; this.setFrames(overFrame, outFrame, downFrame, upFrame); if (callback !== null) { this.onInputUp.add(callback, callbackContext); } this.events.onInputOver.add(this.onInputOverHandler, this); this.events.onInputOut.add(this.onInputOutHandler, this); this.events.onInputDown.add(this.onInputDownHandler, this); this.events.onInputUp.add(this.onInputUpHandler, this); this.events.onRemovedFromWorld.add(this.removedFromWorld, this); }; Phaser.Button.prototype = Object.create(Phaser.Image.prototype); Phaser.Button.prototype.constructor = Phaser.Button; var STATE_OVER = 'Over'; var STATE_OUT = 'Out'; var STATE_DOWN = 'Down'; var STATE_UP = 'Up'; Phaser.Button.prototype.clearFrames = function () { this.setFrames(null, null, null, null); }; Phaser.Button.prototype.removedFromWorld = function () { this.inputEnabled = false; }; Phaser.Button.prototype.setStateFrame = function (state, frame, switchImmediately) { var frameKey = '_on' + state + 'Frame'; if (frame !== null) { this[frameKey] = frame; if (switchImmediately) { this.changeStateFrame(state); } } else { this[frameKey] = null; } }; Phaser.Button.prototype.changeStateFrame = function (state) { if (this.freezeFrames) { return false; } var frameKey = '_on' + state + 'Frame'; var frame = this[frameKey]; if (typeof frame === 'string') { this.frameName = frame; return true; } else if (typeof frame === 'number') { this.frame = frame; return true; } else { return false; } }; Phaser.Button.prototype.setFrames = function (overFrame, outFrame, downFrame, upFrame) { this.setStateFrame(STATE_OVER, overFrame, this.input.pointerOver()); this.setStateFrame(STATE_OUT, outFrame, !this.input.pointerOver()); this.setStateFrame(STATE_DOWN, downFrame, this.input.pointerDown()); this.setStateFrame(STATE_UP, upFrame, this.input.pointerUp()); }; Phaser.Button.prototype.setStateSound = function (state, sound, marker) { var soundKey = 'on' + state + 'Sound'; var markerKey = 'on' + state + 'SoundMarker'; if (sound instanceof Phaser.Sound || sound instanceof Phaser.AudioSprite) { this[soundKey] = sound; this[markerKey] = typeof marker === 'string' ? marker : ''; } else { this[soundKey] = null; this[markerKey] = ''; } }; Phaser.Button.prototype.playStateSound = function (state) { var soundKey = 'on' + state + 'Sound'; var sound = this[soundKey]; if (sound) { var markerKey = 'on' + state + 'SoundMarker'; var marker = this[markerKey]; sound.play(marker); return true; } else { return false; } }; Phaser.Button.prototype.setSounds = function (overSound, overMarker, downSound, downMarker, outSound, outMarker, upSound, upMarker) { this.setStateSound(STATE_OVER, overSound, overMarker); this.setStateSound(STATE_OUT, outSound, outMarker); this.setStateSound(STATE_DOWN, downSound, downMarker); this.setStateSound(STATE_UP, upSound, upMarker); }; Phaser.Button.prototype.setOverSound = function (sound, marker) { this.setStateSound(STATE_OVER, sound, marker); }; Phaser.Button.prototype.setOutSound = function (sound, marker) { this.setStateSound(STATE_OUT, sound, marker); }; Phaser.Button.prototype.setDownSound = function (sound, marker) { this.setStateSound(STATE_DOWN, sound, marker); }; Phaser.Button.prototype.setUpSound = function (sound, marker) { this.setStateSound(STATE_UP, sound, marker); }; Phaser.Button.prototype.onInputOverHandler = function (sprite, pointer) { if (pointer.justReleased() && (this.justReleasedPreventsOver & pointer.pointerMode) === pointer.pointerMode) { return; } this.changeStateFrame(STATE_OVER); if (this.onOverMouseOnly && !pointer.isMouse) { return; } this.playStateSound(STATE_OVER); if (this.onInputOver) { this.onInputOver.dispatch(this, pointer); } }; Phaser.Button.prototype.onInputOutHandler = function (sprite, pointer) { this.changeStateFrame(STATE_OUT); this.playStateSound(STATE_OUT); if (this.onInputOut) { this.onInputOut.dispatch(this, pointer); } }; Phaser.Button.prototype.onInputDownHandler = function (sprite, pointer) { this.changeStateFrame(STATE_DOWN); this.playStateSound(STATE_DOWN); if (this.onInputDown) { this.onInputDown.dispatch(this, pointer); } }; Phaser.Button.prototype.onInputUpHandler = function (sprite, pointer, isOver) { this.playStateSound(STATE_UP); if (this.onInputUp) { this.onInputUp.dispatch(this, pointer, isOver); } if (this.freezeFrames) { return; } if (this.forceOut === true || (this.forceOut & pointer.pointerMode) === pointer.pointerMode) { this.changeStateFrame(STATE_OUT); } else { var changedUp = this.changeStateFrame(STATE_UP); if (!changedUp) { if (isOver) { this.changeStateFrame(STATE_OVER); } else { this.changeStateFrame(STATE_OUT); } } } }; Phaser.SpriteBatch = function (game, parent, name, addToStage) { if (parent === undefined || parent === null) { parent = game.world; } PIXI.SpriteBatch.call(this); Phaser.Group.call(this, game, parent, name, addToStage); this.type = Phaser.SPRITEBATCH; }; Phaser.SpriteBatch.prototype = Phaser.Utils.extend(true, Phaser.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, Phaser.Group.prototype); Phaser.SpriteBatch.prototype.constructor = Phaser.SpriteBatch;