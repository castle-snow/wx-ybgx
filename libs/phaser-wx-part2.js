import PIXI from './pixi-wx.js'; import Phaser from './phaser-wx-main.js'; Phaser.Group = function (game, parent, name, addToStage, enableBody, physicsBodyType) { if (addToStage === undefined) { addToStage = false; } if (enableBody === undefined) { enableBody = false; } if (physicsBodyType === undefined) { physicsBodyType = Phaser.Physics.ARCADE; } this.game = game; if (parent === undefined) { parent = game.world; } this.name = name || 'group'; this.z = 0; PIXI.DisplayObjectContainer.call(this); if (addToStage) { this.game.stage.addChild(this); this.z = this.game.stage.children.length; } else { if (parent) { parent.addChild(this); this.z = parent.children.length; } } this.type = Phaser.GROUP; this.physicsType = Phaser.GROUP; this.alive = true; this.exists = true; this.ignoreDestroy = false; this.pendingDestroy = false; this.classType = Phaser.Sprite; this.cursor = null; this.inputEnableChildren = false; this.onChildInputDown = new Phaser.Signal(); this.onChildInputUp = new Phaser.Signal(); this.onChildInputOver = new Phaser.Signal(); this.onChildInputOut = new Phaser.Signal(); this.enableBody = enableBody; this.enableBodyDebug = false; this.physicsBodyType = physicsBodyType; this.physicsSortDirection = null; this.onDestroy = new Phaser.Signal(); this.cursorIndex = 0; this.fixedToCamera = false; this.cameraOffset = new Phaser.Point(); this.hash = []; this._sortProperty = 'z'; }; Phaser.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); Phaser.Group.prototype.constructor = Phaser.Group; Phaser.Group.RETURN_NONE = 0; Phaser.Group.RETURN_TOTAL = 1; Phaser.Group.RETURN_CHILD = 2; Phaser.Group.RETURN_ALL = 3; Phaser.Group.SORT_ASCENDING = -1; Phaser.Group.SORT_DESCENDING = 1; Phaser.Group.prototype.add = function (child, silent, index) { if (silent === undefined) { silent = false; } if (child.parent === this) { return child; } if (child.body && child.parent && child.parent.hash) { child.parent.removeFromHash(child); } if (index === undefined) { child.z = this.children.length; this.addChild(child); } else { this.addChildAt(child, index); this.updateZ(); } if (this.enableBody && child.hasOwnProperty('body') && child.body === null) { this.game.physics.enable(child, this.physicsBodyType); } else if (child.body) { this.addToHash(child); } if (this.inputEnableChildren && (!child.input || child.inputEnabled)) { child.inputEnabled = true; } if (!silent && child.events) { child.events.onAddedToGroup$dispatch(child, this); } if (this.cursor === null) { this.cursor = child; } return child; }; Phaser.Group.prototype.addAt = function (child, index, silent) { this.add(child, silent, index); }; Phaser.Group.prototype.addToHash = function (child) { if (child.parent === this) { var index = this.hash.indexOf(child); if (index === -1) { this.hash.push(child); return true; } } return false; }; Phaser.Group.prototype.removeFromHash = function (child) { if (child) { var index = this.hash.indexOf(child); if (index !== -1) { this.hash.splice(index, 1); return true; } } return false; }; Phaser.Group.prototype.addMultiple = function (children, silent) { if (children instanceof Phaser.Group) { children.moveAll(this, silent); } else if (Array.isArray(children)) { for (var i = 0; i < children.length; i++) { this.add(children[i], silent); } } return children; }; Phaser.Group.prototype.getAt = function (index) { if (index < 0 || index >= this.children.length) { return -1; } else { return this.getChildAt(index); } }; Phaser.Group.prototype.create = function (x, y, key, frame, exists, index) { if (exists === undefined) { exists = true; } var child = new this.classType(this.game, x, y, key, frame); child.exists = exists; child.visible = exists; child.alive = exists; return this.add(child, false, index); }; Phaser.Group.prototype.createMultiple = function (quantity, key, frame, exists) { if (frame === undefined) { frame = 0; } if (exists === undefined) { exists = false; } if (!Array.isArray(key)) { key = [ key ]; } if (!Array.isArray(frame)) { frame = [ frame ]; } var _this = this; var children = []; key.forEach(function(singleKey) { frame.forEach(function(singleFrame) { for (var i = 0; i < quantity; i++) { children.push(_this.create(0, 0, singleKey, singleFrame, exists)); } }); }); return children; }; Phaser.Group.prototype.updateZ = function () { var i = this.children.length; while (i--) { this.children[i].z = i; } }; Phaser.Group.prototype.align = function (width, height, cellWidth, cellHeight, position, offset) { if (position === undefined) { position = Phaser.TOP_LEFT; } if (offset === undefined) { offset = 0; } if (this.children.length === 0 || offset > this.children.length || (width === -1 && height === -1)) { return false; } var r = new Phaser.Rectangle(0, 0, cellWidth, cellHeight); var w = (width * cellWidth); var h = (height * cellHeight); for (var i = offset; i < this.children.length; i++) { var child = this.children[i]; if (child['alignIn']) { child.alignIn(r, position); } else { continue; } if (width === -1) { r.y += cellHeight; if (r.y === h) { r.x += cellWidth; r.y = 0; } } else if (height === -1) { r.x += cellWidth; if (r.x === w) { r.x = 0; r.y += cellHeight; } } else { r.x += cellWidth; if (r.x === w) { r.x = 0; r.y += cellHeight; if (r.y === h) { return true; } } } } return true; }; Phaser.Group.prototype.resetCursor = function (index) { if (index === undefined) { index = 0; } if (index > this.children.length - 1) { index = 0; } if (this.cursor) { this.cursorIndex = index; this.cursor = this.children[this.cursorIndex]; return this.cursor; } }; Phaser.Group.prototype.next = function () { if (this.cursor) { if (this.cursorIndex >= this.children.length - 1) { this.cursorIndex = 0; } else { this.cursorIndex++; } this.cursor = this.children[this.cursorIndex]; return this.cursor; } }; Phaser.Group.prototype.previous = function () { if (this.cursor) { if (this.cursorIndex === 0) { this.cursorIndex = this.children.length - 1; } else { this.cursorIndex--; } this.cursor = this.children[this.cursorIndex]; return this.cursor; } }; Phaser.Group.prototype.swap = function (child1, child2) { this.swapChildren(child1, child2); this.updateZ(); }; Phaser.Group.prototype.bringToTop = function (child) { if (child.parent === this && this.getIndex(child) < this.children.length) { this.remove(child, false, true); this.add(child, true); } return child; }; Phaser.Group.prototype.sendToBack = function (child) { if (child.parent === this && this.getIndex(child) > 0) { this.remove(child, false, true); this.addAt(child, 0, true); } return child; }; Phaser.Group.prototype.moveUp = function (child) { if (child.parent === this && this.getIndex(child) < this.children.length - 1) { var a = this.getIndex(child); var b = this.getAt(a + 1); if (b) { this.swap(child, b); } } return child; }; Phaser.Group.prototype.moveDown = function (child) { if (child.parent === this && this.getIndex(child) > 0) { var a = this.getIndex(child); var b = this.getAt(a - 1); if (b) { this.swap(child, b); } } return child; }; Phaser.Group.prototype.xy = function (index, x, y) { if (index < 0 || index > this.children.length) { return -1; } else { this.getChildAt(index).x = x; this.getChildAt(index).y = y; } }; Phaser.Group.prototype.reverse = function () { this.children.reverse(); this.updateZ(); }; Phaser.Group.prototype.getIndex = function (child) { return this.children.indexOf(child); }; Phaser.Group.prototype.getByName = function (name) { for (var i = 0; i < this.children.length; i++) { if (this.children[i].name === name) { return this.children[i]; } } return null; }; Phaser.Group.prototype.replace = function (oldChild, newChild) { var index = this.getIndex(oldChild); if (index !== -1) { if (newChild.parent) { if (newChild.parent instanceof Phaser.Group) { newChild.parent.remove(newChild); } else { newChild.parent.removeChild(newChild); } } this.remove(oldChild); this.addAt(newChild, index); return oldChild; } }; Phaser.Group.prototype.hasProperty = function (child, key) { var len = key.length; if (len === 1 && key[0] in child) { return true; } else if (len === 2 && key[0] in child && key[1] in child[key[0]]) { return true; } else if (len === 3 && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]]) { return true; } else if (len === 4 && key[0] in child && key[1] in child[key[0]] && key[2] in child[key[0]][key[1]] && key[3] in child[key[0]][key[1]][key[2]]) { return true; } return false; }; Phaser.Group.prototype.setProperty = function (child, key, value, operation, force) { if (force === undefined) { force = false; } operation = operation || 0; if (!this.hasProperty(child, key) && (!force || operation > 0)) { return false; } var len = key.length; if (len === 1) { if (operation === 0) { child[key[0]] = value; } else if (operation === 1) { child[key[0]] += value; } else if (operation === 2) { child[key[0]] -= value; } else if (operation === 3) { child[key[0]] *= value; } else if (operation === 4) { child[key[0]] /= value; } } else if (len === 2) { if (operation === 0) { child[key[0]][key[1]] = value; } else if (operation === 1) { child[key[0]][key[1]] += value; } else if (operation === 2) { child[key[0]][key[1]] -= value; } else if (operation === 3) { child[key[0]][key[1]] *= value; } else if (operation === 4) { child[key[0]][key[1]] /= value; } } else if (len === 3) { if (operation === 0) { child[key[0]][key[1]][key[2]] = value; } else if (operation === 1) { child[key[0]][key[1]][key[2]] += value; } else if (operation === 2) { child[key[0]][key[1]][key[2]] -= value; } else if (operation === 3) { child[key[0]][key[1]][key[2]] *= value; } else if (operation === 4) { child[key[0]][key[1]][key[2]] /= value; } } else if (len === 4) { if (operation === 0) { child[key[0]][key[1]][key[2]][key[3]] = value; } else if (operation === 1) { child[key[0]][key[1]][key[2]][key[3]] += value; } else if (operation === 2) { child[key[0]][key[1]][key[2]][key[3]] -= value; } else if (operation === 3) { child[key[0]][key[1]][key[2]][key[3]] *= value; } else if (operation === 4) { child[key[0]][key[1]][key[2]][key[3]] /= value; } } return true; }; Phaser.Group.prototype.checkProperty = function (child, key, value, force) { if (force === undefined) { force = false; } if (!Phaser.Utils.getProperty(child, key) && force) { return false; } if (Phaser.Utils.getProperty(child, key) !== value) { return false; } return true; }; Phaser.Group.prototype.set = function (child, key, value, checkAlive, checkVisible, operation, force) { if (force === undefined) { force = false; } key = key.split('.'); if (checkAlive === undefined) { checkAlive = false; } if (checkVisible === undefined) { checkVisible = false; } if ((checkAlive === false || (checkAlive && child.alive)) && (checkVisible === false || (checkVisible && child.visible))) { return this.setProperty(child, key, value, operation, force); } }; Phaser.Group.prototype.setAll = function (key, value, checkAlive, checkVisible, operation, force) { if (checkAlive === undefined) { checkAlive = false; } if (checkVisible === undefined) { checkVisible = false; } if (force === undefined) { force = false; } key = key.split('.'); operation = operation || 0; for (var i = 0; i < this.children.length; i++) { if ((!checkAlive || (checkAlive && this.children[i].alive)) && (!checkVisible || (checkVisible && this.children[i].visible))) { this.setProperty(this.children[i], key, value, operation, force); } } }; Phaser.Group.prototype.setAllChildren = function (key, value, checkAlive, checkVisible, operation, force) { if (checkAlive === undefined) { checkAlive = false; } if (checkVisible === undefined) { checkVisible = false; } if (force === undefined) { force = false; } operation = operation || 0; for (var i = 0; i < this.children.length; i++) { if ((!checkAlive || (checkAlive && this.children[i].alive)) && (!checkVisible || (checkVisible && this.children[i].visible))) { if (this.children[i] instanceof Phaser.Group) { this.children[i].setAllChildren(key, value, checkAlive, checkVisible, operation, force); } else { this.setProperty(this.children[i], key.split('.'), value, operation, force); } } } }; Phaser.Group.prototype.checkAll = function (key, value, checkAlive, checkVisible, force) { if (checkAlive === undefined) { checkAlive = false; } if (checkVisible === undefined) { checkVisible = false; } if (force === undefined) { force = false; } for (var i = 0; i < this.children.length; i++) { if ((!checkAlive || (checkAlive && this.children[i].alive)) && (!checkVisible || (checkVisible && this.children[i].visible))) { if (!this.checkProperty(this.children[i], key, value, force)) { return false; } } } return true; }; Phaser.Group.prototype.addAll = function (property, amount, checkAlive, checkVisible) { this.setAll(property, amount, checkAlive, checkVisible, 1); }; Phaser.Group.prototype.subAll = function (property, amount, checkAlive, checkVisible) { this.setAll(property, amount, checkAlive, checkVisible, 2); }; Phaser.Group.prototype.multiplyAll = function (property, amount, checkAlive, checkVisible) { this.setAll(property, amount, checkAlive, checkVisible, 3); }; Phaser.Group.prototype.divideAll = function (property, amount, checkAlive, checkVisible) { this.setAll(property, amount, checkAlive, checkVisible, 4); }; Phaser.Group.prototype.callAllExists = function (callback, existsValue) { var args; if (arguments.length > 2) { args = []; for (var i = 2; i < arguments.length; i++) { args.push(arguments[i]); } } for (var i = 0; i < this.children.length; i++) { if (this.children[i].exists === existsValue && this.children[i][callback]) { this.children[i][callback].apply(this.children[i], args); } } }; Phaser.Group.prototype.callbackFromArray = function (child, callback, length) { if (length === 1) { if (child[callback[0]]) { return child[callback[0]]; } } else if (length === 2) { if (child[callback[0]][callback[1]]) { return child[callback[0]][callback[1]]; } } else if (length === 3) { if (child[callback[0]][callback[1]][callback[2]]) { return child[callback[0]][callback[1]][callback[2]]; } } else if (length === 4) { if (child[callback[0]][callback[1]][callback[2]][callback[3]]) { return child[callback[0]][callback[1]][callback[2]][callback[3]]; } } else if (child[callback]) { return child[callback]; } return false; }; Phaser.Group.prototype.callAll = function (method, context) { if (method === undefined) { return; } method = method.split('.'); var methodLength = method.length; if (context === undefined || context === null || context === '') { context = null; } else { if (typeof context === 'string') { context = context.split('.'); var contextLength = context.length; } } var args; if (arguments.length > 2) { args = []; for (var i = 2; i < arguments.length; i++) { args.push(arguments[i]); } } var callback = null; var callbackContext = null; for (var i = 0; i < this.children.length; i++) { callback = this.callbackFromArray(this.children[i], method, methodLength); if (context && callback) { callbackContext = this.callbackFromArray(this.children[i], context, contextLength); if (callback) { callback.apply(callbackContext, args); } } else if (callback) { callback.apply(this.children[i], args); } } }; Phaser.Group.prototype.preUpdate = function () { if (this.pendingDestroy) { this.destroy(); return false; } if (!this.exists || !this.parent.exists) { this.renderOrderID = -1; return false; } for (var i = 0; i < this.children.length; i++) { this.children[i].preUpdate(); } return true; }; Phaser.Group.prototype.update = function () { var i = this.children.length; while (i--) { this.children[i].update(); } }; Phaser.Group.prototype.postUpdate = function () { if (this.fixedToCamera) { this.x = this.game.camera.view.x + this.cameraOffset.x; this.y = this.game.camera.view.y + this.cameraOffset.y; } for (var i = 0; i < this.children.length; i++) { this.children[i].postUpdate(); } }; Phaser.Group.prototype.filter = function (predicate, checkExists) { var index = -1; var length = this.children.length; var results = []; while (++index < length) { var child = this.children[index]; if (!checkExists || (checkExists && child.exists)) { if (predicate(child, index, this.children)) { results.push(child); } } } return new Phaser.ArraySet(results); }; Phaser.Group.prototype.forEach = function (callback, callbackContext, checkExists) { if (checkExists === undefined) { checkExists = false; } if (arguments.length <= 3) { for (var i = 0; i < this.children.length; i++) { if (!checkExists || (checkExists && this.children[i].exists)) { callback.call(callbackContext, this.children[i], i); } } } else { var args = [null]; for (var i = 3; i < arguments.length; i++) { args.push(arguments[i]); } for (var i = 0; i < this.children.length; i++) { if (!checkExists || (checkExists && this.children[i].exists)) { args[0] = this.children[i]; callback.apply(callbackContext, args.concat([i])); } } } }; Phaser.Group.prototype.forEachExists = function (callback, callbackContext) { var args; if (arguments.length > 2) { args = [null]; for (var i = 2; i < arguments.length; i++) { args.push(arguments[i]); } } this.iterate('exists', true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args); }; Phaser.Group.prototype.forEachAlive = function (callback, callbackContext) { var args; if (arguments.length > 2) { args = [null]; for (var i = 2; i < arguments.length; i++) { args.push(arguments[i]); } } this.iterate('alive', true, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args); }; Phaser.Group.prototype.forEachDead = function (callback, callbackContext) { var args; if (arguments.length > 2) { args = [null]; for (var i = 2; i < arguments.length; i++) { args.push(arguments[i]); } } this.iterate('alive', false, Phaser.Group.RETURN_TOTAL, callback, callbackContext, args); }; Phaser.Group.prototype.sort = function (key, order) { if (this.children.length < 2) { return; } if (key === undefined) { key = 'z'; } if (order === undefined) { order = Phaser.Group.SORT_ASCENDING; } this._sortProperty = key; if (order === Phaser.Group.SORT_ASCENDING) { this.children.sort(this.ascendingSortHandler.bind(this)); } else { this.children.sort(this.descendingSortHandler.bind(this)); } this.updateZ(); }; Phaser.Group.prototype.customSort = function (sortHandler, context) { if (this.children.length < 2) { return; } this.children.sort(sortHandler.bind(context)); this.updateZ(); }; Phaser.Group.prototype.ascendingSortHandler = function (a, b) { if (a[this._sortProperty] < b[this._sortProperty]) { return -1; } else if (a[this._sortProperty] > b[this._sortProperty]) { return 1; } else { if (a.z < b.z) { return -1; } else { return 1; } } }; Phaser.Group.prototype.descendingSortHandler = function (a, b) { if (a[this._sortProperty] < b[this._sortProperty]) { return 1; } else if (a[this._sortProperty] > b[this._sortProperty]) { return -1; } else { return 0; } }; Phaser.Group.prototype.iterate = function (key, value, returnType, callback, callbackContext, args) { if (this.children.length === 0) { if (returnType === Phaser.Group.RETURN_TOTAL) { return 0; } else if (returnType === Phaser.Group.RETURN_ALL) { return []; } } var total = 0; if (returnType === Phaser.Group.RETURN_ALL) { var output = []; } for (var i = 0; i < this.children.length; i++) { if (this.children[i][key] === value) { total++; if (callback) { if (args) { args[0] = this.children[i]; callback.apply(callbackContext, args); } else { callback.call(callbackContext, this.children[i]); } } if (returnType === Phaser.Group.RETURN_CHILD) { return this.children[i]; } else if (returnType === Phaser.Group.RETURN_ALL) { output.push(this.children[i]); } } } if (returnType === Phaser.Group.RETURN_TOTAL) { return total; } else if (returnType === Phaser.Group.RETURN_ALL) { return output; } else { return null; } }; Phaser.Group.prototype.getFirstExists = function (exists, createIfNull, x, y, key, frame) { if (createIfNull === undefined) { createIfNull = false; } if (typeof exists !== 'boolean') { exists = true; } var child = this.iterate('exists', exists, Phaser.Group.RETURN_CHILD); return (child === null && createIfNull) ? this.create(x, y, key, frame) : this.resetChild(child, x, y, key, frame); }; Phaser.Group.prototype.getFirstAlive = function (createIfNull, x, y, key, frame) { if (createIfNull === undefined) { createIfNull = false; } var child = this.iterate('alive', true, Phaser.Group.RETURN_CHILD); return (child === null && createIfNull) ? this.create(x, y, key, frame) : this.resetChild(child, x, y, key, frame); }; Phaser.Group.prototype.getFirstDead = function (createIfNull, x, y, key, frame) { if (createIfNull === undefined) { createIfNull = false; } var child = this.iterate('alive', false, Phaser.Group.RETURN_CHILD); return (child === null && createIfNull) ? this.create(x, y, key, frame) : this.resetChild(child, x, y, key, frame); }; Phaser.Group.prototype.resetChild = function (child, x, y, key, frame) { if (child === null) { return null; } if (x === undefined) { x = null; } if (y === undefined) { y = null; } if (x !== null && y !== null) { child.reset(x, y); } if (key !== undefined) { child.loadTexture(key, frame); } return child; }; Phaser.Group.prototype.getTop = function () { if (this.children.length > 0) { return this.children[this.children.length - 1]; } }; Phaser.Group.prototype.getBottom = function () { if (this.children.length > 0) { return this.children[0]; } }; Phaser.Group.prototype.getClosestTo = function (object, callback, callbackContext) { var distance = Number.MAX_VALUE; var tempDistance = 0; var result = null; for (var i = 0; i < this.children.length; i++) { var child = this.children[i]; if (child.exists) { tempDistance = Math.abs(Phaser.Point.distance(object, child)); if (tempDistance < distance && (!callback || callback.call(callbackContext, child, tempDistance))) { distance = tempDistance; result = child; } } } return result; }; Phaser.Group.prototype.getFurthestFrom = function (object, callback, callbackContext) { var distance = 0; var tempDistance = 0; var result = null; for (var i = 0; i < this.children.length; i++) { var child = this.children[i]; if (child.exists) { tempDistance = Math.abs(Phaser.Point.distance(object, child)); if (tempDistance > distance && (!callback || callback.call(callbackContext, child, tempDistance))) { distance = tempDistance; result = child; } } } return result; }; Phaser.Group.prototype.countLiving = function () { return this.iterate('alive', true, Phaser.Group.RETURN_TOTAL); }; Phaser.Group.prototype.countDead = function () { return this.iterate('alive', false, Phaser.Group.RETURN_TOTAL); }; Phaser.Group.prototype.getRandom = function (startIndex, length) { if (startIndex === undefined) { startIndex = 0; } if (length === undefined) { length = this.children.length; } if (length === 0) { return null; } return Phaser.ArrayUtils.getRandomItem(this.children, startIndex, length); }; Phaser.Group.prototype.getRandomExists = function (startIndex, endIndex) { var list = this.getAll('exists', true, startIndex, endIndex); return this.game.rnd.pick(list); }; Phaser.Group.prototype.getAll = function (property, value, startIndex, endIndex) { if (startIndex === undefined) { startIndex = 0; } if (endIndex === undefined) { endIndex = this.children.length; } var output = []; for (var i = startIndex; i < endIndex; i++) { var child = this.children[i]; if (property && child[property] === value) { output.push(child); } } return output; }; Phaser.Group.prototype.remove = function (child, destroy, silent) { if (destroy === undefined) { destroy = false; } if (silent === undefined) { silent = false; } if (this.children.length === 0 || this.children.indexOf(child) === -1) { return false; } if (!silent && child.events && !child.destroyPhase) { child.events.onRemovedFromGroup$dispatch(child, this); } var removed = this.removeChild(child); this.removeFromHash(child); this.updateZ(); if (this.cursor === child) { this.next(); } if (destroy && removed) { removed.destroy(true); } return true; }; Phaser.Group.prototype.moveAll = function (group, silent) { if (silent === undefined) { silent = false; } if (this.children.length > 0 && group instanceof Phaser.Group) { do { group.add(this.children[0], silent); } while (this.children.length > 0); this.hash = []; this.cursor = null; } return group; }; Phaser.Group.prototype.removeAll = function (destroy, silent, destroyTexture) { if (destroy === undefined) { destroy = false; } if (silent === undefined) { silent = false; } if (destroyTexture === undefined) { destroyTexture = false; } if (this.children.length === 0) { return; } do { if (!silent && this.children[0].events) { this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this); } var removed = this.removeChild(this.children[0]); this.removeFromHash(removed); if (destroy && removed) { removed.destroy(true, destroyTexture); } } while (this.children.length > 0); this.hash = []; this.cursor = null; }; Phaser.Group.prototype.removeBetween = function (startIndex, endIndex, destroy, silent) { if (endIndex === undefined) { endIndex = this.children.length - 1; } if (destroy === undefined) { destroy = false; } if (silent === undefined) { silent = false; } if (this.children.length === 0) { return; } if (startIndex > endIndex || startIndex < 0 || endIndex > this.children.length) { return false; } var i = endIndex; while (i >= startIndex) { if (!silent && this.children[i].events) { this.children[i].events.onRemovedFromGroup$dispatch(this.children[i], this); } var removed = this.removeChild(this.children[i]); this.removeFromHash(removed); if (destroy && removed) { removed.destroy(true); } if (this.cursor === this.children[i]) { this.cursor = null; } i--; } this.updateZ(); }; Phaser.Group.prototype.destroy = function (destroyChildren, soft) { if (this.game === null || this.ignoreDestroy) { return; } if (destroyChildren === undefined) { destroyChildren = true; } if (soft === undefined) { soft = false; } this.onDestroy.dispatch(this, destroyChildren, soft); this.removeAll(destroyChildren); this.cursor = null; this.filters = null; this.pendingDestroy = false; if (!soft) { if (this.parent) { this.parent.removeChild(this); } this.game = null; this.exists = false; } }; Object.defineProperty(Phaser.Group.prototype, "total", { get: function () { return this.iterate('exists', true, Phaser.Group.RETURN_TOTAL); } }); Object.defineProperty(Phaser.Group.prototype, "length", { get: function () { return this.children.length; } }); Object.defineProperty(Phaser.Group.prototype, "angle", { get: function() { return Phaser.Math.radToDeg(this.rotation); }, set: function(value) { this.rotation = Phaser.Math.degToRad(value); } }); Object.defineProperty(Phaser.Group.prototype, "centerX", { get: function () { return this.getBounds(this.parent).centerX; }, set: function (value) { var r = this.getBounds(this.parent); var offset = this.x - r.x; this.x = (value + offset) - r.halfWidth; } }); Object.defineProperty(Phaser.Group.prototype, "centerY", { get: function () { return this.getBounds(this.parent).centerY; }, set: function (value) { var r = this.getBounds(this.parent); var offset = this.y - r.y; this.y = (value + offset) - r.halfHeight; } }); Object.defineProperty(Phaser.Group.prototype, "left", { get: function () { return this.getBounds(this.parent).left; }, set: function (value) { var r = this.getBounds(this.parent); var offset = this.x - r.x; this.x = value + offset; } }); Object.defineProperty(Phaser.Group.prototype, "right", { get: function () { return this.getBounds(this.parent).right; }, set: function (value) { var r = this.getBounds(this.parent); var offset = this.x - r.x; this.x = (value + offset) - r.width; } }); Object.defineProperty(Phaser.Group.prototype, "top", { get: function () { return this.getBounds(this.parent).top; }, set: function (value) { var r = this.getBounds(this.parent); var offset = this.y - r.y; this.y = (value + offset); } }); Object.defineProperty(Phaser.Group.prototype, "bottom", { get: function () { return this.getBounds(this.parent).bottom; }, set: function (value) { var r = this.getBounds(this.parent); var offset = this.y - r.y; this.y = (value + offset) - r.height; } }); Phaser.World = function (game) { Phaser.Group.call(this, game, null, '__world', false); this.bounds = new Phaser.Rectangle(0, 0, game.width, game.height); this.camera = null; this._definedSize = false; this._width = game.width; this._height = game.height; this.game.state.onStateChange.add(this.stateChange, this); }; Phaser.World.prototype = Object.create(Phaser.Group.prototype); Phaser.World.prototype.constructor = Phaser.World; Phaser.World.prototype.boot = function () { this.camera = new Phaser.Camera(this.game, 0, 0, 0, this.game.width, this.game.height); this.game.stage.addChild(this); this.camera.boot(); }; Phaser.World.prototype.stateChange = function () { this.x = 0; this.y = 0; this.camera.reset(); }; Phaser.World.prototype.setBounds = function (x, y, width, height) { this._definedSize = true; this._width = width; this._height = height; this.bounds.setTo(x, y, width, height); this.x = x; this.y = y; if (this.camera.bounds) { this.camera.bounds.setTo(x, y, Math.max(width, this.game.width), Math.max(height, this.game.height)); } this.game.physics.setBoundsToWorld(); }; Phaser.World.prototype.resize = function (width, height) { if (this._definedSize) { if (width < this._width) { width = this._width; } if (height < this._height) { height = this._height; } } this.bounds.width = width; this.bounds.height = height; this.game.camera.setBoundsToWorld(); this.game.physics.setBoundsToWorld(); }; Phaser.World.prototype.shutdown = function () { this.destroy(true, true); }; Phaser.World.prototype.wrap = function (sprite, padding, useBounds, horizontal, vertical) { if (padding === undefined) { padding = 0; } if (useBounds === undefined) { useBounds = false; } if (horizontal === undefined) { horizontal = true; } if (vertical === undefined) { vertical = true; } if (!useBounds) { if (horizontal && sprite.x + padding < this.bounds.x) { sprite.x = this.bounds.right + padding; } else if (horizontal && sprite.x - padding > this.bounds.right) { sprite.x = this.bounds.left - padding; } if (vertical && sprite.y + padding < this.bounds.top) { sprite.y = this.bounds.bottom + padding; } else if (vertical && sprite.y - padding > this.bounds.bottom) { sprite.y = this.bounds.top - padding; } } else { sprite.getBounds(); if (horizontal) { if ((sprite.x + sprite._currentBounds.width) < this.bounds.x) { sprite.x = this.bounds.right; } else if (sprite.x > this.bounds.right) { sprite.x = this.bounds.left; } } if (vertical) { if ((sprite.y + sprite._currentBounds.height) < this.bounds.top) { sprite.y = this.bounds.bottom; } else if (sprite.y > this.bounds.bottom) { sprite.y = this.bounds.top; } } } }; Object.defineProperty(Phaser.World.prototype, "width", { get: function () { return this.bounds.width; }, set: function (value) { if (value < this.game.width) { value = this.game.width; } this.bounds.width = value; this._width = value; this._definedSize = true; } }); Object.defineProperty(Phaser.World.prototype, "height", { get: function () { return this.bounds.height; }, set: function (value) { if (value < this.game.height) { value = this.game.height; } this.bounds.height = value; this._height = value; this._definedSize = true; } }); Object.defineProperty(Phaser.World.prototype, "centerX", { get: function () { return this.bounds.halfWidth + this.bounds.x; } }); Object.defineProperty(Phaser.World.prototype, "centerY", { get: function () { return this.bounds.halfHeight + this.bounds.y; } }); Object.defineProperty(Phaser.World.prototype, "randomX", { get: function () { if (this.bounds.x < 0) { return this.game.rnd.between(this.bounds.x, (this.bounds.width - Math.abs(this.bounds.x))); } else { return this.game.rnd.between(this.bounds.x, this.bounds.width); } } }); Object.defineProperty(Phaser.World.prototype, "randomY", { get: function () { if (this.bounds.y < 0) { return this.game.rnd.between(this.bounds.y, (this.bounds.height - Math.abs(this.bounds.y))); } else { return this.game.rnd.between(this.bounds.y, this.bounds.height); } } }); Phaser.Game = function (width, height, renderer, parent, state, transparent, antialias, physicsConfig) { this.id = Phaser.GAMES.push(this) - 1; this.config = null; this.physicsConfig = physicsConfig; this.parent = ''; this.width = 800; this.height = 600; this.resolution = 1; this._width = 800; this._height = 600; this.transparent = false; this.antialias = true; this.preserveDrawingBuffer = false; this.clearBeforeRender = true; this.renderer = null; this.renderType = Phaser.AUTO; this.state = null; this.isBooted = false; this.isRunning = false; this.raf = null; this.add = null; this.make = null; this.cache = null; this.input = null; this.load = null; this.math = null; this.net = null; this.scale = null; this.sound = null; this.stage = null; this.time = null; this.tweens = null; this.world = null; this.physics = null; this.plugins = null; this.rnd = null; this.device = Phaser.Device; this.camera = null; this.canvas = null; this.context = null; this.debug = null; this.particles = null; this.create = null; this.lockRender = false; this.stepping = false; this.pendingStep = false; this.stepCount = 0; this.onPause = null; this.onResume = null; this.onBlur = null; this.onFocus = null; this._paused = false; this._codePaused = false; this.currentUpdateID = 0; this.updatesThisFrame = 1; this._deltaTime = 0; this._lastCount = 0; this._spiraling = 0; this._kickstart = true; this.fpsProblemNotifier = new Phaser.Signal(); this.forceSingleUpdate = true; this._nextFpsNotification = 0; if (arguments.length === 1 && typeof arguments[0] === 'object') { this.parseConfig(arguments[0]); } else { this.config = { enableDebug: true }; if (typeof width !== 'undefined') { this._width = width; } if (typeof height !== 'undefined') { this._height = height; } if (typeof renderer !== 'undefined') { this.renderType = renderer; } if (typeof parent !== 'undefined') { this.parent = parent; } if (typeof transparent !== 'undefined') { this.transparent = transparent; } if (typeof antialias !== 'undefined') { this.antialias = antialias; } this.rnd = new Phaser.RandomDataGenerator([(Date.now() * Math.random()).toString()]); this.state = new Phaser.StateManager(this, state); } this.device.whenReady(this.boot, this); return this; }; Phaser.Game.prototype = { parseConfig: function (config) { this.config = config; if (config['enableDebug'] === undefined) { this.config.enableDebug = true; } if (config['width']) { this._width = config['width']; } if (config['height']) { this._height = config['height']; } if (config['renderer']) { this.renderType = config['renderer']; } if (config['parent']) { this.parent = config['parent']; } if (config['transparent'] !== undefined) { this.transparent = config['transparent']; } if (config['antialias'] !== undefined) { this.antialias = config['antialias']; } if (config['resolution']) { this.resolution = config['resolution']; } if (config['preserveDrawingBuffer'] !== undefined) { this.preserveDrawingBuffer = config['preserveDrawingBuffer']; } if (config['physicsConfig']) { this.physicsConfig = config['physicsConfig']; } var seed = [(Date.now() * Math.random()).toString()]; if (config['seed']) { seed = config['seed']; } this.rnd = new Phaser.RandomDataGenerator(seed); var state = null; if (config['state']) { state = config['state']; } this.state = new Phaser.StateManager(this, state); }, boot: function () { if (this.isBooted) { return; } this.onPause = new Phaser.Signal(); this.onResume = new Phaser.Signal(); this.onBlur = new Phaser.Signal(); this.onFocus = new Phaser.Signal(); this.isBooted = true; PIXI.game = this; this.math = Phaser.Math; this.scale = new Phaser.ScaleManager(this, this._width, this._height); this.stage = new Phaser.Stage(this); this.setUpRenderer(); this.world = new Phaser.World(this); this.add = new Phaser.GameObjectFactory(this); this.make = new Phaser.GameObjectCreator(this); this.cache = new Phaser.Cache(this); this.load = new Phaser.Loader(this); this.time = new Phaser.Time(this); this.tweens = new Phaser.TweenManager(this); this.input = new Phaser.Input(this); this.sound = new Phaser.SoundManager(this); this.physics = new Phaser.Physics(this, this.physicsConfig); this.particles = new Phaser.Particles(this); this.create = new Phaser.Create(this); this.plugins = new Phaser.PluginManager(this); this.net = new Phaser.Net(this); this.time.boot(); this.stage.boot(); this.world.boot(); this.scale.boot(); this.input.boot(); this.sound.boot(); this.state.boot(); if (this.config['enableDebug']) { this.debug = new Phaser.Utils.Debug(this); this.debug.boot(); } else { this.debug = { preUpdate: function () {}, update: function () {}, reset: function () {} }; } this.showDebugHeader(); this.isRunning = true; if (this.config && this.config['forceSetTimeOut']) { this.raf = new Phaser.RequestAnimationFrame(this, this.config['forceSetTimeOut']); } else { this.raf = new Phaser.RequestAnimationFrame(this, false); } this._kickstart = true; if (window['focus']) { if (!window['PhaserGlobal'] || (window['PhaserGlobal'] && !window['PhaserGlobal'].stopFocus)) { window.focus(); } } this.raf.start(); }, showDebugHeader: function () { if (window['PhaserGlobal'] && window['PhaserGlobal'].hideBanner) { return; } var v = Phaser.VERSION; var r = 'Canvas'; var a = 'HTML Audio'; var c = 1; if (this.renderType === Phaser.WEBGL) { r = 'WebGL'; c++; } else if (this.renderType === Phaser.HEADLESS) { r = 'Headless'; } if (this.device.webAudio) { a = 'WebAudio'; c++; } if (this.device.chrome) { var args = []; for (var i = 0; i < 3; i++) { if (i < c) { args.push('color: #ff2424; background: #fff'); } else { args.push('color: #959595; background: #fff'); } } console.log.apply(console, args); } else if (console && console.log) { return; } }, setUpRenderer: function () { if (this.config['canvas']) { this.canvas = this.config['canvas']; } else { this.canvas = Phaser.Canvas.create(this, this.width, this.height, this.config['canvasID'], true); } if (this.config['canvasStyle']) { this.canvas.style = this.config['canvasStyle']; } else { this.canvas.style['-webkit-full-screen'] = 'width: 100%; height: 100%'; } if (this.renderType === Phaser.HEADLESS || this.renderType === Phaser.CANVAS || (this.renderType === Phaser.AUTO && !this.device.webGL)) { if (this.device.canvas = true) { this.renderType = Phaser.CANVAS; this.renderer = new PIXI.CanvasRenderer(this); this.context = this.renderer.context; } else { throw new Error('Phaser.Game - Cannot create Canvas or WebGL context, aborting.'); } } else { this.renderType = Phaser.WEBGL; this.renderer = new PIXI.WebGLRenderer(this); this.context = null; this.canvas.addEventListener('webglcontextlost', this.contextLost.bind(this), false); this.canvas.addEventListener('webglcontextrestored', this.contextRestored.bind(this), false); } if (this.device.cocoonJS) { this.canvas.screencanvas = (this.renderType === Phaser.CANVAS) ? true : false; } if (this.renderType !== Phaser.HEADLESS) { this.stage.smoothed = this.antialias; Phaser.Canvas.addToDOM(this.canvas, this.parent, false); Phaser.Canvas.setTouchAction(this.canvas); } }, contextLost: function (event) { event.preventDefault(); this.renderer.contextLost = true; }, contextRestored: function () { this.renderer.initContext(); this.cache.clearGLTextures(); this.renderer.contextLost = false; }, update: function (time) { this.time.update(time); if (this._kickstart) { this.updateLogic(this.time.desiredFpsMult); this.updateRender(this.time.slowMotion * this.time.desiredFps); this._kickstart = false; return; } if (this._spiraling > 1 && !this.forceSingleUpdate) { if (this.time.time > this._nextFpsNotification) { this._nextFpsNotification = this.time.time + 10000; this.fpsProblemNotifier.dispatch(); } this._deltaTime = 0; this._spiraling = 0; this.updateRender(this.time.slowMotion * this.time.desiredFps); } else { var slowStep = this.time.slowMotion * 1000.0 / this.time.desiredFps; this._deltaTime += Math.max(Math.min(slowStep * 3, this.time.elapsed), 0); var count = 0; this.updatesThisFrame = Math.floor(this._deltaTime / slowStep); if (this.forceSingleUpdate) { this.updatesThisFrame = Math.min(1, this.updatesThisFrame); } while (this._deltaTime >= slowStep) { this._deltaTime -= slowStep; this.currentUpdateID = count; this.updateLogic(this.time.desiredFpsMult); count++; if (this.forceSingleUpdate && count === 1) { break; } else { this.time.refresh(); } } if (count > this._lastCount) { this._spiraling++; } else if (count < this._lastCount) { this._spiraling = 0; } this._lastCount = count; this.updateRender(this._deltaTime / slowStep); } }, updateLogic: function (timeStep) { if (!this._paused && !this.pendingStep) { if (this.stepping) { this.pendingStep = true; } this.scale.preUpdate(); this.debug.preUpdate(); this.camera.preUpdate(); this.physics.preUpdate(); this.state.preUpdate(timeStep); this.plugins.preUpdate(timeStep); this.stage.preUpdate(); this.state.update(); this.stage.update(); this.tweens.update(); this.sound.update(); this.input.update(); this.physics.update(); this.particles.update(); this.plugins.update(); this.stage.postUpdate(); this.plugins.postUpdate(); } else { this.scale.pauseUpdate(); this.state.pauseUpdate(); this.debug.preUpdate(); } this.stage.updateTransform(); }, updateRender: function (elapsedTime) { if (this.lockRender) { return; } this.state.preRender(elapsedTime); if (this.renderType !== Phaser.HEADLESS) { this.renderer.render(this.stage); this.plugins.render(elapsedTime); this.state.render(elapsedTime); } this.plugins.postRender(elapsedTime); }, enableStep: function () { this.stepping = true; this.pendingStep = false; this.stepCount = 0; }, disableStep: function () { this.stepping = false; this.pendingStep = false; }, step: function () { this.pendingStep = false; this.stepCount++; }, destroy: function () { this.raf.stop(); this.state.destroy(); this.sound.destroy(); this.scale.destroy(); this.stage.destroy(); this.input.destroy(); this.physics.destroy(); this.plugins.destroy(); this.state = null; this.sound = null; this.scale = null; this.stage = null; this.input = null; this.physics = null; this.plugins = null; this.cache = null; this.load = null; this.time = null; this.world = null; this.isBooted = false; this.renderer.destroy(false); Phaser.Canvas.removeFromDOM(this.canvas); PIXI.defaultRenderer = null; Phaser.GAMES[this.id] = null; }, gamePaused: function (event) { if (!this._paused) { this._paused = true; this.time.gamePaused(); if (this.sound.muteOnPause) { this.sound.setMute(); } this.onPause.dispatch(event); if (this.device.cordova && this.device.iOS) { this.lockRender = true; } } }, gameResumed: function (event) { if (this._paused && !this._codePaused) { this._paused = false; this.time.gameResumed(); this.input.reset(); if (this.sound.muteOnPause) { this.sound.unsetMute(); } this.onResume.dispatch(event); if (this.device.cordova && this.device.iOS) { this.lockRender = false; } } }, focusLoss: function (event) { this.onBlur.dispatch(event); if (!this.stage.disableVisibilityChange) { this.gamePaused(event); } }, focusGain: function (event) { this.onFocus.dispatch(event); if (!this.stage.disableVisibilityChange) { this.gameResumed(event); } } }; Phaser.Game.prototype.constructor = Phaser.Game; Object.defineProperty(Phaser.Game.prototype, "paused", { get: function () { return this._paused; }, set: function (value) { if (value === true) { if (this._paused === false) { this._paused = true; this.sound.setMute(); this.time.gamePaused(); this.onPause.dispatch(this); } this._codePaused = true; } else { if (this._paused) { this._paused = false; this.input.reset(); this.sound.unsetMute(); this.time.gameResumed(); this.onResume.dispatch(this); } this._codePaused = false; } } }); Phaser.Input = function (game) { this.game = game; this.hitCanvas = null; this.hitContext = null; this.moveCallbacks = []; this.customCandidateHandler = null; this.customCandidateHandlerContext = null; this.pollRate = 0; this.enabled = true; this.multiInputOverride = Phaser.Input.MOUSE_TOUCH_COMBINE; this.position = null; this.speed = null; this.circle = null; this.scale = null; this.maxPointers = -1; this.tapRate = 200; this.doubleTapRate = 300; this.holdRate = 2000; this.justPressedRate = 200; this.justReleasedRate = 200; this.recordPointerHistory = false; this.recordRate = 100; this.recordLimit = 100; this.pointer1 = null; this.pointer2 = null; this.pointer3 = null; this.pointer4 = null; this.pointer5 = null; this.pointer6 = null; this.pointer7 = null; this.pointer8 = null; this.pointer9 = null; this.pointer10 = null; this.pointers = []; this.activePointer = null; this.mousePointer = null; this.mouse = null; this.keyboard = null; this.touch = null; this.mspointer = null; this.gamepad = null; this.resetLocked = false; this.onDown = null; this.onUp = null; this.onTap = null; this.onHold = null; this.minPriorityID = 0; this.interactiveItems = new Phaser.ArraySet(); this._localPoint = new Phaser.Point(); this._pollCounter = 0; this._oldPosition = null; this._x = 0; this._y = 0; }; Phaser.Input.MOUSE_OVERRIDES_TOUCH = 0; Phaser.Input.TOUCH_OVERRIDES_MOUSE = 1; Phaser.Input.MOUSE_TOUCH_COMBINE = 2; Phaser.Input.MAX_POINTERS = 10; Phaser.Input.prototype = { boot: function () { this.mousePointer = new Phaser.Pointer(this.game, 0, Phaser.PointerMode.CURSOR); this.addPointer(); this.addPointer(); this.mouse = new Phaser.Mouse(this.game); this.touch = new Phaser.Touch(this.game); this.mspointer = new Phaser.MSPointer(this.game); if (Phaser.Keyboard) { this.keyboard = new Phaser.Keyboard(this.game); } if (Phaser.Gamepad) { this.gamepad = new Phaser.Gamepad(this.game); } this.onDown = new Phaser.Signal(); this.onUp = new Phaser.Signal(); this.onTap = new Phaser.Signal(); this.onHold = new Phaser.Signal(); this.scale = new Phaser.Point(1, 1); this.speed = new Phaser.Point(); this.position = new Phaser.Point(); this._oldPosition = new Phaser.Point(); this.circle = new Phaser.Circle(0, 0, 44); this.activePointer = this.mousePointer; this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1); this.hitContext = this.hitCanvas.getContext('2d'); this.mouse.start(); this.touch.start(); this.mspointer.start(); this.mousePointer.active = true; if (this.keyboard) { this.keyboard.start(); } var _this = this; this._onClickTrampoline = function (event) { _this.onClickTrampoline(event); }; this.game.canvas.addEventListener('click', this._onClickTrampoline, false); }, destroy: function () { this.mouse.stop(); this.touch.stop(); this.mspointer.stop(); if (this.keyboard) { this.keyboard.stop(); } if (this.gamepad) { this.gamepad.stop(); } this.moveCallbacks = []; PIXI.CanvasPool.remove(this); this.game.canvas.removeEventListener('click', this._onClickTrampoline); }, setInteractiveCandidateHandler: function (callback, context) { this.customCandidateHandler = callback; this.customCandidateHandlerContext = context; }, addMoveCallback: function (callback, context) { this.moveCallbacks.push({ callback: callback, context: context }); }, deleteMoveCallback: function (callback, context) { var i = this.moveCallbacks.length; while (i--) { if (this.moveCallbacks[i].callback === callback && this.moveCallbacks[i].context === context) { this.moveCallbacks.splice(i, 1); return; } } }, addPointer: function () { if (this.pointers.length >= Phaser.Input.MAX_POINTERS) { console.warn("Phaser.Input.addPointer: Maximum limit of " + Phaser.Input.MAX_POINTERS + " pointers reached."); return null; } var id = this.pointers.length + 1; var pointer = new Phaser.Pointer(this.game, id, Phaser.PointerMode.TOUCH); this.pointers.push(pointer); this['pointer' + id] = pointer; return pointer; }, update: function () { if (this.keyboard) { this.keyboard.update(); } if (this.pollRate > 0 && this._pollCounter < this.pollRate) { this._pollCounter++; return; } this.speed.x = this.position.x - this._oldPosition.x; this.speed.y = this.position.y - this._oldPosition.y; this._oldPosition.copyFrom(this.position); this.mousePointer.update(); if (this.gamepad && this.gamepad.active) { this.gamepad.update(); } for (var i = 0; i < this.pointers.length; i++) { this.pointers[i].update(); } this._pollCounter = 0; }, reset: function (hard) { if (!this.game.isBooted || this.resetLocked) { return; } if (hard === undefined) { hard = false; } this.mousePointer.reset(); if (this.keyboard) { this.keyboard.reset(hard); } if (this.gamepad) { this.gamepad.reset(); } for (var i = 0; i < this.pointers.length; i++) { this.pointers[i].reset(); } if (this.game.canvas.style.cursor !== 'none') { this.game.canvas.style.cursor = 'inherit'; } if (hard) { this.onDown.dispose(); this.onUp.dispose(); this.onTap.dispose(); this.onHold.dispose(); this.onDown = new Phaser.Signal(); this.onUp = new Phaser.Signal(); this.onTap = new Phaser.Signal(); this.onHold = new Phaser.Signal(); this.moveCallbacks = []; } this._pollCounter = 0; }, resetSpeed: function (x, y) { this._oldPosition.setTo(x, y); this.speed.setTo(0, 0); }, startPointer: function (event) { if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) { return null; } if (!this.pointer1.active) { return this.pointer1.start(event); } if (!this.pointer2.active) { return this.pointer2.start(event); } for (var i = 2; i < this.pointers.length; i++) { var pointer = this.pointers[i]; if (!pointer.active) { return pointer.start(event); } } return null; }, updatePointer: function (event) { if (this.pointer1.active && this.pointer1.identifier === event.identifier) { return this.pointer1.move(event); } if (this.pointer2.active && this.pointer2.identifier === event.identifier) { return this.pointer2.move(event); } for (var i = 2; i < this.pointers.length; i++) { var pointer = this.pointers[i]; if (pointer.active && pointer.identifier === event.identifier) { return pointer.move(event); } } return null; }, stopPointer: function (event) { if (this.pointer1.active && this.pointer1.identifier === event.identifier) { return this.pointer1.stop(event); } if (this.pointer2.active && this.pointer2.identifier === event.identifier) { return this.pointer2.stop(event); } for (var i = 2; i < this.pointers.length; i++) { var pointer = this.pointers[i]; if (pointer.active && pointer.identifier === event.identifier) { return pointer.stop(event); } } return null; }, countActivePointers: function (limit) { if (limit === undefined) { limit = this.pointers.length; } var count = limit; for (var i = 0; i < this.pointers.length && count > 0; i++) { var pointer = this.pointers[i]; if (pointer.active) { count--; } } return (limit - count); }, getPointer: function (isActive) { if (isActive === undefined) { isActive = false; } for (var i = 0; i < this.pointers.length; i++) { var pointer = this.pointers[i]; if (pointer.active === isActive) { return pointer; } } return null; }, getPointerFromIdentifier: function (identifier) { for (var i = 0; i < this.pointers.length; i++) { var pointer = this.pointers[i]; if (pointer.identifier === identifier) { return pointer; } } return null; }, getPointerFromId: function (pointerId) { for (var i = 0; i < this.pointers.length; i++) { var pointer = this.pointers[i]; if (pointer.pointerId === pointerId) { return pointer; } } return null; }, getLocalPosition: function (displayObject, pointer, output) { if (output === undefined) { output = new Phaser.Point(); } var wt = displayObject.worldTransform; var id = 1 / (wt.a * wt.d + wt.c * -wt.b); return output.setTo( wt.d * id * pointer.x + -wt.c * id * pointer.y + (wt.ty * wt.c - wt.tx * wt.d) * id, wt.a * id * pointer.y + -wt.b * id * pointer.x + (-wt.ty * wt.a + wt.tx * wt.b) * id ); }, hitTest: function (displayObject, pointer, localPoint) { if (!displayObject.worldVisible) { return false; } this.getLocalPosition(displayObject, pointer, this._localPoint); localPoint.copyFrom(this._localPoint); if (displayObject.hitArea && displayObject.hitArea.contains) { return (displayObject.hitArea.contains(this._localPoint.x, this._localPoint.y)); } else if (displayObject instanceof Phaser.TileSprite) { var width = displayObject.width; var height = displayObject.height; var x1 = -width * displayObject.anchor.x; if (this._localPoint.x >= x1 && this._localPoint.x < x1 + width) { var y1 = -height * displayObject.anchor.y; if (this._localPoint.y >= y1 && this._localPoint.y < y1 + height) { return true; } } } else if (displayObject instanceof PIXI.Sprite) { var width = displayObject.texture.frame.width; var height = displayObject.texture.frame.height; var x1 = -width * displayObject.anchor.x; if (this._localPoint.x >= x1 && this._localPoint.x < x1 + width) { var y1 = -height * displayObject.anchor.y; if (this._localPoint.y >= y1 && this._localPoint.y < y1 + height) { return true; } } } else if (displayObject instanceof Phaser.Graphics) { for (var i = 0; i < displayObject.graphicsData.length; i++) { var data = displayObject.graphicsData[i]; if (!data.fill) { continue; } if (data.shape && data.shape.contains(this._localPoint.x, this._localPoint.y)) { return true; } } } for (var i = 0; i < displayObject.children.length; i++) { if (this.hitTest(displayObject.children[i], pointer, localPoint)) { return true; } } return false; }, onClickTrampoline: function () { this.activePointer.processClickTrampolines(); } }; Phaser.Input.prototype.constructor = Phaser.Input; Object.defineProperty(Phaser.Input.prototype, "x", { get: function () { return this._x; }, set: function (value) { this._x = Math.floor(value); } }); Object.defineProperty(Phaser.Input.prototype, "y", { get: function () { return this._y; }, set: function (value) { this._y = Math.floor(value); } }); Object.defineProperty(Phaser.Input.prototype, "pollLocked", { get: function () { return (this.pollRate > 0 && this._pollCounter < this.pollRate); } }); Object.defineProperty(Phaser.Input.prototype, "totalInactivePointers", { get: function () { return this.pointers.length - this.countActivePointers(); } }); Object.defineProperty(Phaser.Input.prototype, "totalActivePointers", { get: function () { return this.countActivePointers(); } }); Object.defineProperty(Phaser.Input.prototype, "worldX", { get: function () { return this.game.camera.view.x + this.x; } }); Object.defineProperty(Phaser.Input.prototype, "worldY", { get: function () { return this.game.camera.view.y + this.y; } }); Phaser.Mouse = function (game) { this.game = game; this.input = game.input; this.callbackContext = this.game; this.mouseDownCallback = null; this.mouseUpCallback = null; this.mouseOutCallback = null; this.mouseOverCallback = null; this.mouseWheelCallback = null; this.capture = false; this.button = -1; this.wheelDelta = 0; this.enabled = true; this.locked = false; this.stopOnGameOut = false; this.pointerLock = new Phaser.Signal(); this.event = null; this._onMouseDown = null; this._onMouseMove = null; this._onMouseUp = null; this._onMouseOut = null; this._onMouseOver = null; this._onMouseWheel = null; this._wheelEvent = null; }; Phaser.Mouse.NO_BUTTON = -1; Phaser.Mouse.LEFT_BUTTON = 0; Phaser.Mouse.MIDDLE_BUTTON = 1; Phaser.Mouse.RIGHT_BUTTON = 2; Phaser.Mouse.BACK_BUTTON = 3; Phaser.Mouse.FORWARD_BUTTON = 4; Phaser.Mouse.WHEEL_UP = 1; Phaser.Mouse.WHEEL_DOWN = -1; Phaser.Mouse.prototype = { start: function () { if (this.game.device.android && this.game.device.chrome === false) { return; } if (this._onMouseDown !== null) { return; } var _this = this; this._onMouseDown = function (event) { return _this.onMouseDown(event); }; this._onMouseMove = function (event) { return _this.onMouseMove(event); }; this._onMouseUp = function (event) { return _this.onMouseUp(event); }; this._onMouseUpGlobal = function (event) { return _this.onMouseUpGlobal(event); }; this._onMouseOutGlobal = function (event) { return _this.onMouseOutGlobal(event); }; this._onMouseOut = function (event) { return _this.onMouseOut(event); }; this._onMouseOver = function (event) { return _this.onMouseOver(event); }; this._onMouseWheel = function (event) { return _this.onMouseWheel(event); }; var canvas = this.game.canvas; canvas.addEventListener('mousedown', this._onMouseDown, true); canvas.addEventListener('mousemove', this._onMouseMove, true); canvas.addEventListener('mouseup', this._onMouseUp, true); if (!this.game.device.cocoonJS) { window.addEventListener('mouseup', this._onMouseUpGlobal, true); window.addEventListener('mouseout', this._onMouseOutGlobal, true); canvas.addEventListener('mouseover', this._onMouseOver, true); canvas.addEventListener('mouseout', this._onMouseOut, true); } var wheelEvent = this.game.device.wheelEvent; if (wheelEvent) { canvas.addEventListener(wheelEvent, this._onMouseWheel, true); if (wheelEvent === 'mousewheel') { this._wheelEvent = new WheelEventProxy(-1/40, 1); } else if (wheelEvent === 'DOMMouseScroll') { this._wheelEvent = new WheelEventProxy(1, 1); } } }, onMouseDown: function (event) { this.event = event; if (this.capture) { event.preventDefault(); } if (this.mouseDownCallback) { this.mouseDownCallback.call(this.callbackContext, event); } if (!this.input.enabled || !this.enabled) { return; } event['identifier'] = 0; this.input.mousePointer.start(event); }, onMouseMove: function (event) { this.event = event; if (this.capture) { event.preventDefault(); } if (this.mouseMoveCallback) { this.mouseMoveCallback.call(this.callbackContext, event); } if (!this.input.enabled || !this.enabled) { return; } event['identifier'] = 0; this.input.mousePointer.move(event); }, onMouseUp: function (event) { this.event = event; if (this.capture) { event.preventDefault(); } if (this.mouseUpCallback) { this.mouseUpCallback.call(this.callbackContext, event); } if (!this.input.enabled || !this.enabled) { return; } event['identifier'] = 0; this.input.mousePointer.stop(event); }, onMouseUpGlobal: function (event) { if (!this.input.mousePointer.withinGame) { if (this.mouseUpCallback) { this.mouseUpCallback.call(this.callbackContext, event); } event['identifier'] = 0; this.input.mousePointer.stop(event); } }, onMouseOutGlobal: function (event) { this.event = event; if (this.capture) { event.preventDefault(); } this.input.mousePointer.withinGame = false; if (!this.input.enabled || !this.enabled) { return; } this.input.mousePointer.stop(event); this.input.mousePointer.leftButton.stop(event); this.input.mousePointer.rightButton.stop(event); }, onMouseOut: function (event) { this.event = event; if (this.capture) { event.preventDefault(); } this.input.mousePointer.withinGame = false; if (this.mouseOutCallback) { this.mouseOutCallback.call(this.callbackContext, event); } if (!this.input.enabled || !this.enabled) { return; } if (this.stopOnGameOut) { event['identifier'] = 0; this.input.mousePointer.stop(event); } }, onMouseOver: function (event) { this.event = event; if (this.capture) { event.preventDefault(); } this.input.mousePointer.withinGame = true; if (this.mouseOverCallback) { this.mouseOverCallback.call(this.callbackContext, event); } }, onMouseWheel: function (event) { if (this._wheelEvent) { event = this._wheelEvent.bindEvent(event); } this.event = event; if (this.capture) { event.preventDefault(); } this.wheelDelta = Phaser.Math.clamp(-event.deltaY, -1, 1); if (this.mouseWheelCallback) { this.mouseWheelCallback.call(this.callbackContext, event); } }, requestPointerLock: function () { if (this.game.device.pointerLock) { var element = this.game.canvas; element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock; element.requestPointerLock(); var _this = this; this._pointerLockChange = function (event) { return _this.pointerLockChange(event); }; document.addEventListener('pointerlockchange', this._pointerLockChange, true); document.addEventListener('mozpointerlockchange', this._pointerLockChange, true); document.addEventListener('webkitpointerlockchange', this._pointerLockChange, true); } }, pointerLockChange: function (event) { var element = this.game.canvas; if (document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element) { this.locked = true; this.pointerLock.dispatch(true, event); } else { this.locked = false; this.pointerLock.dispatch(false, event); } }, releasePointerLock: function () { document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock; document.exitPointerLock(); document.removeEventListener('pointerlockchange', this._pointerLockChange, true); document.removeEventListener('mozpointerlockchange', this._pointerLockChange, true); document.removeEventListener('webkitpointerlockchange', this._pointerLockChange, true); }, stop: function () { var canvas = this.game.canvas; canvas.removeEventListener('mousedown', this._onMouseDown, true); canvas.removeEventListener('mousemove', this._onMouseMove, true); canvas.removeEventListener('mouseup', this._onMouseUp, true); canvas.removeEventListener('mouseover', this._onMouseOver, true); canvas.removeEventListener('mouseout', this._onMouseOut, true); var wheelEvent = this.game.device.wheelEvent; if (wheelEvent) { canvas.removeEventListener(wheelEvent, this._onMouseWheel, true); } window.removeEventListener('mouseup', this._onMouseUpGlobal, true); window.removeEventListener('mouseout', this._onMouseOutGlobal, true); document.removeEventListener('pointerlockchange', this._pointerLockChange, true); document.removeEventListener('mozpointerlockchange', this._pointerLockChange, true); document.removeEventListener('webkitpointerlockchange', this._pointerLockChange, true); } }; Phaser.Mouse.prototype.constructor = Phaser.Mouse; function WheelEventProxy (scaleFactor, deltaMode) { this._scaleFactor = scaleFactor; this._deltaMode = deltaMode; this.originalEvent = null; } WheelEventProxy.prototype = {}; WheelEventProxy.prototype.constructor = WheelEventProxy; WheelEventProxy.prototype.bindEvent = function (event) { if (!WheelEventProxy._stubsGenerated && event) { var makeBinder = function (name) { return function () { var v = this.originalEvent[name]; return typeof v !== 'function' ? v : v.bind(this.originalEvent); }; }; for (var prop in event) { if (!(prop in WheelEventProxy.prototype)) { Object.defineProperty(WheelEventProxy.prototype, prop, { get: makeBinder(prop) }); } } WheelEventProxy._stubsGenerated = true; } this.originalEvent = event; return this; }; Object.defineProperties(WheelEventProxy.prototype, { "type": { value: "wheel" }, "deltaMode": { get: function () { return this._deltaMode; } }, "deltaY": { get: function () { return (this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail)) || 0; } }, "deltaX": { get: function () { return (this._scaleFactor * this.originalEvent.wheelDeltaX) || 0; } }, "deltaZ": { value: 0 } }); Phaser.MSPointer = function (game) { this.game = game; this.input = game.input; this.callbackContext = this.game; this.pointerDownCallback = null; this.pointerMoveCallback = null; this.pointerUpCallback = null; this.capture = true; this.button = -1; this.event = null; this.enabled = true; this._onMSPointerDown = null; this._onMSPointerMove = null; this._onMSPointerUp = null; this._onMSPointerUpGlobal = null; this._onMSPointerOut = null; this._onMSPointerOver = null; }; Phaser.MSPointer.prototype = { start: function () { if (this._onMSPointerDown !== null) { return; } var _this = this; if (this.game.device.mspointer) { this._onMSPointerDown = function (event) { return _this.onPointerDown(event); }; this._onMSPointerMove = function (event) { return _this.onPointerMove(event); }; this._onMSPointerUp = function (event) { return _this.onPointerUp(event); }; this._onMSPointerUpGlobal = function (event) { return _this.onPointerUpGlobal(event); }; this._onMSPointerOut = function (event) { return _this.onPointerOut(event); }; this._onMSPointerOver = function (event) { return _this.onPointerOver(event); }; var canvas = this.game.canvas; canvas.addEventListener('MSPointerDown', this._onMSPointerDown, false); canvas.addEventListener('MSPointerMove', this._onMSPointerMove, false); canvas.addEventListener('MSPointerUp', this._onMSPointerUp, false); canvas.addEventListener('pointerdown', this._onMSPointerDown, false); canvas.addEventListener('pointermove', this._onMSPointerMove, false); canvas.addEventListener('pointerup', this._onMSPointerUp, false); canvas.style['-ms-content-zooming'] = 'none'; canvas.style['-ms-touch-action'] = 'none'; if (!this.game.device.cocoonJS) { window.addEventListener('MSPointerUp', this._onMSPointerUpGlobal, true); canvas.addEventListener('MSPointerOver', this._onMSPointerOver, true); canvas.addEventListener('MSPointerOut', this._onMSPointerOut, true); window.addEventListener('pointerup', this._onMSPointerUpGlobal, true); canvas.addEventListener('pointerover', this._onMSPointerOver, true); canvas.addEventListener('pointerout', this._onMSPointerOut, true); } } }, onPointerDown: function (event) { this.event = event; if (this.capture) { event.preventDefault(); } if (this.pointerDownCallback) { this.pointerDownCallback.call(this.callbackContext, event); } if (!this.input.enabled || !this.enabled) { return; } event.identifier = event.pointerId; if (event.pointerType === 'mouse' || event.pointerType === 0x00000004) { this.input.mousePointer.start(event); } else { this.input.startPointer(event); } }, onPointerMove: function (event) { this.event = event; if (this.capture) { event.preventDefault(); } if (this.pointerMoveCallback) { this.pointerMoveCallback.call(this.callbackContext, event); } if (!this.input.enabled || !this.enabled) { return; } event.identifier = event.pointerId; if (event.pointerType === 'mouse' || event.pointerType === 0x00000004) { this.input.mousePointer.move(event); } else { this.input.updatePointer(event); } }, onPointerUp: function (event) { this.event = event; if (this.capture) { event.preventDefault(); } if (this.pointerUpCallback) { this.pointerUpCallback.call(this.callbackContext, event); } if (!this.input.enabled || !this.enabled) { return; } event.identifier = event.pointerId; if (event.pointerType === 'mouse' || event.pointerType === 0x00000004) { this.input.mousePointer.stop(event); } else { this.input.stopPointer(event); } }, onPointerUpGlobal: function (event) { if ((event.pointerType === 'mouse' || event.pointerType === 0x00000004) && !this.input.mousePointer.withinGame) { this.onPointerUp(event); } else { var pointer = this.input.getPointerFromIdentifier(event.identifier); if (pointer && pointer.withinGame) { this.onPointerUp(event); } } }, onPointerOut: function (event) { this.event = event; if (this.capture) { event.preventDefault(); } if (event.pointerType === 'mouse' || event.pointerType === 0x00000004) { this.input.mousePointer.withinGame = false; } else { var pointer = this.input.getPointerFromIdentifier(event.identifier); if (pointer) { pointer.withinGame = false; } } if (this.input.mouse.mouseOutCallback) { this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, event); } if (!this.input.enabled || !this.enabled) { return; } if (this.input.mouse.stopOnGameOut) { event['identifier'] = 0; if (pointer) { pointer.stop(event); } else { this.input.mousePointer.stop(event); } } }, onPointerOver: function (event) { this.event = event; if (this.capture) { event.preventDefault(); } if (event.pointerType === 'mouse' || event.pointerType === 0x00000004) { this.input.mousePointer.withinGame = true; } else { var pointer = this.input.getPointerFromIdentifier(event.identifier); if (pointer) { pointer.withinGame = true; } } if (this.input.mouse.mouseOverCallback) { this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, event); } }, stop: function () { var canvas = this.game.canvas; canvas.removeEventListener('MSPointerDown', this._onMSPointerDown, false); canvas.removeEventListener('MSPointerMove', this._onMSPointerMove, false); canvas.removeEventListener('MSPointerUp', this._onMSPointerUp, false); canvas.removeEventListener('pointerdown', this._onMSPointerDown, false); canvas.removeEventListener('pointermove', this._onMSPointerMove, false); canvas.removeEventListener('pointerup', this._onMSPointerUp, false); window.removeEventListener('MSPointerUp', this._onMSPointerUpGlobal, true); canvas.removeEventListener('MSPointerOver', this._onMSPointerOver, true); canvas.removeEventListener('MSPointerOut', this._onMSPointerOut, true); window.removeEventListener('pointerup', this._onMSPointerUpGlobal, true); canvas.removeEventListener('pointerover', this._onMSPointerOver, true); canvas.removeEventListener('pointerout', this._onMSPointerOut, true); } }; Phaser.MSPointer.prototype.constructor = Phaser.MSPointer; Phaser.DeviceButton = function (parent, buttonCode) { this.parent = parent; this.game = parent.game; this.event = null; this.isDown = false; this.isUp = true; this.timeDown = 0; this.timeUp = 0; this.repeats = 0; this.altKey = false; this.shiftKey = false; this.ctrlKey = false; this.value = 0; this.buttonCode = buttonCode; this.onDown = new Phaser.Signal(); this.onUp = new Phaser.Signal(); this.onFloat = new Phaser.Signal(); }; Phaser.DeviceButton.prototype = { start: function (event, value) { if (this.isDown) { return; } this.isDown = true; this.isUp = false; this.timeDown = this.game.time.time; this.repeats = 0; this.event = event; this.value = value; if (event) { this.altKey = event.altKey; this.shiftKey = event.shiftKey; this.ctrlKey = event.ctrlKey; } this.onDown.dispatch(this, value); }, stop: function (event, value) { if (this.isUp) { return; } this.isDown = false; this.isUp = true; this.timeUp = this.game.time.time; this.event = event; this.value = value; if (event) { this.altKey = event.altKey; this.shiftKey = event.shiftKey; this.ctrlKey = event.ctrlKey; } this.onUp.dispatch(this, value); }, padFloat: function (value) { this.value = value; this.onFloat.dispatch(this, value); }, justPressed: function (duration) { duration = duration || 250; return (this.isDown && (this.timeDown + duration) > this.game.time.time); }, justReleased: function (duration) { duration = duration || 250; return (this.isUp && (this.timeUp + duration) > this.game.time.time); }, reset: function () { this.isDown = false; this.isUp = true; this.timeDown = this.game.time.time; this.repeats = 0; this.altKey = false; this.shiftKey = false; this.ctrlKey = false; }, destroy: function () { this.onDown.dispose(); this.onUp.dispose(); this.onFloat.dispose(); this.parent = null; this.game = null; } }; Phaser.DeviceButton.prototype.constructor = Phaser.DeviceButton; Object.defineProperty(Phaser.DeviceButton.prototype, "duration", { get: function () { if (this.isUp) { return -1; } return this.game.time.time - this.timeDown; } }); Phaser.Pointer = function (game, id, pointerMode) { this.game = game; this.id = id; this.type = Phaser.POINTER; this.exists = true; this.identifier = 0; this.pointerId = null; this.pointerMode = pointerMode || (Phaser.PointerMode.CURSOR | Phaser.PointerMode.CONTACT); this.target = null; this.button = null; this.leftButton = new Phaser.DeviceButton(this, Phaser.Pointer.LEFT_BUTTON); this.middleButton = new Phaser.DeviceButton(this, Phaser.Pointer.MIDDLE_BUTTON); this.rightButton = new Phaser.DeviceButton(this, Phaser.Pointer.RIGHT_BUTTON); this.backButton = new Phaser.DeviceButton(this, Phaser.Pointer.BACK_BUTTON); this.forwardButton = new Phaser.DeviceButton(this, Phaser.Pointer.FORWARD_BUTTON); this.eraserButton = new Phaser.DeviceButton(this, Phaser.Pointer.ERASER_BUTTON); this._holdSent = false; this._history = []; this._nextDrop = 0; this._stateReset = false; this.withinGame = false; this.clientX = -1; this.clientY = -1; this.pageX = -1; this.pageY = -1; this.screenX = -1; this.screenY = -1; this.rawMovementX = 0; this.rawMovementY = 0; this.movementX = 0; this.movementY = 0; this.x = -1; this.y = -1; this.isMouse = (id === 0); this.isDown = false; this.isUp = true; this.timeDown = 0; this.timeUp = 0; this.previousTapTime = 0; this.totalTouches = 0; this.msSinceLastClick = Number.MAX_VALUE; this.targetObject = null; this.interactiveCandidates = []; this.active = false; this.dirty = false; this.position = new Phaser.Point(); this.positionDown = new Phaser.Point(); this.positionUp = new Phaser.Point(); this.circle = new Phaser.Circle(0, 0, 44); this._clickTrampolines = null; this._trampolineTargetObject = null; }; Phaser.Pointer.NO_BUTTON = 0; Phaser.Pointer.LEFT_BUTTON = 1; Phaser.Pointer.RIGHT_BUTTON = 2; Phaser.Pointer.MIDDLE_BUTTON = 4; Phaser.Pointer.BACK_BUTTON = 8; Phaser.Pointer.FORWARD_BUTTON = 16; Phaser.Pointer.ERASER_BUTTON = 32; Phaser.Pointer.prototype = { resetButtons: function () { this.isDown = false; this.isUp = true; if (this.isMouse) { this.leftButton.reset(); this.middleButton.reset(); this.rightButton.reset(); this.backButton.reset(); this.forwardButton.reset(); this.eraserButton.reset(); } }, processButtonsDown: function (buttons, event) { if (Phaser.Pointer.LEFT_BUTTON & buttons) { this.leftButton.start(event); } if (Phaser.Pointer.RIGHT_BUTTON & buttons) { this.rightButton.start(event); } if (Phaser.Pointer.MIDDLE_BUTTON & buttons) { this.middleButton.start(event); } if (Phaser.Pointer.BACK_BUTTON & buttons) { this.backButton.start(event); } if (Phaser.Pointer.FORWARD_BUTTON & buttons) { this.forwardButton.start(event); } if (Phaser.Pointer.ERASER_BUTTON & buttons) { this.eraserButton.start(event); } }, processButtonsUp: function (button, event) { if (button === Phaser.Mouse.LEFT_BUTTON) { this.leftButton.stop(event); } if (button === Phaser.Mouse.RIGHT_BUTTON) { this.rightButton.stop(event); } if (button === Phaser.Mouse.MIDDLE_BUTTON) { this.middleButton.stop(event); } if (button === Phaser.Mouse.BACK_BUTTON) { this.backButton.stop(event); } if (button === Phaser.Mouse.FORWARD_BUTTON) { this.forwardButton.stop(event); } if (button === 5) { this.eraserButton.stop(event); } }, updateButtons: function (event) { this.button = event.button; var down = (event.type.toLowerCase().substr(-4) === 'down'); if (event.buttons !== undefined) { if (down) { this.processButtonsDown(event.buttons, event); } else { this.processButtonsUp(event.button, event); } } else { if (down) { this.leftButton.start(event); } else { this.leftButton.stop(event); this.rightButton.stop(event); } } if (event.buttons === 1 && event.ctrlKey && this.leftButton.isDown) { this.leftButton.stop(event); this.rightButton.start(event); } this.isUp = true; this.isDown = false; if (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) { this.isUp = false; this.isDown = true; } }, start: function (event) { var input = this.game.input; if (event['pointerId']) { this.pointerId = event.pointerId; } this.identifier = event.identifier; this.target = event.target; if (this.isMouse) { this.updateButtons(event); } else { this.isDown = true; this.isUp = false; } this.active = true; this.withinGame = true; this.dirty = false; this._history = []; this._clickTrampolines = null; this._trampolineTargetObject = null; this.msSinceLastClick = this.game.time.time - this.timeDown; this.timeDown = this.game.time.time; this._holdSent = false; this.move(event, true); this.positionDown.setTo(this.x, this.y); if (input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || (input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && input.totalActivePointers === 0)) { input.x = this.x; input.y = this.y; input.position.setTo(this.x, this.y); input.onDown.dispatch(this, event); input.resetSpeed(this.x, this.y); } this._stateReset = false; this.totalTouches++; if (this.targetObject !== null) { this.targetObject._touchedHandler(this); } return this; }, update: function () { var input = this.game.input; if (this.active) { if (this.dirty) { if (input.interactiveItems.total > 0) { this.processInteractiveObjects(false); } this.dirty = false; } if (this._holdSent === false && this.duration >= input.holdRate) { if (input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || (input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && input.totalActivePointers === 0)) { input.onHold.dispatch(this); } this._holdSent = true; } if (input.recordPointerHistory && this.game.time.time >= this._nextDrop) { this._nextDrop = this.game.time.time + input.recordRate; this._history.push({ x: this.position.x, y: this.position.y }); if (this._history.length > input.recordLimit) { this._history.shift(); } } } }, move: function (event, fromClick) { var input = this.game.input; if (input.pollLocked) { return; } if (fromClick === undefined) { fromClick = false; } if (event.button !== undefined) { this.button = event.button; } if (fromClick && this.isMouse) { this.updateButtons(event); } this.clientX = event.clientX; this.clientY = event.clientY; this.pageX = event.pageX; this.pageY = event.pageY; this.screenX = event.screenX; this.screenY = event.screenY; if (this.isMouse && input.mouse.locked && !fromClick) { this.rawMovementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0; this.rawMovementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0; this.movementX += this.rawMovementX; this.movementY += this.rawMovementY; } this.x = (this.pageX - this.game.scale.offset.x) * input.scale.x; this.y = (this.pageY - this.game.scale.offset.y) * input.scale.y; this.position.setTo(this.x, this.y); this.circle.x = this.x; this.circle.y = this.y; if (input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || (input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && input.totalActivePointers === 0)) { input.activePointer = this; input.x = this.x; input.y = this.y; input.position.setTo(input.x, input.y); input.circle.x = input.x; input.circle.y = input.y; } this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY); if (this.game.paused) { return this; } var i = input.moveCallbacks.length; while (i--) { input.moveCallbacks[i].callback.call(input.moveCallbacks[i].context, this, this.x, this.y, fromClick); } if (this.targetObject !== null && this.targetObject.isDragged === true) { if (this.targetObject.update(this) === false) { this.targetObject = null; } } else if (input.interactiveItems.total > 0) { this.processInteractiveObjects(fromClick); } return this; }, processInteractiveObjects: function (fromClick) { var highestRenderOrderID = 0; var highestInputPriorityID = -1; var candidateTarget = null; var currentNode = this.game.input.interactiveItems.first; this.interactiveCandidates = []; while (currentNode) { currentNode.checked = false; if (currentNode.validForInput(highestInputPriorityID, highestRenderOrderID, false)) { currentNode.checked = true; if ((fromClick && currentNode.checkPointerDown(this, true)) || (!fromClick && currentNode.checkPointerOver(this, true))) { highestRenderOrderID = currentNode.sprite.renderOrderID; highestInputPriorityID = currentNode.priorityID; candidateTarget = currentNode; this.interactiveCandidates.push(currentNode); } } currentNode = this.game.input.interactiveItems.next; } currentNode = this.game.input.interactiveItems.first; while (currentNode) { if (!currentNode.checked && currentNode.validForInput(highestInputPriorityID, highestRenderOrderID, true)) { if ((fromClick && currentNode.checkPointerDown(this, false)) || (!fromClick && currentNode.checkPointerOver(this, false))) { highestRenderOrderID = currentNode.sprite.renderOrderID; highestInputPriorityID = currentNode.priorityID; candidateTarget = currentNode; this.interactiveCandidates.push(currentNode); } } currentNode = this.game.input.interactiveItems.next; } if (this.game.input.customCandidateHandler) { candidateTarget = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, candidateTarget); } this.swapTarget(candidateTarget, false); return (this.targetObject !== null); }, swapTarget: function (newTarget, silent) { if (silent === undefined) { silent = false; } if (newTarget === null) { if (this.targetObject) { this.targetObject._pointerOutHandler(this, silent); this.targetObject = null; } } else { if (this.targetObject === null) { this.targetObject = newTarget; newTarget._pointerOverHandler(this, silent); } else { if (this.targetObject === newTarget) { if (newTarget.update(this) === false) { this.targetObject = null; } } else { this.targetObject._pointerOutHandler(this, silent); this.targetObject = newTarget; this.targetObject._pointerOverHandler(this, silent); } } } }, leave: function (event) { this.withinGame = false; this.move(event, false); }, stop: function (event) { var input = this.game.input; if (this._stateReset && this.withinGame) { event.preventDefault(); return; } this.timeUp = this.game.time.time; if (input.multiInputOverride === Phaser.Input.MOUSE_OVERRIDES_TOUCH || input.multiInputOverride === Phaser.Input.MOUSE_TOUCH_COMBINE || (input.multiInputOverride === Phaser.Input.TOUCH_OVERRIDES_MOUSE && input.totalActivePointers === 0)) { input.onUp.dispatch(this, event); if (this.duration >= 0 && this.duration <= input.tapRate) { if (this.timeUp - this.previousTapTime < input.doubleTapRate) { input.onTap.dispatch(this, true); } else { input.onTap.dispatch(this, false); } this.previousTapTime = this.timeUp; } } if (this.isMouse) { this.updateButtons(event); } else { this.isDown = false; this.isUp = true; } if (this.id > 0) { this.active = false; } this.withinGame = this.game.scale.bounds.contains(event.pageX, event.pageY); this.pointerId = null; this.identifier = null; this.positionUp.setTo(this.x, this.y); if (this.isMouse === false) { input.currentPointers--; } input.interactiveItems.callAll('_releasedHandler', this); if (this._clickTrampolines) { this._trampolineTargetObject = this.targetObject; } this.targetObject = null; return this; }, justPressed: function (duration) { duration = duration || this.game.input.justPressedRate; return (this.isDown === true && (this.timeDown + duration) > this.game.time.time); }, justReleased: function (duration) { duration = duration || this.game.input.justReleasedRate; return (this.isUp && (this.timeUp + duration) > this.game.time.time); }, addClickTrampoline: function (name, callback, callbackContext, callbackArgs) { if (!this.isDown) { return; } var trampolines = (this._clickTrampolines = this._clickTrampolines || []); for (var i = 0; i < trampolines.length; i++) { if (trampolines[i].name === name) { trampolines.splice(i, 1); break; } } trampolines.push({ name: name, targetObject: this.targetObject, callback: callback, callbackContext: callbackContext, callbackArgs: callbackArgs }); }, processClickTrampolines: function () { var trampolines = this._clickTrampolines; if (!trampolines) { return; } for (var i = 0; i < trampolines.length; i++) { var trampoline = trampolines[i]; if (trampoline.targetObject === this._trampolineTargetObject) { trampoline.callback.apply(trampoline.callbackContext, trampoline.callbackArgs); } } this._clickTrampolines = null; this._trampolineTargetObject = null; }, reset: function () { if (this.isMouse === false) { this.active = false; } this.pointerId = null; this.identifier = null; this.dirty = false; this.totalTouches = 0; this._holdSent = false; this._history.length = 0; this._stateReset = true; this.resetButtons(); if (this.targetObject) { this.targetObject._releasedHandler(this); } this.targetObject = null; }, resetMovement: function() { this.movementX = 0; this.movementY = 0; } }; Phaser.Pointer.prototype.constructor = Phaser.Pointer; Object.defineProperty(Phaser.Pointer.prototype, "duration", { get: function () { if (this.isUp) { return -1; } return this.game.time.time - this.timeDown; } }); Object.defineProperty(Phaser.Pointer.prototype, "worldX", { get: function () { return this.game.world.camera.x + this.x; } }); Object.defineProperty(Phaser.Pointer.prototype, "worldY", { get: function () { return this.game.world.camera.y + this.y; } }); Phaser.PointerMode = { CURSOR: 1 << 0, CONTACT: 1 << 1 }; Phaser.Touch = function (game) { this.game = game; this.enabled = true; this.touchLockCallbacks = []; this.callbackContext = this.game; this.touchStartCallback = null; this.touchMoveCallback = null; this.touchEndCallback = null; this.touchEnterCallback = null; this.touchLeaveCallback = null; this.touchCancelCallback = null; this.preventDefault = true; this.event = null; this._onTouchStart = null; this._onTouchMove = null; this._onTouchEnd = null; this._onTouchEnter = null; this._onTouchLeave = null; this._onTouchCancel = null; this._onTouchMove = null; }; Phaser.Touch.prototype = { start: function () { if (this._onTouchStart !== null) { return; } var _this = this; if (this.game.device.touch) { this._onTouchStart = function (event) { return _this.onTouchStart(event); }; this._onTouchMove = function (event) { return _this.onTouchMove(event); }; this._onTouchEnd = function (event) { return _this.onTouchEnd(event); }; this._onTouchEnter = function (event) { return _this.onTouchEnter(event); }; this._onTouchLeave = function (event) { return _this.onTouchLeave(event); }; this._onTouchCancel = function (event) { return _this.onTouchCancel(event); }; this.game.canvas.addEventListener('touchstart', this._onTouchStart, false); this.game.canvas.addEventListener('touchmove', this._onTouchMove, false); this.game.canvas.addEventListener('touchend', this._onTouchEnd, false); this.game.canvas.addEventListener('touchcancel', this._onTouchCancel, false); if (!this.game.device.cocoonJS) { this.game.canvas.addEventListener('touchenter', this._onTouchEnter, false); this.game.canvas.addEventListener('touchleave', this._onTouchLeave, false); } } }, consumeDocumentTouches: function () { this._documentTouchMove = function (event) { event.preventDefault(); }; document.addEventListener('touchmove', this._documentTouchMove, false); }, addTouchLockCallback: function (callback, context, onEnd) { if (onEnd === undefined) { onEnd = false; } this.touchLockCallbacks.push({ callback: callback, context: context, onEnd: onEnd }); }, removeTouchLockCallback: function (callback, context) { var i = this.touchLockCallbacks.length; while (i--) { if (this.touchLockCallbacks[i].callback === callback && this.touchLockCallbacks[i].context === context) { this.touchLockCallbacks.splice(i, 1); return true; } } return false; }, onTouchStart: function (event) { var i = this.touchLockCallbacks.length; while (i--) { var cb = this.touchLockCallbacks[i]; if (!cb.onEnd && cb.callback.call(cb.context, this, event)) { this.touchLockCallbacks.splice(i, 1); } } this.event = event; if (!this.game.input.enabled || !this.enabled) { return; } if (this.touchStartCallback) { this.touchStartCallback.call(this.callbackContext, event); } if (this.preventDefault) { event.preventDefault(); } for (var i = 0; i < event.changedTouches.length; i++) { this.game.input.startPointer(event.changedTouches[i]); } }, onTouchCancel: function (event) { this.event = event; if (this.touchCancelCallback) { this.touchCancelCallback.call(this.callbackContext, event); } if (!this.game.input.enabled || !this.enabled) { return; } if (this.preventDefault) { event.preventDefault(); } for (var i = 0; i < event.changedTouches.length; i++) { this.game.input.stopPointer(event.changedTouches[i]); } }, onTouchEnter: function (event) { this.event = event; if (this.touchEnterCallback) { this.touchEnterCallback.call(this.callbackContext, event); } if (!this.game.input.enabled || !this.enabled) { return; } if (this.preventDefault) { event.preventDefault(); } }, onTouchLeave: function (event) { this.event = event; if (this.touchLeaveCallback) { this.touchLeaveCallback.call(this.callbackContext, event); } if (this.preventDefault) { event.preventDefault(); } }, onTouchMove: function (event) { this.event = event; if (this.touchMoveCallback) { this.touchMoveCallback.call(this.callbackContext, event); } if (this.preventDefault) { event.preventDefault(); } for (var i = 0; i < event.changedTouches.length; i++) { this.game.input.updatePointer(event.changedTouches[i]); } }, onTouchEnd: function (event) { var i = this.touchLockCallbacks.length; while (i--) { var cb = this.touchLockCallbacks[i]; if (cb.onEnd && cb.callback.call(cb.context, this, event)) { this.touchLockCallbacks.splice(i, 1); } } this.event = event; if (this.touchEndCallback) { this.touchEndCallback.call(this.callbackContext, event); } if (this.preventDefault) { event.preventDefault(); } for (var i = 0; i < event.changedTouches.length; i++) { this.game.input.stopPointer(event.changedTouches[i]); } }, stop: function () { if (this.game.device.touch) { this.game.canvas.removeEventListener('touchstart', this._onTouchStart); this.game.canvas.removeEventListener('touchmove', this._onTouchMove); this.game.canvas.removeEventListener('touchend', this._onTouchEnd); this.game.canvas.removeEventListener('touchenter', this._onTouchEnter); this.game.canvas.removeEventListener('touchleave', this._onTouchLeave); this.game.canvas.removeEventListener('touchcancel', this._onTouchCancel); } } }; Phaser.Touch.prototype.constructor = Phaser.Touch;