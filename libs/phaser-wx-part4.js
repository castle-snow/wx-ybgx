import PIXI from './pixi-wx.js';import Phaser from './phaser-wx-main.js';Phaser.BitmapData = function (game, key, width, height, skipPool) { if (width === undefined || width === 0) { width = 256; } if (height === undefined || height === 0) { height = 256; } if (skipPool === undefined) { skipPool = false; } this.game = game; this.key = key; this.width = width; this.height = height; this.canvas = Phaser.Canvas.create(this, width, height, null, skipPool); this.context = this.canvas.getContext('2d', { alpha: true }); this.ctx = this.context; this.smoothProperty = (game.renderType === Phaser.CANVAS) ? game.renderer.renderSession.smoothProperty : Phaser.Canvas.getSmoothingPrefix(this.context); this.imageData = this.context.getImageData(0, 0, width, height); this.data = null; if (this.imageData) { this.data = this.imageData.data; } this.pixels = null; if (this.data) { if (this.imageData.data.buffer) { this.buffer = this.imageData.data.buffer; this.pixels = new Uint32Array(this.buffer); } else { if (window['ArrayBuffer']) { this.buffer = new ArrayBuffer(this.imageData.data.length); this.pixels = new Uint32Array(this.buffer); } else { this.pixels = this.imageData.data; } } } this.baseTexture = new PIXI.BaseTexture(this.canvas); this.texture = new PIXI.Texture(this.baseTexture); this.frameData = new Phaser.FrameData(); this.textureFrame = this.frameData.addFrame(new Phaser.Frame(0, 0, 0, width, height, 'bitmapData')); this.texture.frame = this.textureFrame; this.type = Phaser.BITMAPDATA; this.disableTextureUpload = false; this.dirty = false; this.cls = this.clear; this._image = null; this._pos = new Phaser.Point(); this._size = new Phaser.Point(); this._scale = new Phaser.Point(); this._rotate = 0; this._alpha = { prev: 1, current: 1 }; this._anchor = new Phaser.Point(); this._tempR = 0; this._tempG = 0; this._tempB = 0; this._circle = new Phaser.Circle(); this._swapCanvas = undefined; }; Phaser.BitmapData.prototype = { move: function (x, y, wrap) { if (x !== 0) { this.moveH(x, wrap); } if (y !== 0) { this.moveV(y, wrap); } return this; }, moveH: function (distance, wrap) { if (wrap === undefined) { wrap = true; } if (this._swapCanvas === undefined) { this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height); } var c = this._swapCanvas; var ctx = c.getContext('2d'); var h = this.height; var src = this.canvas; ctx.clearRect(0, 0, this.width, this.height); if (distance < 0) { distance = Math.abs(distance); var w = this.width - distance; if (wrap) { ctx.drawImage(src, 0, 0, distance, h, w, 0, distance, h); } ctx.drawImage(src, distance, 0, w, h, 0, 0, w, h); } else { var w = this.width - distance; if (wrap) { ctx.drawImage(src, w, 0, distance, h, 0, 0, distance, h); } ctx.drawImage(src, 0, 0, w, h, distance, 0, w, h); } this.clear(); return this.copy(this._swapCanvas); }, moveV: function (distance, wrap) { if (wrap === undefined) { wrap = true; } if (this._swapCanvas === undefined) { this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height); } var c = this._swapCanvas; var ctx = c.getContext('2d'); var w = this.width; var src = this.canvas; ctx.clearRect(0, 0, this.width, this.height); if (distance < 0) { distance = Math.abs(distance); var h = this.height - distance; if (wrap) { ctx.drawImage(src, 0, 0, w, distance, 0, h, w, distance); } ctx.drawImage(src, 0, distance, w, h, 0, 0, w, h); } else { var h = this.height - distance; if (wrap) { ctx.drawImage(src, 0, h, w, distance, 0, 0, w, distance); } ctx.drawImage(src, 0, 0, w, h, 0, distance, w, h); } this.clear(); return this.copy(this._swapCanvas); }, add: function (object) { if (Array.isArray(object)) { for (var i = 0; i < object.length; i++) { if (object[i]['loadTexture']) { object[i].loadTexture(this); } } } else { object.loadTexture(this); } return this; }, load: function (source) { if (typeof source === 'string') { source = this.game.cache.getImage(source); } if (source) { this.resize(source.width, source.height); this.cls(); } else { return; } this.draw(source); this.update(); return this; }, clear: function (x, y, width, height) { if (x === undefined) { x = 0; } if (y === undefined) { y = 0; } if (width === undefined) { width = this.width; } if (height === undefined) { height = this.height; } this.context.clearRect(x, y, width, height); this.dirty = true; return this; }, fill: function (r, g, b, a) { if (a === undefined) { a = 1; } this.context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'; this.context.fillRect(0, 0, this.width, this.height); this.dirty = true; return this; }, generateTexture: function (key) { var image = new Image(); image.src = this.canvas.toDataURL("image/png"); var obj = this.game.cache.addImage(key, '', image); return new PIXI.Texture(obj.base); }, resize: function (width, height) { if (width !== this.width || height !== this.height) { this.width = width; this.height = height; this.canvas.width = width; this.canvas.height = height; if (this._swapCanvas !== undefined) { this._swapCanvas.width = width; this._swapCanvas.height = height; } this.baseTexture.width = width; this.baseTexture.height = height; this.textureFrame.width = width; this.textureFrame.height = height; this.texture.width = width; this.texture.height = height; this.texture.crop.width = width; this.texture.crop.height = height; this.update(); this.dirty = true; } return this; }, update: function (x, y, width, height) { if (x === undefined) { x = 0; } if (y === undefined) { y = 0; } if (width === undefined) { width = Math.max(1, this.width); } if (height === undefined) { height = Math.max(1, this.height); } this.imageData = this.context.getImageData(x, y, width, height); this.data = this.imageData.data; if (this.imageData.data.buffer) { this.buffer = this.imageData.data.buffer; this.pixels = new Uint32Array(this.buffer); } else { if (window['ArrayBuffer']) { this.buffer = new ArrayBuffer(this.imageData.data.length); this.pixels = new Uint32Array(this.buffer); } else { this.pixels = this.imageData.data; } } return this; }, processPixelRGB: function (callback, callbackContext, x, y, width, height) { if (x === undefined) { x = 0; } if (y === undefined) { y = 0; } if (width === undefined) { width = this.width; } if (height === undefined) { height = this.height; } var w = x + width; var h = y + height; var pixel = Phaser.Color.createColor(); var result = { r: 0, g: 0, b: 0, a: 0 }; var dirty = false; for (var ty = y; ty < h; ty++) { for (var tx = x; tx < w; tx++) { Phaser.Color.unpackPixel(this.getPixel32(tx, ty), pixel); result = callback.call(callbackContext, pixel, tx, ty); if (result !== false && result !== null && result !== undefined) { this.setPixel32(tx, ty, result.r, result.g, result.b, result.a, false); dirty = true; } } } if (dirty) { this.context.putImageData(this.imageData, 0, 0); this.dirty = true; } return this; }, processPixel: function (callback, callbackContext, x, y, width, height) { if (x === undefined) { x = 0; } if (y === undefined) { y = 0; } if (width === undefined) { width = this.width; } if (height === undefined) { height = this.height; } var w = x + width; var h = y + height; var pixel = 0; var result = 0; var dirty = false; for (var ty = y; ty < h; ty++) { for (var tx = x; tx < w; tx++) { pixel = this.getPixel32(tx, ty); result = callback.call(callbackContext, pixel, tx, ty); if (result !== pixel) { this.pixels[ty * this.width + tx] = result; dirty = true; } } } if (dirty) { this.context.putImageData(this.imageData, 0, 0); this.dirty = true; } return this; }, replaceRGB: function (r1, g1, b1, a1, r2, g2, b2, a2, region) { var sx = 0; var sy = 0; var w = this.width; var h = this.height; var source = Phaser.Color.packPixel(r1, g1, b1, a1); if (region !== undefined && region instanceof Phaser.Rectangle) { sx = region.x; sy = region.y; w = region.width; h = region.height; } for (var y = 0; y < h; y++) { for (var x = 0; x < w; x++) { if (this.getPixel32(sx + x, sy + y) === source) { this.setPixel32(sx + x, sy + y, r2, g2, b2, a2, false); } } } this.context.putImageData(this.imageData, 0, 0); this.dirty = true; return this; }, setHSL: function (h, s, l, region) { var bHaveH = h || h === 0; var bHaveS = s || s === 0; var bHaveL = l || l === 0; if (!bHaveH && !bHaveS && !bHaveL) { return; } if (region === undefined) { region = new Phaser.Rectangle(0, 0, this.width, this.height); } var pixel = Phaser.Color.createColor(); for (var y = region.y; y < region.bottom; y++) { for (var x = region.x; x < region.right; x++) { Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true); if (bHaveH) { pixel.h = h; } if (bHaveS) { pixel.s = s; } if (bHaveL) { pixel.l = l; } Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel); this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false); } } this.context.putImageData(this.imageData, 0, 0); this.dirty = true; return this; }, shiftHSL: function (h, s, l, region) { if (h === undefined || h === null) { h = false; } if (s === undefined || s === null) { s = false; } if (l === undefined || l === null) { l = false; } if (!h && !s && !l) { return; } if (region === undefined) { region = new Phaser.Rectangle(0, 0, this.width, this.height); } var pixel = Phaser.Color.createColor(); for (var y = region.y; y < region.bottom; y++) { for (var x = region.x; x < region.right; x++) { Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel, true); if (h) { pixel.h = this.game.math.wrap(pixel.h + h, 0, 1); } if (s) { pixel.s = this.game.math.clamp(pixel.s + s, 0, 1); } if (l) { pixel.l = this.game.math.clamp(pixel.l + l, 0, 1); } Phaser.Color.HSLtoRGB(pixel.h, pixel.s, pixel.l, pixel); this.setPixel32(x, y, pixel.r, pixel.g, pixel.b, pixel.a, false); } } this.context.putImageData(this.imageData, 0, 0); this.dirty = true; return this; }, setPixel32: function (x, y, red, green, blue, alpha, immediate) { if (immediate === undefined) { immediate = true; } if (x >= 0 && x <= this.width && y >= 0 && y <= this.height) { if (Phaser.Device.LITTLE_ENDIAN) { this.pixels[y * this.width + x] = (alpha << 24) | (blue << 16) | (green << 8) | red; } else { this.pixels[y * this.width + x] = (red << 24) | (green << 16) | (blue << 8) | alpha; } if (immediate) { this.context.putImageData(this.imageData, 0, 0); this.dirty = true; } } return this; }, setPixel: function (x, y, red, green, blue, immediate) { return this.setPixel32(x, y, red, green, blue, 255, immediate); }, getPixel: function (x, y, out) { if (!out) { out = Phaser.Color.createColor(); } var index = ~~(x + (y * this.width)); index *= 4; out.r = this.data[index]; out.g = this.data[++index]; out.b = this.data[++index]; out.a = this.data[++index]; return out; }, getPixel32: function (x, y) { if (x >= 0 && x <= this.width && y >= 0 && y <= this.height) { return this.pixels[y * this.width + x]; } }, getPixelRGB: function (x, y, out, hsl, hsv) { return Phaser.Color.unpackPixel(this.getPixel32(x, y), out, hsl, hsv); }, getPixels: function (rect) { return this.context.getImageData(rect.x, rect.y, rect.width, rect.height); }, getFirstPixel: function (direction) { if (direction === undefined) { direction = 0; } var pixel = Phaser.Color.createColor(); var x = 0; var y = 0; var v = 1; var scan = false; if (direction === 1) { v = -1; y = this.height; } else if (direction === 3) { v = -1; x = this.width; } do { Phaser.Color.unpackPixel(this.getPixel32(x, y), pixel); if (direction === 0 || direction === 1) { x++; if (x === this.width) { x = 0; y += v; if (y >= this.height || y <= 0) { scan = true; } } } else if (direction === 2 || direction === 3) { y++; if (y === this.height) { y = 0; x += v; if (x >= this.width || x <= 0) { scan = true; } } } } while (pixel.a === 0 && !scan); pixel.x = x; pixel.y = y; return pixel; }, getBounds: function (rect) { if (rect === undefined) { rect = new Phaser.Rectangle(); } rect.x = this.getFirstPixel(2).x; if (rect.x === this.width) { return rect.setTo(0, 0, 0, 0); } rect.y = this.getFirstPixel(0).y; rect.width = (this.getFirstPixel(3).x - rect.x) + 1; rect.height = (this.getFirstPixel(1).y - rect.y) + 1; return rect; }, addToWorld: function (x, y, anchorX, anchorY, scaleX, scaleY) { scaleX = scaleX || 1; scaleY = scaleY || 1; var image = this.game.add.image(x, y, this); image.anchor.set(anchorX, anchorY); image.scale.set(scaleX, scaleY); return image; }, copy: function (source, x, y, width, height, tx, ty, newWidth, newHeight, rotate, anchorX, anchorY, scaleX, scaleY, alpha, blendMode, roundPx) { if (source === undefined || source === null) { source = this; } if (source instanceof Phaser.RenderTexture || source instanceof PIXI.RenderTexture) { source = source.getCanvas(); } this._image = source; if (source instanceof Phaser.Sprite || source instanceof Phaser.Image || source instanceof Phaser.Text || source instanceof PIXI.Sprite) { this._pos.set(source.texture.crop.x, source.texture.crop.y); this._size.set(source.texture.crop.width, source.texture.crop.height); this._scale.set(source.scale.x, source.scale.y); this._anchor.set(source.anchor.x, source.anchor.y); this._rotate = source.rotation; this._alpha.current = source.alpha; if (source.texture instanceof Phaser.RenderTexture || source.texture instanceof PIXI.RenderTexture) { this._image = source.texture.getCanvas(); } else { this._image = source.texture.baseTexture.source; } if (tx === undefined || tx === null) { tx = source.x; } if (ty === undefined || ty === null) { ty = source.y; } if (source.texture.trim) { tx += source.texture.trim.x - source.anchor.x * source.texture.trim.width; ty += source.texture.trim.y - source.anchor.y * source.texture.trim.height; } if (source.tint !== 0xFFFFFF) { if (source.cachedTint !== source.tint) { source.cachedTint = source.tint; source.tintedTexture = PIXI.CanvasTinter.getTintedTexture(source, source.tint); } this._image = source.tintedTexture; this._pos.set(0); } } else { this._pos.set(0); this._scale.set(1); this._anchor.set(0); this._rotate = 0; this._alpha.current = 1; if (source instanceof Phaser.BitmapData) { this._image = source.canvas; } else if (typeof source === 'string') { source = this.game.cache.getImage(source); if (source === null) { return; } else { this._image = source; } } this._size.set(this._image.width, this._image.height); } if (x === undefined || x === null) { x = 0; } if (y === undefined || y === null) { y = 0; } if (width) { this._size.x = width; } if (height) { this._size.y = height; } if (tx === undefined || tx === null) { tx = x; } if (ty === undefined || ty === null) { ty = y; } if (newWidth === undefined || newWidth === null) { newWidth = this._size.x; } if (newHeight === undefined || newHeight === null) { newHeight = this._size.y; } if (typeof rotate === 'number') { this._rotate = rotate; } if (typeof anchorX === 'number') { this._anchor.x = anchorX; } if (typeof anchorY === 'number') { this._anchor.y = anchorY; } if (typeof scaleX === 'number') { this._scale.x = scaleX; } if (typeof scaleY === 'number') { this._scale.y = scaleY; } if (typeof alpha === 'number') { this._alpha.current = alpha; } if (blendMode === undefined) { blendMode = null; } if (roundPx === undefined) { roundPx = false; } if (this._alpha.current <= 0 || this._scale.x === 0 || this._scale.y === 0 || this._size.x === 0 || this._size.y === 0) { return; } var ctx = this.context; this._alpha.prev = ctx.globalAlpha; ctx.save(); ctx.globalAlpha = this._alpha.current; if (blendMode) { this.op = blendMode; } if (roundPx) { tx |= 0; ty |= 0; } ctx.translate(tx, ty); ctx.scale(this._scale.x, this._scale.y); ctx.rotate(this._rotate); ctx.drawImage(this._image, this._pos.x + x, this._pos.y + y, this._size.x, this._size.y, -newWidth * this._anchor.x, -newHeight * this._anchor.y, newWidth, newHeight); ctx.restore(); ctx.globalAlpha = this._alpha.prev; this.dirty = true; return this; }, copyTransform: function (source, blendMode, roundPx) { if (blendMode === undefined) { blendMode = null; } if (roundPx === undefined) { roundPx = false; } if (!source.hasOwnProperty('worldTransform') || !source.worldVisible || source.worldAlpha === 0) { return this; } var wt = source.worldTransform; this._pos.set(source.texture.crop.x, source.texture.crop.y); this._size.set(source.texture.crop.width, source.texture.crop.height); if (wt.a === 0 || wt.d === 0 || this._size.x === 0 || this._size.y === 0) { return this; } if (source.texture instanceof Phaser.RenderTexture || source.texture instanceof PIXI.RenderTexture) { this._image = source.texture.getCanvas(); } else { this._image = source.texture.baseTexture.source; } var tx = wt.tx; var ty = wt.ty; if (source.texture.trim) { tx += source.texture.trim.x - source.anchor.x * source.texture.trim.width; ty += source.texture.trim.y - source.anchor.y * source.texture.trim.height; } if (source.tint !== 0xFFFFFF) { if (source.cachedTint !== source.tint) { source.cachedTint = source.tint; source.tintedTexture = PIXI.CanvasTinter.getTintedTexture(source, source.tint); } this._image = source.tintedTexture; this._pos.set(0); } if (roundPx) { tx |= 0; ty |= 0; } var ctx = this.context; this._alpha.prev = ctx.globalAlpha; ctx.save(); ctx.globalAlpha = this._alpha.current; if (blendMode) { this.op = blendMode; } ctx[this.smoothProperty] = (source.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR); ctx.setTransform(wt.a, wt.b, wt.c, wt.d, tx, ty); ctx.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * source.anchor.x, -this._size.y * source.anchor.y, this._size.x, this._size.y); ctx.restore(); ctx.globalAlpha = this._alpha.prev; this.dirty = true; return this; }, copyRect: function (source, area, x, y, alpha, blendMode, roundPx) { return this.copy(source, area.x, area.y, area.width, area.height, x, y, area.width, area.height, 0, 0, 0, 1, 1, alpha, blendMode, roundPx); }, draw: function (source, x, y, width, height, blendMode, roundPx) { return this.copy(source, null, null, null, null, x, y, width, height, null, null, null, null, null, null, blendMode, roundPx); }, drawGroup: function (group, blendMode, roundPx) { if (group.total > 0) { group.forEachExists(this.drawGroupProxy, this, blendMode, roundPx); } return this; }, drawGroupProxy: function (child, blendMode, roundPx) { if (child.hasOwnProperty('texture')) { this.copyTransform(child, blendMode, roundPx); } if (child.type === Phaser.GROUP && child.exists) { this.drawGroup(child, blendMode, roundPx); } else { if (child.hasOwnProperty('children') && child.children.length > 0) { for (var i = 0; i < child.children.length; i++) { if (child.children[i].exists) { this.copyTransform(child.children[i], blendMode, roundPx); } } } } }, drawFull: function (parent, blendMode, roundPx) { if (parent.worldVisible === false || parent.worldAlpha === 0 || (parent.hasOwnProperty('exists') && parent.exists === false)) { return this; } if (parent.type !== Phaser.GROUP && parent.type !== Phaser.EMITTER && parent.type !== Phaser.BITMAPTEXT) { if (parent.type === Phaser.GRAPHICS) { var bounds = parent.getBounds(); this.ctx.save(); this.ctx.translate(bounds.x, bounds.y); PIXI.CanvasGraphics.renderGraphics(parent, this.ctx); this.ctx.restore(); } else { this.copy(parent, null, null, null, null, parent.worldPosition.x, parent.worldPosition.y, null, null, parent.worldRotation, null, null, parent.worldScale.x, parent.worldScale.y, parent.worldAlpha, blendMode, roundPx); } } if (parent.children) { for (var i = 0; i < parent.children.length; i++) { this.drawFull(parent.children[i], blendMode, roundPx); } } return this; }, shadow: function (color, blur, x, y) { var ctx = this.context; if (color === undefined || color === null) { ctx.shadowColor = 'rgba(0,0,0,0)'; } else { ctx.shadowColor = color; ctx.shadowBlur = blur || 5; ctx.shadowOffsetX = x || 10; ctx.shadowOffsetY = y || 10; } return this; }, alphaMask: function (source, mask, sourceRect, maskRect) { if (maskRect === undefined || maskRect === null) { this.draw(mask).blendSourceAtop(); } else { this.draw(mask, maskRect.x, maskRect.y, maskRect.width, maskRect.height).blendSourceAtop(); } if (sourceRect === undefined || sourceRect === null) { this.draw(source).blendReset(); } else { this.draw(source, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height).blendReset(); } return this; }, extract: function (destination, r, g, b, a, resize, r2, g2, b2) { if (a === undefined) { a = 255; } if (resize === undefined) { resize = false; } if (r2 === undefined) { r2 = r; } if (g2 === undefined) { g2 = g; } if (b2 === undefined) { b2 = b; } if (resize) { destination.resize(this.width, this.height); } this.processPixelRGB( function (pixel, x, y) { if (pixel.r === r && pixel.g === g && pixel.b === b) { destination.setPixel32(x, y, r2, g2, b2, a, false); } return false; }, this); destination.context.putImageData(destination.imageData, 0, 0); destination.dirty = true; return destination; }, rect: function (x, y, width, height, fillStyle) { if (typeof fillStyle !== 'undefined') { this.context.fillStyle = fillStyle; } this.context.fillRect(x, y, width, height); return this; }, text: function (text, x, y, font, color, shadow) { if (x === undefined) { x = 0; } if (y === undefined) { y = 0; } if (font === undefined) { font = '14px Courier'; } if (color === undefined) { color = 'rgb(255,255,255)'; } if (shadow === undefined) { shadow = true; } var ctx = this.context; var prevFont = ctx.font; ctx.font = font; if (shadow) { ctx.fillStyle = 'rgb(0,0,0)'; ctx.fillText(text, x + 1, y + 1); } ctx.fillStyle = color; ctx.fillText(text, x, y); ctx.font = prevFont; return this; }, circle: function (x, y, radius, fillStyle) { var ctx = this.context; if (fillStyle !== undefined) { ctx.fillStyle = fillStyle; } ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2, false); ctx.closePath(); ctx.fill(); return this; }, line: function (x1, y1, x2, y2, color, width) { if (color === undefined) { color = '#fff'; } if (width === undefined) { width = 1; } var ctx = this.context; ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.lineWidth = width; ctx.strokeStyle = color; ctx.stroke(); ctx.closePath(); return this; }, textureLine: function (line, image, repeat) { if (repeat === undefined) { repeat = 'repeat-x'; } if (typeof image === 'string') { image = this.game.cache.getImage(image); if (!image) { return; } } var width = line.length; if (repeat === 'no-repeat' && width > image.width) { width = image.width; } var ctx = this.context; ctx.fillStyle = ctx.createPattern(image, repeat); this._circle = new Phaser.Circle(line.start.x, line.start.y, image.height); this._circle.circumferencePoint(line.angle - 1.5707963267948966, false, this._pos); ctx.save(); ctx.translate(this._pos.x, this._pos.y); ctx.rotate(line.angle); ctx.fillRect(0, 0, width, image.height); ctx.restore(); this.dirty = true; return this; }, render: function () { if (!this.disableTextureUpload && this.dirty) { this.baseTexture.dirty(); this.dirty = false; } return this; }, destroy: function () { this.frameData.destroy(); this.texture.destroy(true); PIXI.CanvasPool.remove(this); }, blendReset: function () { this.op = 'source-over'; return this; }, blendSourceOver: function () { this.op = 'source-over'; return this; }, blendSourceIn: function () { this.op = 'source-in'; return this; }, blendSourceOut: function () { this.op = 'source-out'; return this; }, blendSourceAtop: function () { this.op = 'source-atop'; return this; }, blendDestinationOver: function () { this.op = 'destination-over'; return this; }, blendDestinationIn: function () { this.op = 'destination-in'; return this; }, blendDestinationOut: function () { this.op = 'destination-out'; return this; }, blendDestinationAtop: function () { this.op = 'destination-atop'; return this; }, blendXor: function () { this.op = 'xor'; return this; }, blendAdd: function () { this.op = 'lighter'; return this; }, blendMultiply: function () { this.op = 'multiply'; return this; }, blendScreen: function () { this.op = 'screen'; return this; }, blendOverlay: function () { this.op = 'overlay'; return this; }, blendDarken: function () { this.op = 'darken'; return this; }, blendLighten: function () { this.op = 'lighten'; return this; }, blendColorDodge: function () { this.op = 'color-dodge'; return this; }, blendColorBurn: function () { this.op = 'color-burn'; return this; }, blendHardLight: function () { this.op = 'hard-light'; return this; }, blendSoftLight: function () { this.op = 'soft-light'; return this; }, blendDifference: function () { this.op = 'difference'; return this; }, blendExclusion: function () { this.op = 'exclusion'; return this; }, blendHue: function () { this.op = 'hue'; return this; }, blendSaturation: function () { this.op = 'saturation'; return this; }, blendColor: function () { this.op = 'color'; return this; }, blendLuminosity: function () { this.op = 'luminosity'; return this; } };Object.defineProperty(Phaser.BitmapData.prototype, "smoothed", { get: function () { Phaser.Canvas.getSmoothingEnabled(this.context); }, set: function (value) { Phaser.Canvas.setSmoothingEnabled(this.context, value); } }); Object.defineProperty(Phaser.BitmapData.prototype, "op", { get: function () { return this.context.globalCompositeOperation; }, set: function (value) { this.context.globalCompositeOperation = value; } }); Phaser.BitmapData.getTransform = function (translateX, translateY, scaleX, scaleY, skewX, skewY) { if (typeof translateX !== 'number') { translateX = 0; } if (typeof translateY !== 'number') { translateY = 0; } if (typeof scaleX !== 'number') { scaleX = 1; } if (typeof scaleY !== 'number') { scaleY = 1; } if (typeof skewX !== 'number') { skewX = 0; } if (typeof skewY !== 'number') { skewY = 0; } return { sx: scaleX, sy: scaleY, scaleX: scaleX, scaleY: scaleY, skewX: skewX, skewY: skewY, translateX: translateX, translateY: translateY, tx: translateX, ty: translateY }; }; Phaser.BitmapData.prototype.constructor = Phaser.BitmapData; PIXI.Graphics = function() { PIXI.DisplayObjectContainer.call(this); this.renderable = true; this.fillAlpha = 1; this.lineWidth = 0; this.lineColor = 0; this.graphicsData = []; this.tint = 0xFFFFFF; this.blendMode = PIXI.blendModes.NORMAL; this.currentPath = null; this._webGL = []; this.isMask = false; this.boundsPadding = 0; this._localBounds = new PIXI.Rectangle(0,0,1,1); this.dirty = true; this._boundsDirty = false; this.webGLDirty = false; this.cachedSpriteDirty = false; }; PIXI.Graphics.prototype = Object.create( PIXI.DisplayObjectContainer.prototype ); PIXI.Graphics.prototype.constructor = PIXI.Graphics; PIXI.Graphics.prototype.lineStyle = function(lineWidth, color, alpha) { this.lineWidth = lineWidth || 0; this.lineColor = color || 0; this.lineAlpha = (alpha === undefined) ? 1 : alpha; if (this.currentPath) { if (this.currentPath.shape.points.length) { this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))); } else { this.currentPath.lineWidth = this.lineWidth; this.currentPath.lineColor = this.lineColor; this.currentPath.lineAlpha = this.lineAlpha; } } return this; }; PIXI.Graphics.prototype.moveTo = function(x, y) { this.drawShape(new PIXI.Polygon([x, y])); return this; }; PIXI.Graphics.prototype.lineTo = function(x, y) { if (!this.currentPath) { this.moveTo(0, 0); } this.currentPath.shape.points.push(x, y); this.dirty = true; this._boundsDirty = true; return this; }; PIXI.Graphics.prototype.quadraticCurveTo = function(cpX, cpY, toX, toY) { if (this.currentPath) { if (this.currentPath.shape.points.length === 0) { this.currentPath.shape.points = [0, 0]; } } else { this.moveTo(0,0); } var xa, ya, n = 20, points = this.currentPath.shape.points; if (points.length === 0) { this.moveTo(0, 0); } var fromX = points[points.length - 2]; var fromY = points[points.length - 1]; var j = 0; for (var i = 1; i <= n; ++i) { j = i / n; xa = fromX + ( (cpX - fromX) * j ); ya = fromY + ( (cpY - fromY) * j ); points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ), ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) ); } this.dirty = true; this._boundsDirty = true; return this; }; PIXI.Graphics.prototype.bezierCurveTo = function(cpX, cpY, cpX2, cpY2, toX, toY) { if (this.currentPath) { if (this.currentPath.shape.points.length === 0) { this.currentPath.shape.points = [0, 0]; } } else { this.moveTo(0,0); } var n = 20, dt, dt2, dt3, t2, t3, points = this.currentPath.shape.points; var fromX = points[points.length-2]; var fromY = points[points.length-1]; var j = 0; for (var i = 1; i <= n; ++i) { j = i / n; dt = (1 - j); dt2 = dt * dt; dt3 = dt2 * dt; t2 = j * j; t3 = t2 * j; points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY); } this.dirty = true; this._boundsDirty = true; return this; }; PIXI.Graphics.prototype.arcTo = function(x1, y1, x2, y2, radius) { if (this.currentPath) { if (this.currentPath.shape.points.length === 0) { this.currentPath.shape.points.push(x1, y1); } } else { this.moveTo(x1, y1); } var points = this.currentPath.shape.points, fromX = points[points.length-2], fromY = points[points.length-1], a1 = fromY - y1, b1 = fromX - x1, a2 = y2   - y1, b2 = x2   - x1, mm = Math.abs(a1 * b2 - b1 * a2); if (mm < 1.0e-8 || radius === 0) { if (points[points.length-2] !== x1 || points[points.length-1] !== y1) { points.push(x1, y1); } } else { var dd = a1 * a1 + b1 * b1, cc = a2 * a2 + b2 * b2, tt = a1 * a2 + b1 * b2, k1 = radius * Math.sqrt(dd) / mm, k2 = radius * Math.sqrt(cc) / mm, j1 = k1 * tt / dd, j2 = k2 * tt / cc, cx = k1 * b2 + k2 * b1, cy = k1 * a2 + k2 * a1, px = b1 * (k2 + j1), py = a1 * (k2 + j1), qx = b2 * (k1 + j2), qy = a2 * (k1 + j2), startAngle = Math.atan2(py - cy, px - cx), endAngle   = Math.atan2(qy - cy, qx - cx); this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1); } this.dirty = true; this._boundsDirty = true; return this; }; PIXI.Graphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise, segments) { if (startAngle === endAngle) { return this; } if (anticlockwise === undefined) { anticlockwise = false; } if (segments === undefined) { segments = 40; } if (!anticlockwise && endAngle <= startAngle) { endAngle += Math.PI * 2; } else if (anticlockwise && startAngle <= endAngle) { startAngle += Math.PI * 2; } var sweep = anticlockwise ? (startAngle - endAngle) * -1 : (endAngle - startAngle); var segs =  Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * segments; if (sweep === 0) { return this; } var startX = cx + Math.cos(startAngle) * radius; var startY = cy + Math.sin(startAngle) * radius; if (anticlockwise && this.filling) { this.moveTo(cx, cy); } else { this.moveTo(startX, startY); } var points = this.currentPath.shape.points; var theta = sweep / (segs * 2); var theta2 = theta * 2; var cTheta = Math.cos(theta); var sTheta = Math.sin(theta); var segMinus = segs - 1; var remainder = (segMinus % 1) / segMinus; for (var i = 0; i <= segMinus; i++) { var real =  i + remainder * i; var angle = ((theta) + startAngle + (theta2 * real)); var c = Math.cos(angle); var s = -Math.sin(angle); points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx, ( (cTheta * -s) + (sTheta * c) ) * radius + cy); } this.dirty = true; this._boundsDirty = true; return this; }; PIXI.Graphics.prototype.beginFill = function(color, alpha) { this.filling = true; this.fillColor = color || 0; this.fillAlpha = (alpha === undefined) ? 1 : alpha; if (this.currentPath) { if (this.currentPath.shape.points.length <= 2) { this.currentPath.fill = this.filling; this.currentPath.fillColor = this.fillColor; this.currentPath.fillAlpha = this.fillAlpha; } } return this; }; PIXI.Graphics.prototype.endFill = function() { this.filling = false; this.fillColor = null; this.fillAlpha = 1; return this; }; PIXI.Graphics.prototype.drawRect = function(x, y, width, height) { this.drawShape(new PIXI.Rectangle(x, y, width, height)); return this; }; PIXI.Graphics.prototype.drawRoundedRect = function(x, y, width, height, radius) { this.drawShape(new PIXI.RoundedRectangle(x, y, width, height, radius)); return this; }; PIXI.Graphics.prototype.drawCircle = function(x, y, diameter) { this.drawShape(new PIXI.Circle(x, y, diameter)); return this; }; PIXI.Graphics.prototype.drawEllipse = function(x, y, width, height) { this.drawShape(new PIXI.Ellipse(x, y, width, height)); return this; }; PIXI.Graphics.prototype.drawPolygon = function(path) { if (path instanceof Phaser.Polygon || path instanceof PIXI.Polygon) { path = path.points; } var points = path; if (!Array.isArray(points)) { points = new Array(arguments.length); for (var i = 0; i < points.length; ++i) { points[i] = arguments[i]; } } this.drawShape(new Phaser.Polygon(points)); return this; }; PIXI.Graphics.prototype.clear = function() { this.lineWidth = 0; this.filling = false; this.dirty = true; this._boundsDirty = true; this.clearDirty = true; this.graphicsData = []; this.updateLocalBounds(); return this; }; PIXI.Graphics.prototype.generateTexture = function(resolution, scaleMode, padding) { if (resolution === undefined) { resolution = 1; } if (scaleMode === undefined) { scaleMode = PIXI.scaleModes.DEFAULT; } if (padding === undefined) { padding = 0; } var bounds = this.getBounds(); bounds.width += padding; bounds.height += padding; var canvasBuffer = new PIXI.CanvasBuffer(bounds.width * resolution, bounds.height * resolution); var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas, scaleMode); texture.baseTexture.resolution = resolution; canvasBuffer.context.scale(resolution, resolution); canvasBuffer.context.translate(-bounds.x, -bounds.y); PIXI.CanvasGraphics.renderGraphics(this, canvasBuffer.context); return texture; }; PIXI.Graphics.prototype._renderWebGL = function(renderSession) { if (this.visible === false || this.alpha === 0 || this.isMask === true) return; if (this._cacheAsBitmap) { if (this.dirty || this.cachedSpriteDirty) { this._generateCachedSprite(); this.updateCachedSpriteTexture(); this.cachedSpriteDirty = false; this.dirty = false; } this._cachedSprite.worldAlpha = this.worldAlpha; PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession); return; } else { renderSession.spriteBatch.stop(); renderSession.blendModeManager.setBlendMode(this.blendMode); if (this._mask) renderSession.maskManager.pushMask(this._mask, renderSession); if (this._filters) renderSession.filterManager.pushFilter(this._filterBlock); if (this.blendMode !== renderSession.spriteBatch.currentBlendMode) { renderSession.spriteBatch.currentBlendMode = this.blendMode; var blendModeWebGL = PIXI.blendModesWebGL[renderSession.spriteBatch.currentBlendMode]; renderSession.spriteBatch.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]); } if (this.webGLDirty) { this.dirty = true; this.webGLDirty = false; } PIXI.WebGLGraphics.renderGraphics(this, renderSession); if (this.children.length) { renderSession.spriteBatch.start(); for (var i = 0; i < this.children.length; i++) { this.children[i]._renderWebGL(renderSession); } renderSession.spriteBatch.stop(); } if (this._filters) renderSession.filterManager.popFilter(); if (this._mask) renderSession.maskManager.popMask(this.mask, renderSession); renderSession.drawCount++; renderSession.spriteBatch.start(); } }; PIXI.Graphics.prototype._renderCanvas = function(renderSession) { if (this.visible === false || this.alpha === 0 || this.isMask === true) return; if (this._prevTint !== this.tint) { this.dirty = true; this._prevTint = this.tint; } if (this._cacheAsBitmap) { if (this.dirty || this.cachedSpriteDirty) { this._generateCachedSprite(); this.updateCachedSpriteTexture(); this.cachedSpriteDirty = false; this.dirty = false; } this._cachedSprite.alpha = this.alpha; PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession); return; } else { var context = renderSession.context; var transform = this.worldTransform; if (this.blendMode !== renderSession.currentBlendMode) { renderSession.currentBlendMode = this.blendMode; context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode]; } if (this._mask) { renderSession.maskManager.pushMask(this._mask, renderSession); } var resolution = renderSession.resolution; var tx = (transform.tx * renderSession.resolution) + renderSession.shakeX; var ty = (transform.ty * renderSession.resolution) + renderSession.shakeY; context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, tx, ty); PIXI.CanvasGraphics.renderGraphics(this, context); for (var i = 0; i < this.children.length; i++) { this.children[i]._renderCanvas(renderSession); } if (this._mask) { renderSession.maskManager.popMask(renderSession); } } }; PIXI.Graphics.prototype.getBounds = function(matrix) { if (!this._currentBounds) { if (!this.renderable) { return PIXI.EmptyRectangle; } if (this.dirty) { this.updateLocalBounds(); this.webGLDirty = true; this.cachedSpriteDirty = true; this.dirty = false; } var bounds = this._localBounds; var w0 = bounds.x; var w1 = bounds.width + bounds.x; var h0 = bounds.y; var h1 = bounds.height + bounds.y; var worldTransform = matrix || this.worldTransform; var a = worldTransform.a; var b = worldTransform.b; var c = worldTransform.c; var d = worldTransform.d; var tx = worldTransform.tx; var ty = worldTransform.ty; var x1 = a * w1 + c * h1 + tx; var y1 = d * h1 + b * w1 + ty; var x2 = a * w0 + c * h1 + tx; var y2 = d * h1 + b * w0 + ty; var x3 = a * w0 + c * h0 + tx; var y3 = d * h0 + b * w0 + ty; var x4 =  a * w1 + c * h0 + tx; var y4 =  d * h0 + b * w1 + ty; var maxX = x1; var maxY = y1; var minX = x1; var minY = y1; minX = x2 < minX ? x2 : minX; minX = x3 < minX ? x3 : minX; minX = x4 < minX ? x4 : minX; minY = y2 < minY ? y2 : minY; minY = y3 < minY ? y3 : minY; minY = y4 < minY ? y4 : minY; maxX = x2 > maxX ? x2 : maxX; maxX = x3 > maxX ? x3 : maxX; maxX = x4 > maxX ? x4 : maxX; maxY = y2 > maxY ? y2 : maxY; maxY = y3 > maxY ? y3 : maxY; maxY = y4 > maxY ? y4 : maxY; this._bounds.x = minX; this._bounds.width = maxX - minX; this._bounds.y = minY; this._bounds.height = maxY - minY; this._currentBounds = this._bounds; } return this._currentBounds; }; PIXI.Graphics.prototype.getLocalBounds = function () { var matrixCache = this.worldTransform; this.worldTransform = PIXI.identityMatrix; for (var i = 0; i < this.children.length; i++) { this.children[i].updateTransform(); } var bounds = this.getBounds(); this.worldTransform = matrixCache; for (i = 0; i < this.children.length; i++) { this.children[i].updateTransform(); } return bounds; }; PIXI.Graphics.prototype.containsPoint = function( point ) { this.worldTransform.applyInverse(point,  tempPoint); var graphicsData = this.graphicsData; for (var i = 0; i < graphicsData.length; i++) { var data = graphicsData[i]; if (!data.fill) { continue; } if (data.shape) { if (data.shape.contains(tempPoint.x, tempPoint.y)) { return true; } } } return false; }; PIXI.Graphics.prototype.updateLocalBounds = function() { var minX = Infinity; var maxX = -Infinity; var minY = Infinity; var maxY = -Infinity; if (this.graphicsData.length) { var shape, points, x, y, w, h; for (var i = 0; i < this.graphicsData.length; i++) { var data = this.graphicsData[i]; var type = data.type; var lineWidth = data.lineWidth; shape = data.shape; if (type === PIXI.Graphics.RECT || type === PIXI.Graphics.RREC) { x = shape.x - lineWidth / 2; y = shape.y - lineWidth / 2; w = shape.width + lineWidth; h = shape.height + lineWidth; minX = x < minX ? x : minX; maxX = x + w > maxX ? x + w : maxX; minY = y < minY ? y : minY; maxY = y + h > maxY ? y + h : maxY; } else if (type === PIXI.Graphics.CIRC) { x = shape.x; y = shape.y; w = shape.radius + lineWidth / 2; h = shape.radius + lineWidth / 2; minX = x - w < minX ? x - w : minX; maxX = x + w > maxX ? x + w : maxX; minY = y - h < minY ? y - h : minY; maxY = y + h > maxY ? y + h : maxY; } else if (type === PIXI.Graphics.ELIP) { x = shape.x; y = shape.y; w = shape.width + lineWidth / 2; h = shape.height + lineWidth / 2; minX = x - w < minX ? x - w : minX; maxX = x + w > maxX ? x + w : maxX; minY = y - h < minY ? y - h : minY; maxY = y + h > maxY ? y + h : maxY; } else { points = shape.points; for (var j = 0; j < points.length; j++) { if (points[j] instanceof Phaser.Point) { x = points[j].x; y = points[j].y; } else { x = points[j]; y = points[j + 1]; if (j < points.length - 1) { j++; } } minX = x - lineWidth < minX ? x - lineWidth : minX; maxX = x + lineWidth > maxX ? x + lineWidth : maxX; minY = y - lineWidth < minY ? y - lineWidth : minY; maxY = y + lineWidth > maxY ? y + lineWidth : maxY; } } } } else { minX = 0; maxX = 0; minY = 0; maxY = 0; } var padding = this.boundsPadding; this._localBounds.x = minX - padding; this._localBounds.width = (maxX - minX) + padding * 2; this._localBounds.y = minY - padding; this._localBounds.height = (maxY - minY) + padding * 2; }; PIXI.Graphics.prototype._generateCachedSprite = function() { var bounds = this.getLocalBounds(); if (!this._cachedSprite) { var canvasBuffer = new PIXI.CanvasBuffer(bounds.width, bounds.height); var texture = PIXI.Texture.fromCanvas(canvasBuffer.canvas); this._cachedSprite = new PIXI.Sprite(texture); this._cachedSprite.buffer = canvasBuffer; this._cachedSprite.worldTransform = this.worldTransform; } else { this._cachedSprite.buffer.resize(bounds.width, bounds.height); } this._cachedSprite.anchor.x = -(bounds.x / bounds.width); this._cachedSprite.anchor.y = -(bounds.y / bounds.height); this._cachedSprite.buffer.context.translate(-bounds.x, -bounds.y); this.worldAlpha = 1; PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context); this._cachedSprite.alpha = this.alpha; }; PIXI.Graphics.prototype.updateCachedSpriteTexture = function() { var cachedSprite = this._cachedSprite; var texture = cachedSprite.texture; var canvas = cachedSprite.buffer.canvas; texture.baseTexture.width = canvas.width; texture.baseTexture.height = canvas.height; texture.crop.width = texture.frame.width = canvas.width; texture.crop.height = texture.frame.height = canvas.height; cachedSprite._width = canvas.width; cachedSprite._height = canvas.height; texture.baseTexture.dirty(); }; PIXI.Graphics.prototype.destroyCachedSprite = function() { this._cachedSprite.texture.destroy(true); this._cachedSprite = null; }; PIXI.Graphics.prototype.drawShape = function(shape) { if (this.currentPath) { if (this.currentPath.shape.points.length <= 2) { this.graphicsData.pop(); } } this.currentPath = null; if (shape instanceof Phaser.Polygon) { shape = shape.clone(); shape.flatten(); } var data = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape); this.graphicsData.push(data); if (data.type === PIXI.Graphics.POLY) { data.shape.closed = this.filling; this.currentPath = data; } this.dirty = true; this._boundsDirty = true; return data; }; Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", { get: function() { return  this._cacheAsBitmap; }, set: function(value) { this._cacheAsBitmap = value; if (this._cacheAsBitmap) { this._generateCachedSprite(); } else { this.destroyCachedSprite(); } this.dirty = true; this.webGLDirty = true; } }); PIXI.GraphicsData = function(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape) { this.lineWidth = lineWidth; this.lineColor = lineColor; this.lineAlpha = lineAlpha; this._lineTint = lineColor; this.fillColor = fillColor; this.fillAlpha = fillAlpha; this._fillTint = fillColor; this.fill = fill; this.shape = shape; this.type = shape.type; }; PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData; PIXI.GraphicsData.prototype.clone = function() { return new GraphicsData( this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape ); }; PIXI.EarCut = {}; PIXI.EarCut.Triangulate = function (data, holeIndices, dim) { dim = dim || 2; var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = PIXI.EarCut.linkedList(data, 0, outerLen, dim, true), triangles = []; if (!outerNode) return triangles; var minX, minY, maxX, maxY, x, y, size; if (hasHoles) outerNode = PIXI.EarCut.eliminateHoles(data, holeIndices, outerNode, dim); if (data.length > 80 * dim) { minX = maxX = data[0]; minY = maxY = data[1]; for (var i = dim; i < outerLen; i += dim) { x = data[i]; y = data[i + 1]; if (x < minX) minX = x; if (y < minY) minY = y; if (x > maxX) maxX = x; if (y > maxY) maxY = y; } size = Math.max(maxX - minX, maxY - minY); } PIXI.EarCut.earcutLinked(outerNode, triangles, dim, minX, minY, size); return triangles; }; PIXI.EarCut.linkedList = function (data, start, end, dim, clockwise) { var sum = 0, i, j, last; for (i = start, j = end - dim; i < end; i += dim) { sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]); j = i; } if (clockwise === (sum > 0)) { for (i = start; i < end; i += dim) last = PIXI.EarCut.insertNode(i, data[i], data[i + 1], last); } else { for (i = end - dim; i >= start; i -= dim) last = PIXI.EarCut.insertNode(i, data[i], data[i + 1], last); } return last; }; PIXI.EarCut.filterPoints = function (start, end) { if (!start) return start; if (!end) end = start; var p = start, again; do { again = false; if (!p.steiner && (PIXI.EarCut.equals(p, p.next) || PIXI.EarCut.area(p.prev, p, p.next) === 0)) { PIXI.EarCut.removeNode(p); p = end = p.prev; if (p === p.next) return null; again = true; } else { p = p.next; } } while (again || p !== end); return end; }; PIXI.EarCut.earcutLinked = function (ear, triangles, dim, minX, minY, size, pass) { if (!ear) return; if (!pass && size) PIXI.EarCut.indexCurve(ear, minX, minY, size); var stop = ear, prev, next; while (ear.prev !== ear.next) { prev = ear.prev; next = ear.next; if (size ? PIXI.EarCut.isEarHashed(ear, minX, minY, size) : PIXI.EarCut.isEar(ear)) { triangles.push(prev.i / dim); triangles.push(ear.i / dim); triangles.push(next.i / dim); PIXI.EarCut.removeNode(ear); ear = next.next; stop = next.next; continue; } ear = next; if (ear === stop) { if (!pass) { PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(ear), triangles, dim, minX, minY, size, 1); } else if (pass === 1) { ear = PIXI.EarCut.cureLocalIntersections(ear, triangles, dim); PIXI.EarCut.earcutLinked(ear, triangles, dim, minX, minY, size, 2); } else if (pass === 2) { PIXI.EarCut.splitEarcut(ear, triangles, dim, minX, minY, size); } break; } } }; PIXI.EarCut.isEar = function (ear) { var a = ear.prev, b = ear, c = ear.next; if (PIXI.EarCut.area(a, b, c) >= 0) return false; var p = ear.next.next; while (p !== ear.prev) { if (PIXI.EarCut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && PIXI.EarCut.area(p.prev, p, p.next) >= 0) return false; p = p.next; } return true; }; PIXI.EarCut.isEarHashed = function (ear, minX, minY, size) { var a = ear.prev, b = ear, c = ear.next; if (PIXI.EarCut.area(a, b, c) >= 0) return false; var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y); var minZ = PIXI.EarCut.zOrder(minTX, minTY, minX, minY, size), maxZ = PIXI.EarCut.zOrder(maxTX, maxTY, minX, minY, size); var p = ear.nextZ; while (p && p.z <= maxZ) { if (p !== ear.prev && p !== ear.next && PIXI.EarCut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && PIXI.EarCut.area(p.prev, p, p.next) >= 0) return false; p = p.nextZ; } p = ear.prevZ; while (p && p.z >= minZ) { if (p !== ear.prev && p !== ear.next && PIXI.EarCut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && PIXI.EarCut.area(p.prev, p, p.next) >= 0) return false; p = p.prevZ; } return true; }; PIXI.EarCut.cureLocalIntersections = function (start, triangles, dim) { var p = start; do { var a = p.prev, b = p.next.next; if (PIXI.EarCut.intersects(a, p, p.next, b) && PIXI.EarCut.locallyInside(a, b) && PIXI.EarCut.locallyInside(b, a)) { triangles.push(a.i / dim); triangles.push(p.i / dim); triangles.push(b.i / dim); PIXI.EarCut.removeNode(p); PIXI.EarCut.removeNode(p.next); p = start = b; } p = p.next; } while (p !== start); return p; }; PIXI.EarCut.splitEarcut = function (start, triangles, dim, minX, minY, size) { var a = start; do { var b = a.next.next; while (b !== a.prev) { if (a.i !== b.i && PIXI.EarCut.isValidDiagonal(a, b)) { var c = PIXI.EarCut.splitPolygon(a, b); a = PIXI.EarCut.filterPoints(a, a.next); c = PIXI.EarCut.filterPoints(c, c.next); PIXI.EarCut.earcutLinked(a, triangles, dim, minX, minY, size); PIXI.EarCut.earcutLinked(c, triangles, dim, minX, minY, size); return; } b = b.next; } a = a.next; } while (a !== start); }; PIXI.EarCut.eliminateHoles = function (data, holeIndices, outerNode, dim) { var queue = [], i, len, start, end, list; for (i = 0, len = holeIndices.length; i < len; i++) { start = holeIndices[i] * dim; end = i < len - 1 ? holeIndices[i + 1] * dim : data.length; list = PIXI.EarCut.linkedList(data, start, end, dim, false); if (list === list.next) list.steiner = true; queue.push(PIXI.EarCut.getLeftmost(list)); } queue.sort(compareX); for (i = 0; i < queue.length; i++) { PIXI.EarCut.eliminateHole(queue[i], outerNode); outerNode = PIXI.EarCut.filterPoints(outerNode, outerNode.next); } return outerNode; }; PIXI.EarCut.compareX = function (a, b) { return a.x - b.x; }; PIXI.EarCut.eliminateHole = function (hole, outerNode) { outerNode = PIXI.EarCut.findHoleBridge(hole, outerNode); if (outerNode) { var b = PIXI.EarCut.splitPolygon(outerNode, hole); PIXI.EarCut.filterPoints(b, b.next); } }; PIXI.EarCut.findHoleBridge = function (hole, outerNode) { var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m; do { if (hy <= p.y && hy >= p.next.y) { var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y); if (x <= hx && x > qx) { qx = x; m = p.x < p.next.x ? p : p.next; } } p = p.next; } while (p !== outerNode); if (!m) return null; if (hole.x === m.x) return m.prev; var stop = m, tanMin = Infinity, tan; p = m.next; while (p !== stop) { if (hx >= p.x && p.x >= m.x && PIXI.EarCut.pointInTriangle(hy < m.y ? hx : qx, hy, m.x, m.y, hy < m.y ? qx : hx, hy, p.x, p.y)) { tan = Math.abs(hy - p.y) / (hx - p.x); if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && PIXI.EarCut.locallyInside(p, hole)) { m = p; tanMin = tan; } } p = p.next; } return m; }; PIXI.EarCut.indexCurve = function (start, minX, minY, size) { var p = start; do { if (p.z === null) p.z = PIXI.EarCut.zOrder(p.x, p.y, minX, minY, size); p.prevZ = p.prev; p.nextZ = p.next; p = p.next; } while (p !== start); p.prevZ.nextZ = null; p.prevZ = null; PIXI.EarCut.sortLinked(p); }; PIXI.EarCut.sortLinked = function (list) { var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1; do { p = list; list = null; tail = null; numMerges = 0; while (p) { numMerges++; q = p; pSize = 0; for (i = 0; i < inSize; i++) { pSize++; q = q.nextZ; if (!q) break; } qSize = inSize; while (pSize > 0 || (qSize > 0 && q)) { if (pSize === 0) { e = q; q = q.nextZ; qSize--; } else if (qSize === 0 || !q) { e = p; p = p.nextZ; pSize--; } else if (p.z <= q.z) { e = p; p = p.nextZ; pSize--; } else { e = q; q = q.nextZ; qSize--; } if (tail) tail.nextZ = e; else list = e; e.prevZ = tail; tail = e; } p = q; } tail.nextZ = null; inSize *= 2; } while (numMerges > 1); return list; }; PIXI.EarCut.zOrder = function (x, y, minX, minY, size) { x = 32767 * (x - minX) / size; y = 32767 * (y - minY) / size; x = (x | (x << 8)) & 0x00FF00FF; x = (x | (x << 4)) & 0x0F0F0F0F; x = (x | (x << 2)) & 0x33333333; x = (x | (x << 1)) & 0x55555555; y = (y | (y << 8)) & 0x00FF00FF; y = (y | (y << 4)) & 0x0F0F0F0F; y = (y | (y << 2)) & 0x33333333; y = (y | (y << 1)) & 0x55555555; return x | (y << 1); }; PIXI.EarCut.getLeftmost = function (start) { var p = start, leftmost = start; do { if (p.x < leftmost.x) leftmost = p; p = p.next; } while (p !== start); return leftmost; }; PIXI.EarCut.pointInTriangle = function (ax, ay, bx, by, cx, cy, px, py) { return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0; }; PIXI.EarCut.isValidDiagonal = function (a, b) { return PIXI.EarCut.equals(a, b) || a.next.i !== b.i && a.prev.i !== b.i && !PIXI.EarCut.intersectsPolygon(a, b) && PIXI.EarCut.locallyInside(a, b) && PIXI.EarCut.locallyInside(b, a) && PIXI.EarCut.middleInside(a, b); }; PIXI.EarCut.area = function (p, q, r) { return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); };PIXI.EarCut.equals = function (p1, p2) { return p1.x === p2.x && p1.y === p2.y; }; PIXI.EarCut.intersects = function (p1, q1, p2, q2) { return PIXI.EarCut.area(p1, q1, p2) > 0 !== PIXI.EarCut.area(p1, q1, q2) > 0 && PIXI.EarCut.area(p2, q2, p1) > 0 !== PIXI.EarCut.area(p2, q2, q1) > 0; }; PIXI.EarCut.intersectsPolygon = function (a, b) { var p = a; do { if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && PIXI.EarCut.intersects(p, p.next, a, b)) return true; p = p.next; } while (p !== a); return false; }; PIXI.EarCut.locallyInside = function (a, b) { return PIXI.EarCut.area(a.prev, a, a.next) < 0 ? PIXI.EarCut.area(a, b, a.next) >= 0 && PIXI.EarCut.area(a, a.prev, b) >= 0 : PIXI.EarCut.area(a, b, a.prev) < 0 || PIXI.EarCut.area(a, a.next, b) < 0; }; PIXI.EarCut.middleInside = function (a, b) { var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2; do { if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) inside = !inside; p = p.next; } while (p !== a); return inside; }; PIXI.EarCut.splitPolygon = function (a, b) { var a2 = new PIXI.EarCut.Node(a.i, a.x, a.y), b2 = new PIXI.EarCut.Node(b.i, b.x, b.y), an = a.next, bp = b.prev; a.next = b; b.prev = a; a2.next = an; an.prev = a2; b2.next = a2; a2.prev = b2; bp.next = b2; b2.prev = bp; return b2; }; PIXI.EarCut.insertNode = function (i, x, y, last) { var p = new PIXI.EarCut.Node(i, x, y); if (!last) { p.prev = p; p.next = p; } else { p.next = last.next; p.prev = last; last.next.prev = p; last.next = p; } return p; }; PIXI.EarCut.removeNode = function (p) { p.next.prev = p.prev; p.prev.next = p.next; if (p.prevZ) p.prevZ.nextZ = p.nextZ; if (p.nextZ) p.nextZ.prevZ = p.prevZ; }; PIXI.EarCut.Node = function (i, x, y) { this.i = i; this.x = x; this.y = y; this.prev = null; this.next = null; this.z = null; this.prevZ = null; this.nextZ = null; this.steiner = false; }; PIXI.WebGLGraphics = function() { }; PIXI.WebGLGraphics.stencilBufferLimit = 6; PIXI.WebGLGraphics.renderGraphics = function(graphics, renderSession) { var gl = renderSession.gl; var projection = renderSession.projection, offset = renderSession.offset, shader = renderSession.shaderManager.primitiveShader, webGLData; if(graphics.dirty) { PIXI.WebGLGraphics.updateGraphics(graphics, gl); } var webGL = graphics._webGL[gl.id]; for (var i = 0; i < webGL.data.length; i++) { if(webGL.data[i].mode === 1) { webGLData = webGL.data[i]; renderSession.stencilManager.pushStencil(graphics, webGLData, renderSession); gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, ( webGLData.indices.length - 4 ) * 2 ); renderSession.stencilManager.popStencil(graphics, webGLData, renderSession); } else { webGLData = webGL.data[i]; renderSession.shaderManager.setShader( shader ); shader = renderSession.shaderManager.primitiveShader; gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true)); gl.uniform1f(shader.flipY, 1); gl.uniform2f(shader.projectionVector, projection.x, -projection.y); gl.uniform2f(shader.offsetVector, -offset.x, -offset.y); gl.uniform3fv(shader.tintColor, PIXI.hex2rgb(graphics.tint)); gl.uniform1f(shader.alpha, graphics.worldAlpha); gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer); gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0); gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer); gl.drawElements(gl.TRIANGLE_STRIP,  webGLData.indices.length, gl.UNSIGNED_SHORT, 0 ); } } }; PIXI.WebGLGraphics.updateGraphics = function(graphics, gl) { var webGL = graphics._webGL[gl.id]; if(!webGL)webGL = graphics._webGL[gl.id] = {lastIndex:0, data:[], gl:gl}; graphics.dirty = false; var i; if(graphics.clearDirty) { graphics.clearDirty = false; for (i = 0; i < webGL.data.length; i++) { var graphicsData = webGL.data[i]; graphicsData.reset(); PIXI.WebGLGraphics.graphicsDataPool.push( graphicsData ); } webGL.data = []; webGL.lastIndex = 0; } var webGLData; for (i = webGL.lastIndex; i < graphics.graphicsData.length; i++) { var data = graphics.graphicsData[i]; if(data.type === PIXI.Graphics.POLY) { data.points = data.shape.points.slice(); if(data.shape.closed) { if(data.points[0] !== data.points[data.points.length-2] || data.points[1] !== data.points[data.points.length-1]) { data.points.push(data.points[0], data.points[1]); } } if(data.fill) { if(data.points.length >= PIXI.WebGLGraphics.stencilBufferLimit) { if(data.points.length < PIXI.WebGLGraphics.stencilBufferLimit * 2) { webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0); var canDrawUsingSimple = PIXI.WebGLGraphics.buildPoly(data, webGLData); if(!canDrawUsingSimple) { webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1); PIXI.WebGLGraphics.buildComplexPoly(data, webGLData); } } else { webGLData = PIXI.WebGLGraphics.switchMode(webGL, 1); PIXI.WebGLGraphics.buildComplexPoly(data, webGLData); } } } if(data.lineWidth > 0) { webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0); PIXI.WebGLGraphics.buildLine(data, webGLData); } } else { webGLData = PIXI.WebGLGraphics.switchMode(webGL, 0); if(data.type === PIXI.Graphics.RECT) { PIXI.WebGLGraphics.buildRectangle(data, webGLData); } else if(data.type === PIXI.Graphics.CIRC || data.type === PIXI.Graphics.ELIP) { PIXI.WebGLGraphics.buildCircle(data, webGLData); } else if(data.type === PIXI.Graphics.RREC) { PIXI.WebGLGraphics.buildRoundedRectangle(data, webGLData); } } webGL.lastIndex++; } for (i = 0; i < webGL.data.length; i++) { webGLData = webGL.data[i]; if(webGLData.dirty)webGLData.upload(); } }; PIXI.WebGLGraphics.switchMode = function(webGL, type) { var webGLData; if(!webGL.data.length) { webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl); webGLData.mode = type; webGL.data.push(webGLData); } else { webGLData = webGL.data[webGL.data.length-1]; if(webGLData.mode !== type || type === 1) { webGLData = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(webGL.gl); webGLData.mode = type; webGL.data.push(webGLData); } } webGLData.dirty = true; return webGLData; }; PIXI.WebGLGraphics.buildRectangle = function(graphicsData, webGLData) { var rectData = graphicsData.shape; var x = rectData.x; var y = rectData.y; var width = rectData.width; var height = rectData.height; if(graphicsData.fill) { var color = PIXI.hex2rgb(graphicsData.fillColor); var alpha = graphicsData.fillAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; var verts = webGLData.points; var indices = webGLData.indices; var vertPos = verts.length / 6; verts.push(x, y); verts.push(r, g, b, alpha); verts.push(x + width, y); verts.push(r, g, b, alpha); verts.push(x , y + height); verts.push(r, g, b, alpha); verts.push(x + width, y + height); verts.push(r, g, b, alpha); indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3); } if (graphicsData.lineWidth) { var tempPoints = graphicsData.points; graphicsData.points = [x, y, x + width, y, x + width, y + height, x, y + height, x, y]; PIXI.WebGLGraphics.buildLine(graphicsData, webGLData); graphicsData.points = tempPoints; } }; PIXI.WebGLGraphics.buildRoundedRectangle = function(graphicsData, webGLData) { var rrectData = graphicsData.shape; var x = rrectData.x; var y = rrectData.y; var width = rrectData.width; var height = rrectData.height; var radius = rrectData.radius; var recPoints = []; recPoints.push(x, y + radius); recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height)); recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius)); recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y)); recPoints = recPoints.concat(PIXI.WebGLGraphics.quadraticBezierCurve(x + radius, y, x, y, x, y + radius)); if (graphicsData.fill) { var color = PIXI.hex2rgb(graphicsData.fillColor); var alpha = graphicsData.fillAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; var verts = webGLData.points; var indices = webGLData.indices; var vecPos = verts.length / 6; var triangles = PIXI.EarCut.Triangulate(recPoints, null, 2); var i = 0; for (i = 0; i < triangles.length; i+=3) { indices.push(triangles[i] + vecPos); indices.push(triangles[i] + vecPos); indices.push(triangles[i+1] + vecPos); indices.push(triangles[i+2] + vecPos); indices.push(triangles[i+2] + vecPos); } for (i = 0; i < recPoints.length; i++) { verts.push(recPoints[i], recPoints[++i], r, g, b, alpha); } } if (graphicsData.lineWidth) { var tempPoints = graphicsData.points; graphicsData.points = recPoints; PIXI.WebGLGraphics.buildLine(graphicsData, webGLData); graphicsData.points = tempPoints; } }; PIXI.WebGLGraphics.quadraticBezierCurve = function(fromX, fromY, cpX, cpY, toX, toY) { var xa, ya, xb, yb, x, y, n = 20, points = []; function getPt(n1 , n2, perc) { var diff = n2 - n1; return n1 + ( diff * perc ); } var j = 0; for (var i = 0; i <= n; i++ ) { j = i / n; xa = getPt( fromX , cpX , j ); ya = getPt( fromY , cpY , j ); xb = getPt( cpX , toX , j ); yb = getPt( cpY , toY , j ); x = getPt( xa , xb , j ); y = getPt( ya , yb , j ); points.push(x, y); } return points; }; PIXI.WebGLGraphics.buildCircle = function(graphicsData, webGLData) { var circleData = graphicsData.shape; var x = circleData.x; var y = circleData.y; var width; var height; if(graphicsData.type === PIXI.Graphics.CIRC) { width = circleData.radius; height = circleData.radius; } else { width = circleData.width; height = circleData.height; } var totalSegs = 40; var seg = (Math.PI * 2) / totalSegs ; var i = 0; if(graphicsData.fill) { var color = PIXI.hex2rgb(graphicsData.fillColor); var alpha = graphicsData.fillAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; var verts = webGLData.points; var indices = webGLData.indices; var vecPos = verts.length / 6; indices.push(vecPos); for (i = 0; i < totalSegs + 1 ; i++) { verts.push(x,y, r, g, b, alpha); verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha); indices.push(vecPos++, vecPos++); } indices.push(vecPos-1); } if(graphicsData.lineWidth) { var tempPoints = graphicsData.points; graphicsData.points = []; for (i = 0; i < totalSegs + 1; i++) { graphicsData.points.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height); } PIXI.WebGLGraphics.buildLine(graphicsData, webGLData); graphicsData.points = tempPoints; } }; PIXI.WebGLGraphics.buildLine = function(graphicsData, webGLData) { var i = 0; var points = graphicsData.points; if(points.length === 0)return; if(graphicsData.lineWidth%2) { for (i = 0; i < points.length; i++) { points[i] += 0.5; } } var firstPoint = new PIXI.Point( points[0], points[1] ); var lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] ); if(firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) { points = points.slice(); points.pop(); points.pop(); lastPoint = new PIXI.Point( points[points.length - 2], points[points.length - 1] ); var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) *0.5; var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) *0.5; points.unshift(midPointX, midPointY); points.push(midPointX, midPointY); } var verts = webGLData.points; var indices = webGLData.indices; var length = points.length / 2; var indexCount = points.length; var indexStart = verts.length/6; var width = graphicsData.lineWidth / 2; var color = PIXI.hex2rgb(graphicsData.lineColor); var alpha = graphicsData.lineAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; var px, py, p1x, p1y, p2x, p2y, p3x, p3y; var perpx, perpy, perp2x, perp2y, perp3x, perp3y; var a1, b1, c1, a2, b2, c2; var denom, pdist, dist; p1x = points[0]; p1y = points[1]; p2x = points[2]; p2y = points[3]; perpx = -(p1y - p2y); perpy =  p1x - p2x; dist = Math.sqrt(perpx*perpx + perpy*perpy); perpx /= dist; perpy /= dist; perpx *= width; perpy *= width; verts.push(p1x - perpx , p1y - perpy, r, g, b, alpha); verts.push(p1x + perpx , p1y + perpy, r, g, b, alpha); for (i = 1; i < length-1; i++) { p1x = points[(i-1)*2]; p1y = points[(i-1)*2 + 1]; p2x = points[(i)*2]; p2y = points[(i)*2 + 1]; p3x = points[(i+1)*2]; p3y = points[(i+1)*2 + 1]; perpx = -(p1y - p2y); perpy = p1x - p2x; dist = Math.sqrt(perpx*perpx + perpy*perpy); perpx /= dist; perpy /= dist; perpx *= width; perpy *= width; perp2x = -(p2y - p3y); perp2y = p2x - p3x; dist = Math.sqrt(perp2x*perp2x + perp2y*perp2y); perp2x /= dist; perp2y /= dist; perp2x *= width; perp2y *= width; a1 = (-perpy + p1y) - (-perpy + p2y); b1 = (-perpx + p2x) - (-perpx + p1x); c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y); a2 = (-perp2y + p3y) - (-perp2y + p2y); b2 = (-perp2x + p2x) - (-perp2x + p3x); c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y); denom = a1*b2 - a2*b1; if(Math.abs(denom) < 0.1 ) { denom+=10.1; verts.push(p2x - perpx , p2y - perpy, r, g, b, alpha); verts.push(p2x + perpx , p2y + perpy, r, g, b, alpha); continue; } px = (b1*c2 - b2*c1)/denom; py = (a2*c1 - a1*c2)/denom; pdist = (px -p2x) * (px -p2x) + (py -p2y) + (py -p2y); if(pdist > 140 * 140) { perp3x = perpx - perp2x; perp3y = perpy - perp2y; dist = Math.sqrt(perp3x*perp3x + perp3y*perp3y); perp3x /= dist; perp3y /= dist; perp3x *= width; perp3y *= width; verts.push(p2x - perp3x, p2y -perp3y); verts.push(r, g, b, alpha); verts.push(p2x + perp3x, p2y +perp3y); verts.push(r, g, b, alpha); verts.push(p2x - perp3x, p2y -perp3y); verts.push(r, g, b, alpha); indexCount++; } else { verts.push(px , py); verts.push(r, g, b, alpha); verts.push(p2x - (px-p2x), p2y - (py - p2y)); verts.push(r, g, b, alpha); } } p1x = points[(length-2)*2]; p1y = points[(length-2)*2 + 1]; p2x = points[(length-1)*2]; p2y = points[(length-1)*2 + 1]; perpx = -(p1y - p2y); perpy = p1x - p2x; dist = Math.sqrt(perpx*perpx + perpy*perpy); perpx /= dist; perpy /= dist; perpx *= width; perpy *= width; verts.push(p2x - perpx , p2y - perpy); verts.push(r, g, b, alpha); verts.push(p2x + perpx , p2y + perpy); verts.push(r, g, b, alpha); indices.push(indexStart); for (i = 0; i < indexCount; i++) { indices.push(indexStart++); } indices.push(indexStart-1); }; PIXI.WebGLGraphics.buildComplexPoly = function(graphicsData, webGLData) { var points = graphicsData.points.slice(); if(points.length < 6)return; var indices = webGLData.indices; webGLData.points = points; webGLData.alpha = graphicsData.fillAlpha; webGLData.color = PIXI.hex2rgb(graphicsData.fillColor); var minX = Infinity; var maxX = -Infinity; var minY = Infinity; var maxY = -Infinity; var x,y; for (var i = 0; i < points.length; i+=2) { x = points[i]; y = points[i+1]; minX = x < minX ? x : minX; maxX = x > maxX ? x : maxX; minY = y < minY ? y : minY; maxY = y > maxY ? y : maxY; } points.push(minX, minY, maxX, minY, maxX, maxY, minX, maxY); var length = points.length / 2; for (i = 0; i < length; i++) { indices.push( i ); } }; PIXI.WebGLGraphics.buildPoly = function(graphicsData, webGLData) { var points = graphicsData.points; if(points.length < 6)return; var verts = webGLData.points; var indices = webGLData.indices; var length = points.length / 2; var color = PIXI.hex2rgb(graphicsData.fillColor); var alpha = graphicsData.fillAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; var triangles = PIXI.EarCut.Triangulate(points, null, 2); if(!triangles)return false; var vertPos = verts.length / 6; var i = 0; for (i = 0; i < triangles.length; i+=3) { indices.push(triangles[i] + vertPos); indices.push(triangles[i] + vertPos); indices.push(triangles[i+1] + vertPos); indices.push(triangles[i+2] +vertPos); indices.push(triangles[i+2] + vertPos); } for (i = 0; i < length; i++) { verts.push(points[i * 2], points[i * 2 + 1], r, g, b, alpha); } return true; }; PIXI.WebGLGraphics.graphicsDataPool = []; PIXI.WebGLGraphicsData = function(gl) { this.gl = gl; this.color = [0,0,0]; this.points = []; this.indices = []; this.buffer = gl.createBuffer(); this.indexBuffer = gl.createBuffer(); this.mode = 1; this.alpha = 1; this.dirty = true; }; PIXI.WebGLGraphicsData.prototype.reset = function() { this.points = []; this.indices = []; }; PIXI.WebGLGraphicsData.prototype.upload = function() { var gl = this.gl; this.glPoints = new PIXI.Float32Array(this.points); gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer); gl.bufferData(gl.ARRAY_BUFFER, this.glPoints, gl.STATIC_DRAW); this.glIndicies = new PIXI.Uint16Array(this.indices); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.glIndicies, gl.STATIC_DRAW); this.dirty = false; }; PIXI.CanvasGraphics = function() { }; PIXI.CanvasGraphics.renderGraphics = function(graphics, context) { var worldAlpha = graphics.worldAlpha; if (graphics.dirty) { this.updateGraphicsTint(graphics); graphics.dirty = false; } for (var i = 0; i < graphics.graphicsData.length; i++) { var data = graphics.graphicsData[i]; var shape = data.shape; var fillColor = data._fillTint; var lineColor = data._lineTint; context.lineWidth = data.lineWidth; if (data.type === PIXI.Graphics.POLY) { context.beginPath(); var points = shape.points; context.moveTo(points[0], points[1]); for (var j=1; j < points.length/2; j++) { context.lineTo(points[j * 2], points[j * 2 + 1]); } if (shape.closed) { context.lineTo(points[0], points[1]); } if (points[0] === points[points.length-2] && points[1] === points[points.length-1]) { context.closePath(); } if (data.fill) { context.globalAlpha = data.fillAlpha * worldAlpha; context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6); context.fill(); } if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha; context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6); context.stroke(); } } else if (data.type === PIXI.Graphics.RECT) { if (data.fillColor || data.fillColor === 0) { context.globalAlpha = data.fillAlpha * worldAlpha; context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6); context.fillRect(shape.x, shape.y, shape.width, shape.height); } if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha; context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6); context.strokeRect(shape.x, shape.y, shape.width, shape.height); } } else if (data.type === PIXI.Graphics.CIRC) { context.beginPath(); context.arc(shape.x, shape.y, shape.radius,0,2*Math.PI); context.closePath(); if (data.fill) { context.globalAlpha = data.fillAlpha * worldAlpha; context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6); context.fill(); } if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha; context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6); context.stroke(); } } else if (data.type === PIXI.Graphics.ELIP) { var w = shape.width * 2; var h = shape.height * 2; var x = shape.x - w/2; var y = shape.y - h/2; context.beginPath(); var kappa = 0.5522848, ox = (w / 2) * kappa, oy = (h / 2) * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2; context.moveTo(x, ym); context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y); context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym); context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye); context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym); context.closePath(); if (data.fill) { context.globalAlpha = data.fillAlpha * worldAlpha; context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6); context.fill(); } if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha; context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6); context.stroke(); } } else if (data.type === PIXI.Graphics.RREC) { var rx = shape.x; var ry = shape.y; var width = shape.width; var height = shape.height; var radius = shape.radius; var maxRadius = Math.min(width, height) / 2 | 0; radius = radius > maxRadius ? maxRadius : radius; context.beginPath(); context.moveTo(rx, ry + radius); context.lineTo(rx, ry + height - radius); context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height); context.lineTo(rx + width - radius, ry + height); context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius); context.lineTo(rx + width, ry + radius); context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry); context.lineTo(rx + radius, ry); context.quadraticCurveTo(rx, ry, rx, ry + radius); context.closePath(); if (data.fillColor || data.fillColor === 0) { context.globalAlpha = data.fillAlpha * worldAlpha; context.fillStyle = '#' + ('00000' + ( fillColor | 0).toString(16)).substr(-6); context.fill(); } if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha; context.strokeStyle = '#' + ('00000' + ( lineColor | 0).toString(16)).substr(-6); context.stroke(); } } } }; PIXI.CanvasGraphics.renderGraphicsMask = function(graphics, context) { var len = graphics.graphicsData.length; if (len === 0) { return; } context.beginPath(); for (var i = 0; i < len; i++) { var data = graphics.graphicsData[i]; var shape = data.shape; if (data.type === PIXI.Graphics.POLY) { var points = shape.points; context.moveTo(points[0], points[1]); for (var j=1; j < points.length/2; j++) { context.lineTo(points[j * 2], points[j * 2 + 1]); } if (points[0] === points[points.length-2] && points[1] === points[points.length-1]) { context.closePath(); } } else if (data.type === PIXI.Graphics.RECT) { context.rect(shape.x, shape.y, shape.width, shape.height); context.closePath(); } else if (data.type === PIXI.Graphics.CIRC) { context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI); context.closePath(); } else if (data.type === PIXI.Graphics.ELIP) { var w = shape.width * 2; var h = shape.height * 2; var x = shape.x - w/2; var y = shape.y - h/2; var kappa = 0.5522848, ox = (w / 2) * kappa, oy = (h / 2) * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2; context.moveTo(x, ym); context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y); context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym); context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye); context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym); context.closePath(); } else if (data.type === PIXI.Graphics.RREC) { var rx = shape.x; var ry = shape.y; var width = shape.width; var height = shape.height; var radius = shape.radius; var maxRadius = Math.min(width, height) / 2 | 0; radius = radius > maxRadius ? maxRadius : radius; context.moveTo(rx, ry + radius); context.lineTo(rx, ry + height - radius); context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height); context.lineTo(rx + width - radius, ry + height); context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius); context.lineTo(rx + width, ry + radius); context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry); context.lineTo(rx + radius, ry); context.quadraticCurveTo(rx, ry, rx, ry + radius); context.closePath(); } } }; PIXI.CanvasGraphics.updateGraphicsTint = function(graphics) { if (graphics.tint === 0xFFFFFF) { return; } var tintR = (graphics.tint >> 16 & 0xFF) / 255; var tintG = (graphics.tint >> 8 & 0xFF) / 255; var tintB = (graphics.tint & 0xFF)/ 255; for (var i = 0; i < graphics.graphicsData.length; i++) { var data = graphics.graphicsData[i]; var fillColor = data.fillColor | 0; var lineColor = data.lineColor | 0; data._fillTint = (((fillColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (fillColor & 0xFF) / 255 * tintB*255); data._lineTint = (((lineColor >> 16 & 0xFF) / 255 * tintR*255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG*255 << 8) +  (lineColor & 0xFF) / 255 * tintB*255); } }; Phaser.Graphics = function (game, x, y) { if (x === undefined) { x = 0; } if (y === undefined) { y = 0; } this.type = Phaser.GRAPHICS; this.physicsType = Phaser.SPRITE; this.anchor = new Phaser.Point(); PIXI.Graphics.call(this); Phaser.Component.Core.init.call(this, game, x, y, '', null); }; Phaser.Graphics.prototype = Object.create(PIXI.Graphics.prototype); Phaser.Graphics.prototype.constructor = Phaser.Graphics; Phaser.Component.Core.install.call(Phaser.Graphics.prototype, [ 'Angle', 'AutoCull', 'Bounds', 'Destroy', 'FixedToCamera', 'InputEnabled', 'InWorld', 'LifeSpan', 'PhysicsBody', 'Reset' ]); Phaser.Graphics.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate; Phaser.Graphics.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate; Phaser.Graphics.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate; Phaser.Graphics.prototype.preUpdateCore = Phaser.Component.Core.preUpdate; Phaser.Graphics.prototype.preUpdate = function () { if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) { return false; } return this.preUpdateCore(); }; Phaser.Graphics.prototype.postUpdate = function () { Phaser.Component.PhysicsBody.postUpdate.call(this); Phaser.Component.FixedToCamera.postUpdate.call(this); if (this._boundsDirty) { this.updateLocalBounds(); this._boundsDirty = false; } for (var i = 0; i < this.children.length; i++) { this.children[i].postUpdate(); } }; Phaser.Graphics.prototype.destroy = function(destroyChildren) { this.clear(); Phaser.Component.Destroy.prototype.destroy.call(this, destroyChildren); }; Phaser.Graphics.prototype.drawTriangle = function(points, cull) { if (cull === undefined) { cull = false; } var triangle = new Phaser.Polygon(points); if (cull) { var cameraToFace = new Phaser.Point(this.game.camera.x - points[0].x, this.game.camera.y - points[0].y); var ab = new Phaser.Point(points[1].x - points[0].x, points[1].y - points[0].y); var cb = new Phaser.Point(points[1].x - points[2].x, points[1].y - points[2].y); var faceNormal = cb.cross(ab); if (cameraToFace.dot(faceNormal) > 0) { this.drawPolygon(triangle); } } else { this.drawPolygon(triangle); } }; Phaser.Graphics.prototype.drawTriangles = function(vertices, indices, cull) { if (cull === undefined) { cull = false; } var point1 = new Phaser.Point(); var point2 = new Phaser.Point(); var point3 = new Phaser.Point(); var points = []; var i; if (!indices) { if (vertices[0] instanceof Phaser.Point) { for (i = 0; i < vertices.length / 3; i++) { this.drawTriangle([vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]], cull); } } else { for (i = 0; i < vertices.length / 6; i++) { point1.x = vertices[i * 6 + 0]; point1.y = vertices[i * 6 + 1]; point2.x = vertices[i * 6 + 2]; point2.y = vertices[i * 6 + 3]; point3.x = vertices[i * 6 + 4]; point3.y = vertices[i * 6 + 5]; this.drawTriangle([point1, point2, point3], cull); } } } else { if (vertices[0] instanceof Phaser.Point) { for (i = 0; i < indices.length /3; i++) { points.push(vertices[indices[i * 3 ]]); points.push(vertices[indices[i * 3 + 1]]); points.push(vertices[indices[i * 3 + 2]]); if (points.length === 3) { this.drawTriangle(points, cull); points = []; } } } else { for (i = 0; i < indices.length; i++) { point1.x = vertices[indices[i] * 2]; point1.y = vertices[indices[i] * 2 + 1]; points.push(point1.copyTo({})); if (points.length === 3) { this.drawTriangle(points, cull); points = []; } } } } }; Phaser.RenderTexture = function (game, width, height, key, scaleMode, resolution) { if (key === undefined) { key = ''; } if (scaleMode === undefined) { scaleMode = Phaser.scaleModes.DEFAULT; } if (resolution === undefined) { resolution = 1; } this.game = game; this.key = key; this.type = Phaser.RENDERTEXTURE; this._tempMatrix = new PIXI.Matrix(); PIXI.RenderTexture.call(this, width, height, this.game.renderer, scaleMode, resolution); this.render = Phaser.RenderTexture.prototype.render; }; Phaser.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype); Phaser.RenderTexture.prototype.constructor = Phaser.RenderTexture; Phaser.RenderTexture.prototype.renderXY = function (displayObject, x, y, clear) { displayObject.updateTransform(); this._tempMatrix.copyFrom(displayObject.worldTransform); this._tempMatrix.tx = x; this._tempMatrix.ty = y; if (this.renderer.type === PIXI.WEBGL_RENDERER) { this.renderWebGL(displayObject, this._tempMatrix, clear); } else { this.renderCanvas(displayObject, this._tempMatrix, clear); } }; Phaser.RenderTexture.prototype.renderRawXY = function (displayObject, x, y, clear) { this._tempMatrix.identity().translate(x, y); if (this.renderer.type === PIXI.WEBGL_RENDERER) { this.renderWebGL(displayObject, this._tempMatrix, clear); } else { this.renderCanvas(displayObject, this._tempMatrix, clear); } }; Phaser.RenderTexture.prototype.render = function (displayObject, matrix, clear) { if (matrix === undefined || matrix === null) { this._tempMatrix.copyFrom(displayObject.worldTransform); } else { this._tempMatrix.copyFrom(matrix); } if (this.renderer.type === PIXI.WEBGL_RENDERER) { this.renderWebGL(displayObject, this._tempMatrix, clear); } else { this.renderCanvas(displayObject, this._tempMatrix, clear); } }; Phaser.Text = function (game, x, y, text, style) { x = x || 0; y = y || 0; if (text === undefined || text === null) { text = ''; } else { text = text.toString(); } style = Phaser.Utils.extend({}, style); this.type = Phaser.TEXT; this.physicsType = Phaser.SPRITE; this.padding = new Phaser.Point(); this.textBounds = null; this.canvas = PIXI.CanvasPool.create(this); this.context = this.canvas.getContext('2d'); this.colors = []; this.strokeColors = []; this.fontStyles = []; this.fontWeights = []; this.autoRound = false; this.useAdvancedWrap = false; this._res = game.renderer.resolution; this._text = text; this._fontComponents = null; this._lineSpacing = 0; this._charCount = 0; this._width = 0; this._height = 0; Phaser.Sprite.call(this, game, x, y, PIXI.Texture.fromCanvas(this.canvas)); this.setStyle(style); if (text !== '') { this.updateText(); } }; Phaser.Text.prototype = Object.create(Phaser.Sprite.prototype); Phaser.Text.prototype.constructor = Phaser.Text; Phaser.Text.prototype.preUpdate = function () { if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) { return false; } return this.preUpdateCore(); }; Phaser.Text.prototype.update = function() { }; Phaser.Text.prototype.destroy = function (destroyChildren) { this.texture.destroy(true); Phaser.Component.Destroy.prototype.destroy.call(this, destroyChildren); }; Phaser.Text.prototype.setShadow = function (x, y, color, blur, shadowStroke, shadowFill) { if (x === undefined) { x = 0; } if (y === undefined) { y = 0; } if (color === undefined) { color = 'rgba(0, 0, 0, 1)'; } if (blur === undefined) { blur = 0; } if (shadowStroke === undefined) { shadowStroke = true; } if (shadowFill === undefined) { shadowFill = true; } this.style.shadowOffsetX = x; this.style.shadowOffsetY = y; this.style.shadowColor = color; this.style.shadowBlur = blur; this.style.shadowStroke = shadowStroke; this.style.shadowFill = shadowFill; this.dirty = true; return this; }; Phaser.Text.prototype.setStyle = function (style, update) { if (update === undefined) { update = false; } style = style || {}; style.font = style.font || 'bold 20pt Arial'; style.backgroundColor = style.backgroundColor || null; style.fill = style.fill || 'black'; style.align = style.align || 'left'; style.boundsAlignH = style.boundsAlignH || 'left'; style.boundsAlignV = style.boundsAlignV || 'top'; style.stroke = style.stroke || 'black'; style.strokeThickness = style.strokeThickness || 0; style.wordWrap = style.wordWrap || false; style.wordWrapWidth = style.wordWrapWidth || 100; style.maxLines = style.maxLines || 0; style.shadowOffsetX = style.shadowOffsetX || 0; style.shadowOffsetY = style.shadowOffsetY || 0; style.shadowColor = style.shadowColor || 'rgba(0,0,0,0)'; style.shadowBlur = style.shadowBlur || 0; style.tabs = style.tabs || 0; var components = this.fontToComponents(style.font); if (style.fontStyle) { components.fontStyle = style.fontStyle; } if (style.fontVariant) { components.fontVariant = style.fontVariant; } if (style.fontWeight) { components.fontWeight = style.fontWeight; } if (style.fontSize) { if (typeof style.fontSize === 'number') { style.fontSize = style.fontSize + 'px'; } components.fontSize = style.fontSize; } this._fontComponents = components; style.font = this.componentsToFont(this._fontComponents); this.style = style; this.dirty = true; if (update) { this.updateText(); } return this; }; Phaser.Text.prototype.updateText = function () { this.texture.baseTexture.resolution = this._res; this.context.font = this.style.font; var outputText = this.text; if (this.style.wordWrap) { outputText = this.runWordWrap(this.text); } var lines = outputText.split(/(?:\r\n|\r|\n)/); var tabs = this.style.tabs; var lineWidths = []; var maxLineWidth = 0; var fontProperties = this.determineFontProperties(this.style.font); var drawnLines = lines.length; if (this.style.maxLines > 0 && this.style.maxLines < lines.length) { drawnLines = this.style.maxLines; } this._charCount = 0; for (var i = 0; i < drawnLines; i++) { if (tabs === 0) { var lineWidth =  this.style.strokeThickness + this.padding.x; if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0) { lineWidth += this.measureLine(lines[i]); } else { lineWidth += this.context.measureText(lines[i]).width; } if (this.style.wordWrap) { lineWidth -= this.context.measureText(' ').width; } } else { var line = lines[i].split(/(?:\t)/); var lineWidth = this.padding.x + this.style.strokeThickness; if (Array.isArray(tabs)) { var tab = 0; for (var c = 0; c < line.length; c++) { var section = 0; if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0) { section = this.measureLine(line[c]); } else { section = Math.ceil(this.context.measureText(line[c]).width); } if (c > 0) { tab += tabs[c - 1]; } lineWidth = tab + section; } } else { for (var c = 0; c < line.length; c++) { if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0) { lineWidth += this.measureLine(line[c]); } else { lineWidth += Math.ceil(this.context.measureText(line[c]).width); } var diff = this.game.math.snapToCeil(lineWidth, tabs) - lineWidth; lineWidth += diff; } } } lineWidths[i] = Math.ceil(lineWidth); maxLineWidth = Math.max(maxLineWidth, lineWidths[i]); } this.canvas.width = maxLineWidth * this._res; var lineHeight = fontProperties.fontSize + this.style.strokeThickness + this.padding.y; var height = lineHeight * drawnLines; var lineSpacing = this._lineSpacing; if (lineSpacing < 0 && Math.abs(lineSpacing) > lineHeight) { lineSpacing = -lineHeight; } if (lineSpacing !== 0) { height += (lineSpacing > 0) ? lineSpacing * lines.length : lineSpacing * (lines.length - 1); } this.canvas.height = height * this._res; this.context.scale(this._res, this._res); if (navigator.isCocoonJS) { this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); } if (this.style.backgroundColor) { this.context.fillStyle = this.style.backgroundColor; this.context.fillRect(0, 0, this.canvas.width, this.canvas.height); } this.context.fillStyle = this.style.fill; this.context.font = this.style.font; this.context.strokeStyle = this.style.stroke; this.context.textBaseline = 'alphabetic'; this.context.lineWidth = this.style.strokeThickness; this.context.lineCap = 'round'; this.context.lineJoin = 'round'; var linePositionX; var linePositionY; this._charCount = 0; for (i = 0; i < drawnLines; i++) { linePositionX = this.style.strokeThickness / 2; linePositionY = (this.style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent; if (i > 0) { linePositionY += (lineSpacing * i); } if (this.style.align === 'right') { linePositionX += maxLineWidth - lineWidths[i]; } else if (this.style.align === 'center') { linePositionX += (maxLineWidth - lineWidths[i]) / 2; } if (this.autoRound) { linePositionX = Math.round(linePositionX); linePositionY = Math.round(linePositionY); } if (this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0) { this.updateLine(lines[i], linePositionX, linePositionY); } else { if (this.style.stroke && this.style.strokeThickness) { this.updateShadow(this.style.shadowStroke); if (tabs === 0) { this.context.strokeText(lines[i], linePositionX, linePositionY); } else { this.renderTabLine(lines[i], linePositionX, linePositionY, false); } } if (this.style.fill) { this.updateShadow(this.style.shadowFill); if (tabs === 0) { this.context.fillText(lines[i], linePositionX, linePositionY); } else { this.renderTabLine(lines[i], linePositionX, linePositionY, true); } } } } this.updateTexture(); this.dirty = false; }; Phaser.Text.prototype.renderTabLine = function (line, x, y, fill) { var text = line.split(/(?:\t)/); var tabs = this.style.tabs; var snap = 0; if (Array.isArray(tabs)) { var tab = 0; for (var c = 0; c < text.length; c++) { if (c > 0) { tab += tabs[c - 1]; } snap = x + tab; if (fill) { this.context.fillText(text[c], snap, y); } else { this.context.strokeText(text[c], snap, y); } } } else { for (var c = 0; c < text.length; c++) { var section = Math.ceil(this.context.measureText(text[c]).width); snap = this.game.math.snapToCeil(x, tabs); if (fill) { this.context.fillText(text[c], snap, y); } else { this.context.strokeText(text[c], snap, y); } x = snap + section; } } }; Phaser.Text.prototype.updateShadow = function (state) { if (state) { this.context.shadowOffsetX = this.style.shadowOffsetX; this.context.shadowOffsetY = this.style.shadowOffsetY; this.context.shadowColor = this.style.shadowColor; this.context.shadowBlur = this.style.shadowBlur; } else { this.context.shadowOffsetX = 0; this.context.shadowOffsetY = 0; this.context.shadowColor = 0; this.context.shadowBlur = 0; } }; Phaser.Text.prototype.measureLine = function (line) { var lineLength = 0; for (var i = 0; i < line.length; i++) { var letter = line[i]; if (this.fontWeights.length > 0 || this.fontStyles.length > 0) { var components = this.fontToComponents(this.context.font); if (this.fontStyles[this._charCount]) { components.fontStyle = this.fontStyles[this._charCount]; } if (this.fontWeights[this._charCount]) { components.fontWeight = this.fontWeights[this._charCount]; } this.context.font = this.componentsToFont(components); } if (this.style.stroke && this.style.strokeThickness) { if (this.strokeColors[this._charCount]) { this.context.strokeStyle = this.strokeColors[this._charCount]; } this.updateShadow(this.style.shadowStroke); } if (this.style.fill) { if (this.colors[this._charCount]) { this.context.fillStyle = this.colors[this._charCount]; } this.updateShadow(this.style.shadowFill); } lineLength += this.context.measureText(letter).width; this._charCount++; } return Math.ceil(lineLength); }; Phaser.Text.prototype.updateLine = function (line, x, y) { for (var i = 0; i < line.length; i++) { var letter = line[i]; if (this.fontWeights.length > 0 || this.fontStyles.length > 0) { var components = this.fontToComponents(this.context.font); if (this.fontStyles[this._charCount]) { components.fontStyle = this.fontStyles[this._charCount]; } if (this.fontWeights[this._charCount]) { components.fontWeight = this.fontWeights[this._charCount]; } this.context.font = this.componentsToFont(components); } if (this.style.stroke && this.style.strokeThickness) { if (this.strokeColors[this._charCount]) { this.context.strokeStyle = this.strokeColors[this._charCount]; } this.updateShadow(this.style.shadowStroke); this.context.strokeText(letter, x, y); } if (this.style.fill) { if (this.colors[this._charCount]) { this.context.fillStyle = this.colors[this._charCount]; } this.updateShadow(this.style.shadowFill); this.context.fillText(letter, x, y); } x += this.context.measureText(letter).width; this._charCount++; } }; Phaser.Text.prototype.clearColors = function () { this.colors = []; this.strokeColors = []; this.dirty = true; return this; }; Phaser.Text.prototype.clearFontValues = function () { this.fontStyles = []; this.fontWeights = []; this.dirty = true; return this; }; Phaser.Text.prototype.addColor = function (color, position) { this.colors[position] = color; this.dirty = true; return this; }; Phaser.Text.prototype.addStrokeColor = function (color, position) { this.strokeColors[position] = color; this.dirty = true; return this; }; Phaser.Text.prototype.addFontStyle = function (style, position) { this.fontStyles[position] = style; this.dirty = true; return this; }; Phaser.Text.prototype.addFontWeight = function (weight, position) { this.fontWeights[position] = weight; this.dirty = true; return this; }; Phaser.Text.prototype.precalculateWordWrap = function (text) { this.texture.baseTexture.resolution = this._res; this.context.font = this.style.font; var wrappedLines = this.runWordWrap(text); return wrappedLines.split(/(?:\r\n|\r|\n)/); }; Phaser.Text.prototype.runWordWrap = function (text) { if (this.useAdvancedWrap) { return this.advancedWordWrap(text); } else { return this.basicWordWrap(text); } }; Phaser.Text.prototype.advancedWordWrap = function (text) { var context = this.context; var wordWrapWidth = this.style.wordWrapWidth; var output = ''; var lines = text .replace(/ +/gi, ' ') .split(/\r?\n/gi); var linesCount = lines.length; for (var i = 0; i < linesCount; i++) { var line = lines[i]; var out = ''; line = line.replace(/^ *|\s*$/gi, ''); var lineWidth = context.measureText(line).width; if (lineWidth < wordWrapWidth) { output += line + '\n'; continue; } var currentLineWidth = wordWrapWidth; var words = line.split(' '); for (var j = 0; j < words.length; j++) { var word = words[j]; var wordWithSpace = word + ' '; var wordWidth = context.measureText(wordWithSpace).width; if (wordWidth > currentLineWidth) { if (j === 0) { var newWord = wordWithSpace; while (newWord.length) { newWord = newWord.slice(0, -1); wordWidth = context.measureText(newWord).width; if (wordWidth <= currentLineWidth) { break; } } if (!newWord.length) { throw new Error('This text\'s wordWrapWidth setting is less than a single character!'); } var secondPart = word.substr(newWord.length); words[j] = secondPart; out += newWord; } var offset = (words[j].length) ? j : j + 1; var remainder = words.slice(offset).join(' ') .replace(/[ \n]*$/gi, ''); lines[i + 1] = remainder + ' ' + (lines[i + 1] || ''); linesCount = lines.length; break; } else { out += wordWithSpace; currentLineWidth -= wordWidth; } } output += out.replace(/[ \n]*$/gi, '') + '\n'; } output = output.replace(/[\s|\n]*$/gi, ''); return output; }; Phaser.Text.prototype.basicWordWrap = function (text) { var result = ''; var lines = text.split('\n'); for (var i = 0; i < lines.length; i++) { var spaceLeft = this.style.wordWrapWidth; var words = lines[i].split(' '); for (var j = 0; j < words.length; j++) { var wordWidth = this.context.measureText(words[j]).width; var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width; if (wordWidthWithSpace > spaceLeft) { if (j > 0) { result += '\n'; } result += words[j] + ' '; spaceLeft = this.style.wordWrapWidth - wordWidth; } else { spaceLeft -= wordWidthWithSpace; result += words[j] + ' '; } } if (i < lines.length-1) { result += '\n'; } } return result; }; Phaser.Text.prototype.updateFont = function (components) { var font = this.componentsToFont(components); if (this.style.font !== font) { this.style.font = font; this.dirty = true; if (this.parent) { this.updateTransform(); } } }; Phaser.Text.prototype.fontToComponents = function (font) { var m = font.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/); if (m) { var family = m[5].trim(); if (!/^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(family) && !/['",]/.exec(family)) { family = "'" + family + "'"; } return { font: font, fontStyle: m[1] || 'normal', fontVariant: m[2] || 'normal', fontWeight: m[3] || 'normal', fontSize: m[4] || 'medium', fontFamily: family }; } else { console.warn("Phaser.Text - unparsable CSS font: " + font); return { font: font }; } }; Phaser.Text.prototype.componentsToFont = function (components) { var parts = []; var v; v = components.fontStyle; if (v && v !== 'normal') { parts.push(v); } v = components.fontVariant; if (v && v !== 'normal') { parts.push(v); } v = components.fontWeight; if (v && v !== 'normal') { parts.push(v); } v = components.fontSize; if (v && v !== 'medium') { parts.push(v); } v = components.fontFamily; if (v) { parts.push(v); } if (!parts.length) { parts.push(components.font); } return parts.join(" "); }; Phaser.Text.prototype.setText = function (text, immediate) { if (immediate === undefined) { immediate = false; } this.text = text.toString() || ''; if (immediate) { this.updateText(); } else { this.dirty = true; } return this; }; Phaser.Text.prototype.parseList = function (list) { if (!Array.isArray(list)) { return this; } else { var s = ""; for (var i = 0; i < list.length; i++) { if (Array.isArray(list[i])) { s += list[i].join("\t"); if (i < list.length - 1) { s += "\n"; } } else { s += list[i]; if (i < list.length - 1) { s += "\t"; } } } } this.text = s; this.dirty = true; return this; }; Phaser.Text.prototype.setTextBounds = function (x, y, width, height) { if (x === undefined) { this.textBounds = null; } else { if (!this.textBounds) { this.textBounds = new Phaser.Rectangle(x, y, width, height); } else { this.textBounds.setTo(x, y, width, height); } if (this.style.wordWrapWidth > width) { this.style.wordWrapWidth = width; } } this.updateTexture(); return this; }; Phaser.Text.prototype.updateTexture = function () { var base = this.texture.baseTexture; var crop = this.texture.crop; var frame = this.texture.frame; var w = this.canvas.width; var h = this.canvas.height; base.width = w; base.height = h; crop.width = w; crop.height = h; frame.width = w; frame.height = h; this.texture.width = w; this.texture.height = h; this._width = w; this._height = h; if (this.textBounds) { var x = this.textBounds.x; var y = this.textBounds.y; if (this.style.boundsAlignH === 'right') { x += this.textBounds.width - this.canvas.width / this.resolution; } else if (this.style.boundsAlignH === 'center') { x += this.textBounds.halfWidth - (this.canvas.width / this.resolution / 2); } if (this.style.boundsAlignV === 'bottom') { y += this.textBounds.height - this.canvas.height / this.resolution; } else if (this.style.boundsAlignV === 'middle') { y += this.textBounds.halfHeight - (this.canvas.height / this.resolution / 2); } this.pivot.x = -x; this.pivot.y = -y; } this.renderable = (w !== 0 && h !== 0); this.texture.requiresReTint = true; this.texture.baseTexture.dirty(); }; Phaser.Text.prototype._renderWebGL = function (renderSession) { if (this.dirty) { this.updateText(); this.dirty = false; } PIXI.Sprite.prototype._renderWebGL.call(this, renderSession); }; Phaser.Text.prototype._renderCanvas = function (renderSession) { if (this.dirty) { this.updateText(); this.dirty = false; } PIXI.Sprite.prototype._renderCanvas.call(this, renderSession); }; Phaser.Text.prototype.determineFontProperties = function (fontStyle) { var properties = Phaser.Text.fontPropertiesCache[fontStyle]; if (!properties) { properties = {}; var canvas = Phaser.Text.fontPropertiesCanvas; var context = Phaser.Text.fontPropertiesContext; context.font = fontStyle; var width = Math.ceil(context.measureText('|Mq').width); var baseline = Math.ceil(context.measureText('|Mq').width); var height = 2 * baseline; baseline = baseline * 1.4 | 0; canvas.width = width; canvas.height = height; context.fillStyle = '#f00'; context.fillRect(0, 0, width, height); context.font = fontStyle; context.textBaseline = 'alphabetic'; context.fillStyle = '#000'; context.fillText('|Mq', 0, baseline); if (!context.getImageData(0, 0, width, height)) { properties.ascent = baseline; properties.descent = baseline + 6; properties.fontSize = properties.ascent + properties.descent; Phaser.Text.fontPropertiesCache[fontStyle] = properties; return properties; } var imagedata = context.getImageData(0, 0, width, height).data; var pixels = imagedata.length; var line = width * 4; var i, j; var idx = 0; var stop = false; for (i = 0; i < baseline; i++) { for (j = 0; j < line; j += 4) { if (imagedata[idx + j] !== 255) { stop = true; break; } } if (!stop) { idx += line; } else { break; } } properties.ascent = baseline - i; idx = pixels - line; stop = false; for (i = height; i > baseline; i--) { for (j = 0; j < line; j += 4) { if (imagedata[idx + j] !== 255) { stop = true; break; } } if (!stop) { idx -= line; } else { break; } } properties.descent = i - baseline; properties.descent += 6; properties.fontSize = properties.ascent + properties.descent; Phaser.Text.fontPropertiesCache[fontStyle] = properties; } return properties; }; Phaser.Text.prototype.getBounds = function (matrix) { if (this.dirty) { this.updateText(); this.dirty = false; } return PIXI.Sprite.prototype.getBounds.call(this, matrix); }; Object.defineProperty(Phaser.Text.prototype, 'text', { get: function() { return this._text; }, set: function(value) { if (value !== this._text) { this._text = value.toString() || ''; this.dirty = true; if (this.parent) { this.updateTransform(); } } } }); Object.defineProperty(Phaser.Text.prototype, 'cssFont', { get: function() { return this.componentsToFont(this._fontComponents); }, set: function (value) { value = value || 'bold 20pt Arial'; this._fontComponents = this.fontToComponents(value); this.updateFont(this._fontComponents); } }); Object.defineProperty(Phaser.Text.prototype, 'font', { get: function() { return this._fontComponents.fontFamily; }, set: function(value) { value = value || 'Arial'; value = value.trim(); if (!/^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(value) && !/['",]/.exec(value)) { value = "'" + value + "'"; } this._fontComponents.fontFamily = value; this.updateFont(this._fontComponents); } }); Object.defineProperty(Phaser.Text.prototype, 'fontSize', { get: function() { var size = this._fontComponents.fontSize; if (size && /(?:^0$|px$)/.exec(size)) { return parseInt(size, 10); } else { return size; } }, set: function(value) { value = value || '0'; if (typeof value === 'number') { value = value + 'px'; } this._fontComponents.fontSize = value; this.updateFont(this._fontComponents); } }); Object.defineProperty(Phaser.Text.prototype, 'fontWeight', { get: function() { return this._fontComponents.fontWeight || 'normal'; }, set: function(value) { value = value || 'normal'; this._fontComponents.fontWeight = value; this.updateFont(this._fontComponents); } }); Object.defineProperty(Phaser.Text.prototype, 'fontStyle', { get: function() { return this._fontComponents.fontStyle || 'normal'; }, set: function(value) { value = value || 'normal'; this._fontComponents.fontStyle = value; this.updateFont(this._fontComponents); } }); Object.defineProperty(Phaser.Text.prototype, 'fontVariant', { get: function() { return this._fontComponents.fontVariant || 'normal'; }, set: function(value) { value = value || 'normal'; this._fontComponents.fontVariant = value; this.updateFont(this._fontComponents); } }); Object.defineProperty(Phaser.Text.prototype, 'fill', { get: function() { return this.style.fill; }, set: function(value) { if (value !== this.style.fill) { this.style.fill = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'align', { get: function() { return this.style.align; }, set: function(value) { if (value !== this.style.align) { this.style.align = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'resolution', { get: function() { return this._res; }, set: function(value) { if (value !== this._res) { this._res = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'tabs', { get: function() { return this.style.tabs; }, set: function(value) { if (value !== this.style.tabs) { this.style.tabs = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'boundsAlignH', { get: function() { return this.style.boundsAlignH; }, set: function(value) { if (value !== this.style.boundsAlignH) { this.style.boundsAlignH = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'boundsAlignV', { get: function() { return this.style.boundsAlignV; }, set: function(value) { if (value !== this.style.boundsAlignV) { this.style.boundsAlignV = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'stroke', { get: function() { return this.style.stroke; }, set: function(value) { if (value !== this.style.stroke) { this.style.stroke = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'strokeThickness', { get: function() { return this.style.strokeThickness; }, set: function(value) { if (value !== this.style.strokeThickness) { this.style.strokeThickness = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'wordWrap', { get: function() { return this.style.wordWrap; }, set: function(value) { if (value !== this.style.wordWrap) { this.style.wordWrap = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'wordWrapWidth', { get: function() { return this.style.wordWrapWidth; }, set: function(value) { if (value !== this.style.wordWrapWidth) { this.style.wordWrapWidth = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'lineSpacing', { get: function() { return this._lineSpacing; }, set: function(value) { if (value !== this._lineSpacing) { this._lineSpacing = parseFloat(value); this.dirty = true; if (this.parent) { this.updateTransform(); } } } }); Object.defineProperty(Phaser.Text.prototype, 'shadowOffsetX', { get: function() { return this.style.shadowOffsetX; }, set: function(value) { if (value !== this.style.shadowOffsetX) { this.style.shadowOffsetX = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'shadowOffsetY', { get: function() { return this.style.shadowOffsetY; }, set: function(value) { if (value !== this.style.shadowOffsetY) { this.style.shadowOffsetY = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'shadowColor', { get: function() { return this.style.shadowColor; }, set: function(value) { if (value !== this.style.shadowColor) { this.style.shadowColor = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'shadowBlur', { get: function() { return this.style.shadowBlur; }, set: function(value) { if (value !== this.style.shadowBlur) { this.style.shadowBlur = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'shadowStroke', { get: function() { return this.style.shadowStroke; }, set: function(value) { if (value !== this.style.shadowStroke) { this.style.shadowStroke = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'shadowFill', { get: function() { return this.style.shadowFill; }, set: function(value) { if (value !== this.style.shadowFill) { this.style.shadowFill = value; this.dirty = true; } } }); Object.defineProperty(Phaser.Text.prototype, 'width', { get: function() { if (this.dirty) { this.updateText(); this.dirty = false; } return this.scale.x * this.texture.frame.width; }, set: function(value) { this.scale.x = value / this.texture.frame.width; this._width = value; } }); Object.defineProperty(Phaser.Text.prototype, 'height', { get: function() { if (this.dirty) { this.updateText(); this.dirty = false; } return this.scale.y * this.texture.frame.height; }, set: function(value) { this.scale.y = value / this.texture.frame.height; this._height = value; } }); Phaser.Text.fontPropertiesCache = {}; Phaser.Text.fontPropertiesCanvas = document.createElement('canvas'); Phaser.Text.fontPropertiesContext = Phaser.Text.fontPropertiesCanvas.getContext('2d'); Phaser.BitmapText = function (game, x, y, font, text, size, align) { x = x || 0; y = y || 0; font = font || ''; text = text || ''; size = size || 32; align = align || 'left'; PIXI.DisplayObjectContainer.call(this); this.type = Phaser.BITMAPTEXT; this.physicsType = Phaser.SPRITE; this.textWidth = 0; this.textHeight = 0; this.anchor = new Phaser.Point(); this._prevAnchor = new Phaser.Point(); this._glyphs = []; this._maxWidth = 0; this._text = text.toString() || ''; this._data = game.cache.getBitmapFont(font); this._font = font; this._fontSize = size; this._align = align; this._tint = 0xFFFFFF; this.updateText(); this.dirty = false; Phaser.Component.Core.init.call(this, game, x, y, '', null); }; Phaser.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype); Phaser.BitmapText.prototype.constructor = Phaser.BitmapText; Phaser.Component.Core.install.call(Phaser.BitmapText.prototype, [ 'Angle', 'AutoCull', 'Bounds', 'Destroy', 'FixedToCamera', 'InputEnabled', 'InWorld', 'LifeSpan', 'PhysicsBody', 'Reset' ]); Phaser.BitmapText.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate; Phaser.BitmapText.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate; Phaser.BitmapText.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate; Phaser.BitmapText.prototype.preUpdateCore = Phaser.Component.Core.preUpdate; Phaser.BitmapText.prototype.preUpdate = function () { if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) { return false; } return this.preUpdateCore(); }; Phaser.BitmapText.prototype.postUpdate = function () { Phaser.Component.PhysicsBody.postUpdate.call(this); Phaser.Component.FixedToCamera.postUpdate.call(this); if (this.body && this.body.type === Phaser.Physics.ARCADE) { if ((this.textWidth !== this.body.sourceWidth) || (this.textHeight !== this.body.sourceHeight)) { this.body.setSize(this.textWidth, this.textHeight); } } }; Phaser.BitmapText.prototype.setText = function (text) { this.text = text; }; Phaser.BitmapText.prototype.scanLine = function (data, scale, text) { var x = 0; var w = 0; var lastSpace = -1; var wrappedWidth = 0; var prevCharCode = null; var maxWidth = (this._maxWidth > 0) ? this._maxWidth : null; var chars = []; for (var i = 0; i < text.length; i++) { var end = (i === text.length - 1) ? true : false; if (/(?:\r\n|\r|\n)/.test(text.charAt(i))) { return { width: w, text: text.substr(0, i), end: end, chars: chars }; } else { var charCode = text.charCodeAt(i); var charData = data.chars[charCode]; var c = 0; if (charData === undefined) { charCode = 32; charData = data.chars[charCode]; } var kerning = (prevCharCode && charData.kerning[prevCharCode]) ? charData.kerning[prevCharCode] : 0; if (/(\s)/.test(text.charAt(i))) { lastSpace = i; wrappedWidth = w; } c = (kerning + charData.texture.width + charData.xOffset) * scale; if (maxWidth && ((w + c) >= maxWidth) && lastSpace > -1) { return { width: wrappedWidth || w, text: text.substr(0, i - (i - lastSpace)), end: end, chars: chars }; } else { w += (charData.xAdvance + kerning) * scale; chars.push(x + (charData.xOffset + kerning) * scale); x += (charData.xAdvance + kerning) * scale; prevCharCode = charCode; } } } return { width: w, text: text, end: end, chars: chars }; }; Phaser.BitmapText.prototype.cleanText = function (text, replace) { if (replace === undefined) { replace = ''; } var data = this._data.font; if (!data) { return ''; } var re = /\r\n|\n\r|\n|\r/g; var lines = text.replace(re, "\n").split("\n"); for (var i = 0; i < lines.length; i++) { var output = ''; var line = lines[i]; for (var c = 0; c < line.length; c++) { if (data.chars[line.charCodeAt(c)]) { output = output.concat(line[c]); } else { output = output.concat(replace); } } lines[i] = output; } return lines.join("\n"); }; Phaser.BitmapText.prototype.updateText = function () { var data = this._data.font; if (!data) { return; } var text = this.text; var scale = this._fontSize / data.size; var lines = []; var y = 0; this.textWidth = 0; do { var line = this.scanLine(data, scale, text); line.y = y; lines.push(line); if (line.width > this.textWidth) { this.textWidth = line.width; } y += (data.lineHeight * scale); text = text.substr(line.text.length + 1); } while (line.end === false); this.textHeight = y; var t = 0; var align = 0; var ax = this.textWidth * this.anchor.x; var ay = this.textHeight * this.anchor.y; for (var i = 0; i < lines.length; i++) { var line = lines[i]; if (this._align === 'right') { align = this.textWidth - line.width; } else if (this._align === 'center') { align = (this.textWidth - line.width) / 2; } for (var c = 0; c < line.text.length; c++) { var charCode = line.text.charCodeAt(c); var charData = data.chars[charCode]; if (charData === undefined) { charCode = 32; charData = data.chars[charCode]; } var g = this._glyphs[t]; if (g) { g.texture = charData.texture; } else { g = new PIXI.Sprite(charData.texture); g.name = line.text[c]; this._glyphs.push(g); } g.position.x = (line.chars[c] + align) - ax; g.position.y = (line.y + (charData.yOffset * scale)) - ay; g.scale.set(scale); g.tint = this.tint; g.texture.requiresReTint = true; if (!g.parent) { this.addChild(g); } t++; } } for (i = t; i < this._glyphs.length; i++) { this.removeChild(this._glyphs[i]); } }; Phaser.BitmapText.prototype.purgeGlyphs = function () { var len = this._glyphs.length; var kept = []; for (var i = 0; i < this._glyphs.length; i++) { if (this._glyphs[i].parent !== this) { this._glyphs[i].destroy(); } else { kept.push(this._glyphs[i]); } } this._glyphs = []; this._glyphs = kept; this.updateText(); return len - kept.length; }; Phaser.BitmapText.prototype.updateTransform = function () { if (this.dirty || !this.anchor.equals(this._prevAnchor)) { this.updateText(); this.dirty = false; this._prevAnchor.copyFrom(this.anchor); } PIXI.DisplayObjectContainer.prototype.updateTransform.call(this); }; Object.defineProperty(Phaser.BitmapText.prototype, 'align', { get: function() { return this._align; }, set: function(value) { if (value !== this._align && (value === 'left' || value === 'center' || value === 'right')) { this._align = value; this.updateText(); } } }); Object.defineProperty(Phaser.BitmapText.prototype, 'tint', { get: function() { return this._tint; }, set: function(value) { if (value !== this._tint) { this._tint = value; this.updateText(); } } }); Object.defineProperty(Phaser.BitmapText.prototype, 'font', { get: function() { return this._font; }, set: function(value) { if (value !== this._font) { this._font = value.trim(); this._data = this.game.cache.getBitmapFont(this._font); this.updateText(); } } }); Object.defineProperty(Phaser.BitmapText.prototype, 'fontSize', { get: function() { return this._fontSize; }, set: function(value) { value = parseInt(value, 10); if (value !== this._fontSize && value > 0) { this._fontSize = value; this.updateText(); } } }); Object.defineProperty(Phaser.BitmapText.prototype, 'text', { get: function() { return this._text; }, set: function(value) { if (value !== this._text) { this._text = value.toString() || ''; this.updateText(); } } }); Object.defineProperty(Phaser.BitmapText.prototype, 'maxWidth', { get: function() { return this._maxWidth; }, set: function(value) { if (value !== this._maxWidth) { this._maxWidth = value; this.updateText(); } } }); Object.defineProperty(Phaser.BitmapText.prototype, 'smoothed', { get: function() { return !this._data.base.scaleMode; }, set: function(value) { if (value) { this._data.base.scaleMode = 0; } else { this._data.base.scaleMode = 1; } } }); Phaser.RetroFont = function (game, key, characterWidth, characterHeight, chars, charsPerRow, xSpacing, ySpacing, xOffset, yOffset) { if (!game.cache.checkImageKey(key)) { return false; } if (charsPerRow === undefined || charsPerRow === null) { charsPerRow = game.cache.getImage(key).width / characterWidth; } this.characterWidth = characterWidth; this.characterHeight = characterHeight; this.characterSpacingX = xSpacing || 0; this.characterSpacingY = ySpacing || 0; this.characterPerRow = charsPerRow; this.offsetX = xOffset || 0; this.offsetY = yOffset || 0; this.align = "left"; this.multiLine = false; this.autoUpperCase = true; this.customSpacingX = 0; this.customSpacingY = 0; this.fixedWidth = 0; this.fontSet = game.cache.getImage(key); this._text = ''; this.grabData = []; this.frameData = new Phaser.FrameData(); var currentX = this.offsetX; var currentY = this.offsetY; var r = 0; for (var c = 0; c < chars.length; c++) { var frame = this.frameData.addFrame(new Phaser.Frame(c, currentX, currentY, this.characterWidth, this.characterHeight)); this.grabData[chars.charCodeAt(c)] = frame.index; r++; if (r === this.characterPerRow) { r = 0; currentX = this.offsetX; currentY += this.characterHeight + this.characterSpacingY; } else { currentX += this.characterWidth + this.characterSpacingX; } } game.cache.updateFrameData(key, this.frameData); this.stamp = new Phaser.Image(game, 0, 0, key, 0); Phaser.RenderTexture.call(this, game, 100, 100, '', Phaser.scaleModes.NEAREST); this.type = Phaser.RETROFONT; }; Phaser.RetroFont.prototype = Object.create(Phaser.RenderTexture.prototype); Phaser.RetroFont.prototype.constructor = Phaser.RetroFont; Phaser.RetroFont.ALIGN_LEFT = "left"; Phaser.RetroFont.ALIGN_RIGHT = "right"; Phaser.RetroFont.ALIGN_CENTER = "center"; Phaser.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"; Phaser.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"; Phaser.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 "; Phaser.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789"; Phaser.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789"; Phaser.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' "; Phaser.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39"; Phaser.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ"; Phaser.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!"; Phaser.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; Phaser.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789"; Phaser.RetroFont.prototype.setFixedWidth = function (width, lineAlignment) { if (lineAlignment === undefined) { lineAlignment = 'left'; } this.fixedWidth = width; this.align = lineAlignment; }; Phaser.RetroFont.prototype.setText = function (content, multiLine, characterSpacing, lineSpacing, lineAlignment, allowLowerCase) { this.multiLine = multiLine || false; this.customSpacingX = characterSpacing || 0; this.customSpacingY = lineSpacing || 0; this.align = lineAlignment || 'left'; if (allowLowerCase) { this.autoUpperCase = false; } else { this.autoUpperCase = true; } if (content.length > 0) { this.text = content; } }; Phaser.RetroFont.prototype.buildRetroFontText = function () { var cx = 0; var cy = 0; this.clear(); if (this.multiLine) { var lines = this._text.split("\n"); if (this.fixedWidth > 0) { this.resize(this.fixedWidth, (lines.length * (this.characterHeight + this.customSpacingY)) - this.customSpacingY, true); } else { this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), (lines.length * (this.characterHeight + this.customSpacingY)) - this.customSpacingY, true); } for (var i = 0; i < lines.length; i++) { cx = 0; if (this.align === Phaser.RetroFont.ALIGN_RIGHT) { cx = this.width - (lines[i].length * (this.characterWidth + this.customSpacingX)); } else if (this.align === Phaser.RetroFont.ALIGN_CENTER) { cx = (this.width / 2) - ((lines[i].length * (this.characterWidth + this.customSpacingX)) / 2); cx += this.customSpacingX / 2; } if (cx < 0) { cx = 0; } this.pasteLine(lines[i], cx, cy, this.customSpacingX); cy += this.characterHeight + this.customSpacingY; } } else { if (this.fixedWidth > 0) { this.resize(this.fixedWidth, this.characterHeight, true); } else { this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, true); } cx = 0; if (this.align === Phaser.RetroFont.ALIGN_RIGHT) { cx = this.width - (this._text.length * (this.characterWidth + this.customSpacingX)); } else if (this.align === Phaser.RetroFont.ALIGN_CENTER) { cx = (this.width / 2) - ((this._text.length * (this.characterWidth + this.customSpacingX)) / 2); cx += this.customSpacingX / 2; } if (cx < 0) { cx = 0; } this.pasteLine(this._text, cx, 0, this.customSpacingX); } this.requiresReTint = true; }; Phaser.RetroFont.prototype.pasteLine = function (line, x, y, customSpacingX) { for (var c = 0; c < line.length; c++) { if (line.charAt(c) === " ") { x += this.characterWidth + customSpacingX; } else { if (this.grabData[line.charCodeAt(c)] >= 0) { this.stamp.frame = this.grabData[line.charCodeAt(c)]; this.renderXY(this.stamp, x, y, false); x += this.characterWidth + customSpacingX; if (x > this.width) { break; } } } } }; Phaser.RetroFont.prototype.getLongestLine = function () { var longestLine = 0; if (this._text.length > 0) { var lines = this._text.split("\n"); for (var i = 0; i < lines.length; i++) { if (lines[i].length > longestLine) { longestLine = lines[i].length; } } } return longestLine; }; Phaser.RetroFont.prototype.removeUnsupportedCharacters = function (stripCR) { var newString = ""; for (var c = 0; c < this._text.length; c++) { var aChar = this._text[c]; var code = aChar.charCodeAt(0); if (this.grabData[code] >= 0 || (!stripCR && aChar === "\n")) { newString = newString.concat(aChar); } } return newString; }; Phaser.RetroFont.prototype.updateOffset = function (x, y) { if (this.offsetX === x && this.offsetY === y) { return; } var diffX = x - this.offsetX; var diffY = y - this.offsetY; var frames = this.game.cache.getFrameData(this.stamp.key).getFrames(); var i = frames.length; while (i--) { frames[i].x += diffX; frames[i].y += diffY; } this.buildRetroFontText(); }; Object.defineProperty(Phaser.RetroFont.prototype, "text", { get: function () { return this._text; }, set: function (value) { var newText; if (this.autoUpperCase) { newText = value.toUpperCase(); } else { newText = value; } if (newText !== this._text) { this._text = newText; this.removeUnsupportedCharacters(this.multiLine); this.buildRetroFontText(); } } }); Object.defineProperty(Phaser.RetroFont.prototype, "smoothed", { get: function () { return this.stamp.smoothed; }, set: function (value) { this.stamp.smoothed = value; this.buildRetroFontText(); } }); Phaser.Rope = function (game, x, y, key, frame, points) { this.points = []; this.points = points; this._hasUpdateAnimation = false; this._updateAnimationCallback = null; x = x || 0; y = y || 0; key = key || null; frame = frame || null; this.type = Phaser.ROPE; PIXI.Rope.call(this, Phaser.Cache.DEFAULT, this.points); Phaser.Component.Core.init.call(this, game, x, y, key, frame); }; Phaser.Rope.prototype = Object.create(PIXI.Rope.prototype); Phaser.Rope.prototype.constructor = Phaser.Rope; Phaser.Component.Core.install.call(Phaser.Rope.prototype, [ 'Angle', 'Animation', 'AutoCull', 'Bounds', 'BringToTop', 'Crop', 'Delta', 'Destroy', 'FixedToCamera', 'InWorld', 'LifeSpan', 'LoadTexture', 'Overlap', 'PhysicsBody', 'Reset', 'ScaleMinMax', 'Smoothed' ]); Phaser.Rope.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate; Phaser.Rope.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate; Phaser.Rope.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate; Phaser.Rope.prototype.preUpdateCore = Phaser.Component.Core.preUpdate; Phaser.Rope.prototype.preUpdate = function() { if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) { return false; } return this.preUpdateCore(); }; Phaser.Rope.prototype.update = function() { if (this._hasUpdateAnimation) { this.updateAnimation.call(this); } }; Phaser.Rope.prototype.reset = function(x, y) { Phaser.Component.Reset.prototype.reset.call(this, x, y); return this; }; Object.defineProperty(Phaser.Rope.prototype, "updateAnimation", { get: function () { return this._updateAnimation; }, set: function (value) { if (value && typeof value === 'function') { this._hasUpdateAnimation = true; this._updateAnimation = value; } else { this._hasUpdateAnimation = false; this._updateAnimation = null; } } }); Object.defineProperty(Phaser.Rope.prototype, "segments", { get: function() { var segments = []; var index, x1, y1, x2, y2, width, height, rect; for (var i = 0; i < this.points.length; i++) { index = i * 4; x1 = this.vertices[index] * this.scale.x; y1 = this.vertices[index + 1] * this.scale.y; x2 = this.vertices[index + 4] * this.scale.x; y2 = this.vertices[index + 3] * this.scale.y; width = Phaser.Math.difference(x1, x2); height = Phaser.Math.difference(y1, y2); x1 += this.world.x; y1 += this.world.y; rect = new Phaser.Rectangle(x1, y1, width, height); segments.push(rect); } return segments; } }); Phaser.TileSprite = function (game, x, y, width, height, key, frame) { x = x || 0; y = y || 0; width = width || 256; height = height || 256; key = key || null; frame = frame || null; this.type = Phaser.TILESPRITE; this.physicsType = Phaser.SPRITE; this._scroll = new Phaser.Point(); var def = game.cache.getImage('__default', true); PIXI.TilingSprite.call(this, new PIXI.Texture(def.base), width, height); Phaser.Component.Core.init.call(this, game, x, y, key, frame); }; Phaser.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype); Phaser.TileSprite.prototype.constructor = Phaser.TileSprite; Phaser.Component.Core.install.call(Phaser.TileSprite.prototype, [ 'Angle', 'Animation', 'AutoCull', 'Bounds', 'BringToTop', 'Destroy', 'FixedToCamera', 'Health', 'InCamera', 'InputEnabled', 'InWorld', 'LifeSpan', 'LoadTexture', 'Overlap', 'PhysicsBody', 'Reset', 'Smoothed' ]); Phaser.TileSprite.prototype.preUpdatePhysics = Phaser.Component.PhysicsBody.preUpdate; Phaser.TileSprite.prototype.preUpdateLifeSpan = Phaser.Component.LifeSpan.preUpdate; Phaser.TileSprite.prototype.preUpdateInWorld = Phaser.Component.InWorld.preUpdate; Phaser.TileSprite.prototype.preUpdateCore = Phaser.Component.Core.preUpdate; Phaser.TileSprite.prototype.preUpdate = function() { if (this._scroll.x !== 0) { this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed; } if (this._scroll.y !== 0) { this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed; } if (!this.preUpdatePhysics() || !this.preUpdateLifeSpan() || !this.preUpdateInWorld()) { return false; } return this.preUpdateCore(); }; Phaser.TileSprite.prototype.autoScroll = function(x, y) { this._scroll.set(x, y); }; Phaser.TileSprite.prototype.stopScroll = function() { this._scroll.set(0, 0); }; Phaser.TileSprite.prototype.destroy = function(destroyChildren) { Phaser.Component.Destroy.prototype.destroy.call(this, destroyChildren); PIXI.TilingSprite.prototype.destroy.call(this); }; Phaser.TileSprite.prototype.reset = function(x, y) { Phaser.Component.Reset.prototype.reset.call(this, x, y); this.tilePosition.x = 0; this.tilePosition.y = 0; return this; };